{
  "DeBruijnSeq": {
    "prefix":["benq_DeBruijnSeq"],
    "body": [
      "/**",
      " * Description: Recursive FKM, given alphabet \\$[0,k)\\$ constructs cyclic string ",
      " \t* of length \\$k^n\\$ that contains every length \\$n\\$ string as substr. ",
      " * Source: https://github.com/koosaga/DeobureoMinkyuParty/blob/master/teamnote.tex",
      " \t* https://en.wikipedia.org/wiki/De_Bruijn_sequence",
      " \t* pg 241 of http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.93.5967&rep=rep1&type=pdf ",
      " * Verification: https://codeforces.com/gym/102001/problem/C",
      " */ ",
      "",
      "vi dseq(int k, int n) { ",
      "\tif (k == 1) return {0};",
      "\tvi res, aux(n+1); ",
      "\tfunction<void(int,int)> gen = [&](int t, int p) {",
      "\t\tif (t > n) { // consider lyndon word of len p",
      "\t\t\tif (n%p == 0) FOR(i,1,p+1) res.pb(aux[i]); ",
      "\t\t} else {",
      "\t\t\taux[t] = aux[t-p]; gen(t+1,p);",
      "\t\t\tFOR(i,aux[t-p]+1,k) aux[t] = i, gen(t+1,t);",
      "\t\t}",
      "\t};",
      "\tgen(1,1); return res;",
      "}"
    ],
    "description": "Recursive FKM, given alphabet \\$[0,k)\\$ constructs cyclic string ,  * of length \\$k^n\\$ that contains every length \\$n\\$ string as substr. , *"
  },
  "IntPerm": {
    "prefix":["benq_IntPerm"],
    "body": [
      "/**",
      " * Description: Unused. Convert permutation of \\$\\{0,1,...,N-1\\}\\$ to integer in \\$[0,N!)\\$ and back.",
      " * Source: http://antoinecomeau.blogspot.com/2014/07/mapping-between-permutations-and.html",
      " * Verification: ?",
      " * Time: O(N)",
      " * Usage: assert(encode(decode(5,37)) == 37);",
      " */",
      "",
      "vi decode(int n, int a) {",
      "\tvi el(n), b; iota(all(el),0);",
      "\tF0R(i,n) {",
      "\t\tint z = a%sz(el);",
      "\t\tb.pb(el[z]); a /= sz(el);",
      "\t\tswap(el[z],el.bk); el.pop_back();",
      "\t}",
      "\treturn b;",
      "}",
      "int encode(vi b) {",
      "\tint n = sz(b), a = 0, mul = 1;",
      "\tvi pos(n); iota(all(pos),0); vi el = pos;",
      "\tF0R(i,n) {",
      "\t\tint z = pos[b[i]]; a += mul*z; mul *= sz(el);",
      "\t\tswap(pos[el[z]],pos[el.bk]); ",
      "\t\tswap(el[z],el.bk); el.pop_back();",
      "\t}",
      "\treturn a;",
      "}"
    ],
    "description": "Unused. Convert permutation of \\$\\{0,1,...,N-1\\}\\$ to integer in \\$[0,N!)\\$ and back., *"
  },
  "MatroidIsect": {
    "prefix":["benq_MatroidIsect"],
    "body": [
      "/**",
      " * Description: Computes a set of maximum size which is independent ",
      " \t* in both graphic and colorful matroids, aka a spanning forest where",
      " \t* no two edges are of the same color. In general, construct the exchange",
      " \t* graph and find a shortest path. Can apply similar concept to partition",
      " \t* matroid.",
      " * Time: \\$O(GI^{1.5})\\$ calls to oracles, where \\$G\\$ is size of ground set ",
      " \t* and \\$I\\$ is size of independent set.",
      " * Source: https://codeforces.com/blog/entry/69287",
      " \t* chilli (KACTL)",
      " * Verification: https://www.spoj.com/problems/COIN/",
      " * Usage: MatroidIsect<Gmat,Cmat> M(sz(ed),Gmat(ed),Cmat(col))",
      " */",
      "",
      "#include \"../graphs (12)/DSU/DSU (7.6).h\"",
      "",
      "struct Gmat { // graphic matroid",
      "\tint V = 0; vpi ed; DSU D;",
      "\tGmat(vpi ed):ed(ed) {",
      "\t\tmap<int,int> m; each(t,ed) m[t.f] = m[t.s] = 0;",
      "\t\teach(t,m) t.s = V++; ",
      "\t\teach(t,this->ed) t.f = m[t.f], t.s = m[t.s];",
      "\t}",
      "\tvoid clear() { D.init(V); }",
      "\tvoid ins(int i) { assert(D.unite(ed[i].f,ed[i].s)); }",
      "\tbool indep(int i) { return !D.sameSet(ed[i].f,ed[i].s); }",
      "};",
      "struct Cmat { // colorful matroid",
      "\tint C = 0; vi col; vector<bool> used;",
      "\tCmat(vi col):col(col) {each(t,col) ckmax(C,t+1); }",
      "\tvoid clear() { used.assign(C,0); }",
      "\tvoid ins(int i) { used[col[i]] = 1; }",
      "\tbool indep(int i) { return !used[col[i]]; }",
      "};",
      "template<class M1, class M2> struct MatroidIsect {",
      "\tint n; vector<bool> iset; M1 m1; M2 m2;",
      "\tbool augment() {",
      "\t\tvi pre(n+1,-1); queue<int> q({n});",
      "\t\twhile (sz(q)) {",
      "\t\t\tint x = q.ft; q.pop();",
      "\t\t\tif (iset[x]) {",
      "\t\t\t\tm1.clear(); F0R(i,n) if (iset[i] && i != x) m1.ins(i);",
      "\t\t\t\tF0R(i,n) if (!iset[i] && pre[i] == -1 && m1.indep(i))",
      "\t\t\t\t\tpre[i] = x, q.push(i);",
      "\t\t\t} else {",
      "\t\t\t\tauto backE = [&]() { // back edge",
      "\t\t\t\t\tm2.clear(); ",
      "\t\t\t\t\tF0R(c,2)F0R(i,n)if((x==i||iset[i])&&(pre[i]==-1)==c){",
      "\t\t\t\t\t\tif (!m2.indep(i))return c?pre[i]=x,q.push(i),i:-1;",
      "\t\t\t\t\t\tm2.ins(i); }",
      "\t\t\t\t\treturn n; ",
      "\t\t\t\t};",
      "\t\t\t\tfor (int y; (y = backE()) != -1;) if (y == n) { ",
      "\t\t\t\t\tfor(; x != n; x = pre[x]) iset[x] = !iset[x];",
      "\t\t\t\t\treturn 1; }",
      "\t\t\t}",
      "\t\t}",
      "\t\treturn 0;",
      "\t}",
      "\tMatroidIsect(int n, M1 m1, M2 m2):n(n), m1(m1), m2(m2) {",
      "\t\tiset.assign(n+1,0); iset[n] = 1;",
      "\t\tm1.clear(); m2.clear(); // greedily add to basis",
      "\t\tR0F(i,n) if (m1.indep(i) && m2.indep(i)) ",
      "\t\t\tiset[i] = 1, m1.ins(i), m2.ins(i); ",
      "\t\twhile (augment());",
      "\t}",
      "};",
      "",
      "/**",
      "int main() {",
      "\tsetIO();",
      "\tint r; ",
      "\twhile (cin >> r) {",
      "\t\tif (!r) break;",
      "\t\tvpi ed; vi col;",
      "\t\tF0R(i,r) {",
      "\t\t\tint a,b,c,d; re(a,b,c,d);",
      "\t\t\ted.pb({a,b}), ed.pb({c,d});",
      "\t\t\tcol.pb(i); col.pb(i);",
      "\t\t}",
      "\t\tMatroidIsect<Gmat,Cmat> M(sz(ed),Gmat(ed),Cmat(col));",
      "\t\tint cnt = 0; F0R(i,M.n) cnt += M.iset[i];",
      "\t\tps(2*cnt);",
      "\t}",
      "}",
      "*/"
    ],
    "description": "Computes a set of maximum size which is independent ,  * in both graphic and colorful matroids, aka a spanning forest where,  * no two edges are of the same color. In general, construct the exchange,  * graph and find a shortest path. Can apply similar concept to partition,  * matroid., * Time: \\$O(GI^{1.5})\\$ calls to oracles, where \\$G\\$ is size of ground set ,  * and \\$I\\$ is size of independent set., *"
  },
  "MatroidPart": {
    "prefix":["benq_MatroidPart"],
    "body": [
      "/**",
      " * Description: Find three edge-disjoint spanning trees ",
      " \t* (matroid partition)",
      " * Time: ?",
      " * Source: https://codeforces.com/blog/entry/69287",
      " \t* chilli (KACTL)",
      " * Verification: https://dmoj.ca/problem/dmopc19c3p6",
      " * Usage: MatroidPart<Gmat>(n,3,3*(N-1),Gmat(ed))",
      " */",
      "",
      " struct Gmat { // graphic matroid",
      "\tint V = 0; vpi ed; DSU D;",
      "\tvi depth;",
      "\tvector<vpi> adj;",
      "\tvpi pre;",
      "\tGmat(vpi ed):ed(ed) {",
      "\t\tmap<int,int> m; each(t,ed) m[t.f] = m[t.s] = 0;",
      "\t\teach(t,m) t.s = V++; ",
      "\t\teach(t,this->ed) t.f = m[t.f], t.s = m[t.s];",
      "\t}",
      "\tvoid clear() { D.init(V); adj = vector<vpi>(V); }",
      "\tvoid ins(int i) { assert(D.unite(ed[i].f,ed[i].s)); ",
      "\t\tadj[ed[i].f].pb({ed[i].s,i});",
      "\t\tadj[ed[i].s].pb({ed[i].f,i});",
      "\t}",
      "\tbool indep(int i) { return !D.sameSet(ed[i].f,ed[i].s); }",
      "\tvi backEdges(int x) {",
      "\t\tint a = ed[x].f, b = ed[x].s;",
      "\t\tvi v;",
      "\t\twhile (a != b) {",
      "\t\t\tif (depth[a] < depth[b]) swap(a,b);",
      "\t\t\tv.pb(pre[a].s); a = pre[a].f;",
      "\t\t}",
      "\t\tdbg(x,a,b,v);",
      "\t\treturn v;",
      "\t}",
      "\tvoid dfs(int x) {",
      "\t\teach(t,adj[x]) if (depth[t.f] == -1) {",
      "\t\t\tdepth[t.f] = depth[x]+1;",
      "\t\t\tpre[t.f] = {x,t.s};",
      "\t\t\tdfs(t.f);",
      "\t\t}",
      "\t}",
      "\tvoid genBack() {",
      "\t\tdepth = vi(V,-1); pre = vpi(V,{-1,-1});",
      "\t\tF0R(i,V) if (depth[i] == -1) {",
      "\t\t\tdepth[i] = 0;",
      "\t\t\tdfs(i);",
      "\t\t}",
      "\t}",
      "};",
      "",
      "template<class M> struct MatroidPart {",
      "\tint n,k; vi iset; ",
      "\tvector<M> m;",
      "\tbool augment(int st) {",
      "\t\tF0R(i,k) m[i].clear();",
      "\t\tF0R(i,n) if (iset[i] != -1) m[iset[i]].ins(i);",
      "\t\tF0R(i,k) m[i].genBack();",
      "\t\tvi pre(n,-1); pre[st] = n; queue<int> q({st});",
      "\t\twhile (sz(q)) {",
      "\t\t\tint x = q.ft; q.pop();",
      "\t\t\tF0R(z,k) if (z != iset[x]) {",
      "\t\t\t\tif (m[z].indep(x)) {",
      "\t\t\t\t\tfor (; x != n; x = pre[x]) swap(z,iset[x]);",
      "\t\t\t\t\treturn 1;",
      "\t\t\t\t}",
      "\t\t\t\tvi v = m[z].backEdges(x);",
      "\t\t\t\teach(t,v) if (pre[t] == -1) pre[t] = x, q.push(t);",
      "\t\t\t}",
      "\t\t}",
      "\t\treturn 0;",
      "\t}",
      "\tMatroidPart(int n, int k, int des, M _m):n(n),k(k) {",
      "\t\tiset.assign(n,-1); ",
      "\t\tm.assign(k,_m); F0R(i,k) m[i].clear();",
      "\t\tint cur = 0;",
      "\t\tF0R(j,k) F0R(i,n) if (iset[i] == -1 && m[j].indep(i)) ",
      "\t\t\tiset[i] = j, m[j].ins(i), cur ++;",
      "\t\tint lef = n-cur;",
      "\t\tF0R(i,n) if (iset[i] == -1) {",
      "\t\t\tcur += augment(i); lef --;",
      "\t\t\tif (cur == des || cur+lef < des) break;",
      "\t\t}",
      "\t}",
      "};"
    ],
    "description": "Find three edge-disjoint spanning trees ,  * (matroid partition), * Time: ?, *"
  },
  "NimProduct": {
    "prefix":["benq_NimProduct"],
    "body": [
      "/**",
      " * Description: Product of nimbers is associative, commutative, and distributive ",
      " \t* over addition (xor). Forms finite field of size \\$2^{2^k}.\\$ ",
      " \t* Defined by \\$ab=\\text{mex}(\\{a'b+ab'+a'b':a'<a,b'<b\\}).\\$ Application: ",
      " \t* Given 1D coin turning games \\$G_1,G_2\\$ \\$G_1\\times G_2\\$ is the 2D coin turning ",
      " \t* game defined as follows. If turning coins at \\$x_1,x_2,\\ldots,x_m\\$ is legal ",
      " \t* in \\$G_1\\$ and \\$y_1,y_2,\\ldots,y_n\\$ is legal in \\$G_2\\$, then turning coins at ",
      " \t* all positions \\$(x_i,y_j)\\$ is legal assuming that the coin at \\$(x_m,y_n)\\$ ",
      " \t* goes from heads to tails. Then the grundy function \\$g(x,y)\\$ of \\$G_1\\times G_2\\$ ",
      " \t* is \\$g_1(x)\\times g_2(y).\\$ ",
      " * Source: Andrew He",
      " \t* also see pg 35 of https://www.fmf.uni-lj.si/~juvan/Seminar1/ferguson.pdf",
      " \t* https://en.wikipedia.org/wiki/Nimber",
      " \t* https://judge.yosupo.jp/submission/6485",
      " * Time: \\$64^2\\$ xors per multiplication, memorize to speed up.",
      " * Verification: https://codeforces.com/gym/102341/problem/L",
      " \t* https://projecteuler.net/problem=459",
      " \t* https://judge.yosupo.jp/problem/nim_product_64",
      " */",
      "",
      "using ul = uint64_t; ",
      "",
      "struct Precalc {",
      "\tul tmp[64][64], y[8][8][256];",
      "\tunsigned char x[256][256];",
      "\tPrecalc() { // small nim products, all < 256",
      "\t\tF0R(i,256) F0R(j,256) x[i][j] = mult<8>(i,j); ",
      "\t\tF0R(i,8) F0R(j,i+1) F0R(k,256)",
      "\t\t\ty[i][j][k] = mult<64>(prod2(8*i,8*j),k);",
      "\t}",
      "\tul prod2(int i, int j) { // nim prod of 2^i, 2^j",
      "\t\tul& u = tmp[i][j]; if (u) return u;",
      "\t\tif (!(i&j)) return u = 1ULL<<(i|j);",
      "\t\tint a = (i&j)&-(i&j); // a=2^k, consider 2^{2^k}",
      "\t\treturn u=prod2(i^a,j)^prod2((i^a)|(a-1),(j^a)|(i&(a-1)));",
      "\t\t// 2^{2^k}*2^{2^k} = 2^{2^k}+2^{2^k-1}",
      "\t} // 2^{2^i}*2^{2^j} = 2^{2^i+2^j} if i<j",
      "\ttemplate<int L> ul mult(ul a, ul b) {",
      "\t\tul c = 0; F0R(i,L) if (a>>i&1) ",
      "\t\t\tF0R(j,L) if (b>>j&1) c ^= prod2(i,j);",
      "\t\treturn c;",
      "\t}",
      "\t// 2^{8*i}*(a>>(8*i)&255) * 2^{8*j}*(b>>(8*j)&255)",
      "\t// -> (2^{8*i}*2^{8*j})*((a>>(8*i)&255)*(b>>(8*j)&255))",
      "\tul multFast(ul a, ul b) const { // faster nim product",
      "\t\tul res = 0; auto f = [](ul c, int d) { return c>>(8*d)&255; };",
      "\t\tF0R(i,8) {",
      "\t\t\tF0R(j,i) res ^= y[i][j][x[f(a,i)][f(b,j)]^x[f(a,j)][f(b,i)]];",
      "\t\t\tres ^= y[i][i][x[f(a,i)][f(b,i)]];",
      "\t\t}",
      "\t\treturn res;",
      "\t}",
      "};",
      "const Precalc P;",
      "",
      "struct nb { // nimber",
      "\tul x; nb() { x = 0; }",
      "\tnb(ul _x): x(_x) {}",
      "\texplicit operator ul() { return x; }",
      "\tnb operator+(nb y) { return nb(x^y.x); }",
      "\tnb operator*(nb y) { return nb(P.multFast(x,y.x)); }",
      "\tfriend nb pow(nb b, ul p) {",
      "\t\tnb res = 1; for (;p;p/=2,b=b*b) if (p&1) res = res*b;",
      "\t\treturn res; } // b^{2^{2^A}-1}=1 where 2^{2^A} > b",
      "\tfriend nb inv(nb b) { return pow(b,-2); }",
      "};"
    ],
    "description": "Product of nimbers is associative, commutative, and distributive ,  * over addition (xor). Forms finite field of size \\$2^{2^k}.\\$ ,  * Defined by \\$ab=\\text{mex}(\\{a'b+ab'+a'b':a'<a,b'<b\\}).\\$ Application: ,  * Given 1D coin turning games \\$G_1,G_2\\$ \\$G_1\\times G_2\\$ is the 2D coin turning ,  * game defined as follows. If turning coins at \\$x_1,x_2,\\ldots,x_m\\$ is legal ,  * in \\$G_1\\$ and \\$y_1,y_2,\\ldots,y_n\\$ is legal in \\$G_2\\$, then turning coins at ,  * all positions \\$(x_i,y_j)\\$ is legal assuming that the coin at \\$(x_m,y_n)\\$ ,  * goes from heads to tails. Then the grundy function \\$g(x,y)\\$ of \\$G_1\\times G_2\\$ ,  * is \\$g_1(x)\\times g_2(y).\\$ , *"
  },
  "PermGroup": {
    "prefix":["benq_PermGroup"],
    "body": [
      "/**",
      " * Description: Used only once. Schreier-Sims lets you",
      "\t* add a permutation to a group,",
      "\t* count number of permutations in a group,",
      "\t* and test whether a permutation is a member of a group.",
      " * Time: ?",
      " * Source: MIT NULL",
      "\t* see Zlobober's post in Russian version ",
      "\t* of https://codeforces.com/blog/entry/21335",
      " * Verification: GP of Ekateinburg - H",
      " */",
      "",
      "int n; ",
      "vi inv(vi v) { vi V(sz(v)); F0R(i,sz(v)) V[v[i]]=i; return V; }",
      "vi id() { vi v(n); iota(all(v),0); return v; }",
      "vi operator*(const vi& a, const vi& b) {",
      "\tvi c(sz(a)); F0R(i,sz(a)) c[i] = a[b[i]];",
      "\treturn c; }",
      "",
      "const int N = 15;",
      "struct Group {",
      "\tbool flag[N];",
      "\tvi sigma[N]; // sigma[t][k] = t, sigma[t][x] = x if x > k",
      "\tvector<vi> gen;",
      "\tvoid clear(int p) {",
      "\t\tmemset(flag,0,sizeof flag);",
      "\t\tflag[p] = 1; sigma[p] = id(); gen.clear();",
      "\t}",
      "} g[N];",
      "bool check(const vi& cur, int k) {",
      "\tif (!k) return 1;",
      "\tint t = cur[k];",
      "\treturn g[k].flag[t] ? check(inv(g[k].sigma[t])*cur,k-1) : 0;",
      "}",
      "void updateX(const vi& cur, int k);",
      "void ins(const vi& cur, int k) {",
      "\tif (check(cur,k)) return;",
      "\tg[k].gen.pb(cur);",
      "\tF0R(i,n) if (g[k].flag[i]) updateX(cur*g[k].sigma[i],k);",
      "}",
      "void updateX(const vi& cur, int k) {",
      "\tint t = cur[k]; // if flag, fixes k -> k",
      "\tif (g[k].flag[t]) ins(inv(g[k].sigma[t])*cur,k-1); ",
      "\telse { g[k].flag[t] = 1, g[k].sigma[t] = cur;",
      "\t\teach(x,g[k].gen) updateX(x*cur,k); }",
      "}",
      "ll order(vector<vi> gen) { ",
      "\tassert(sz(gen)); n = sz(gen[0]); F0R(i,n) g[i].clear(i);",
      "\teach(a,gen) ins(a,n-1); // insert perms into group one by one",
      "\tll tot = 1;",
      "\tF0R(i,n) {",
      "\t\tint cnt = 0; F0R(j,i+1) cnt += g[i].flag[j];",
      "\t\ttot *= cnt; }",
      "\treturn tot;",
      "}"
    ],
    "description": "Used only once. Schreier-Sims lets you, * add a permutation to a group,, * count number of permutations in a group,, * and test whether a permutation is a member of a group., * Time: ?, *"
  },
  "RSK": {
    "prefix":["benq_RSK"],
    "body": [
      "/**",
      " * Description: Computes \\$S(\\sigma)\\$ in Schensted's algorithm. ",
      " \t* All elements of \\$A\\$ should be distinct.",
      " * Source: Mark Gordon - https://gist.github.com/msg555/4242182",
      " \t* proof - https://books.google.com/books?hl=en&lr=&id=8uTMBQAAQBAJ&oi=fnd&pg=PA39&dq=+An+extension+of+Schensted%E2%80%99s+theorem&ots=GUiiGZFPVG&sig=JHTgu4N3-npZNnqCMwdRQTrXhfE#v=onepage&q=An%20extension%20of%20Schensted%E2%80%99s%20theorem&f=false",
      "\t* https://en.wikipedia.org/wiki/Robinson%E2%80%93Schensted%E2%80%93Knuth_correspondence",
      "\t* https://codeforces.com/blog/entry/16499?#comment-214121",
      " * Time: O(N^2) with naive, O(N\\sqrt N\\log N) with \\texttt{fastRsk}.",
      " * Verification: ?",
      " */",
      "",
      "/*Ex. \\sigma=(5,2,3,1,4)",
      "S(\\sigma) = 5 -> 2 -> 2 3 -> 1 3 -> 1 3 4",
      "                 5 -> 5      2      2",
      "                             5      5",
      "T(\\sigma) = 1 -> 1 -> 1 3 -> 1 3 -> 1 3 5",
      "                 2    2      2      2",
      "                             4      4",
      "*/",
      "vector<vi> boundedRsk(const vi& A, int k) {",
      "\tvector<vi> h(k);",
      "\tF0R(i,sz(A)) {",
      "\t\tint x = A[i];",
      "\t\tF0R(j,k) {",
      "\t\t\tint p = lb(all(h[j]),x)-begin(h[j]);",
      "\t\t\tif (p == sz(h[j])) { h[j].pb(x); break; }",
      "\t\t\tswap(x,h[j][p]);",
      "\t\t}",
      "\t}",
      "\treturn h;",
      "}",
      "vector<vi> fastRsk(vi A) {",
      "\tint rtn = (int)ceil(sqrt(sz(A)));",
      "\tauto ha = boundedRsk(A, rtn);",
      "\treverse(all(A)); auto hb = boundedRsk(A, rtn);",
      "\tha.rsz(sz(hb[0]));",
      "\tFOR(i,rtn,sz(hb[0])) for (int j = 0; i < sz(hb[j]); j++)",
      "\t\tha[i].pb(hb[j][i]);",
      "\treturn ha;",
      "}"
    ],
    "description": "Computes \\$S(\\sigma)\\$ in Schensted's algorithm. ,  * All elements of \\$A\\$ should be distinct., *"
  },
  "RSKrecover": {
    "prefix":["benq_RSKrecover"],
    "body": [
      "/**",
      " * Description: Recovers \\$k\\$ increasing disjoint subsequences that ",
      " \t* cover the maximum possible number of elements from \\$A\\$, ",
      " \t* which must be a permutation of \\$[0,N)\\$. ",
      " * Source: Mark Gordon, based on the method described in section 4 of Greene's ",
      " \t* \"An Extension of Schensted's Theorem\".",
      " * Time: O(MN), \\$M\\$ equals sum of sizes of subseqs",
      " * Verification: ?",
      " */",
      "",
      "vector<vi> RSKrecover(vi A, int k) {",
      "\tint N = sz(A); vector<vi> h(k); // current tableau",
      "\tvector<tuple<int,int,int>> swaps; // Run RSK algo",
      "\tF0R(i,N) { ",
      "\t\tint x = A[i];",
      "\t\tF0R(j,k) { // type 3 swaps: (y,z,x) -> (y,x,z) where x<y<z",
      "\t\t\tif (!sz(h[j]) || h[j].bk < x) { h[j].pb(x); break; } ",
      "\t\t\tfor (int y = sz(h[j])-1; ; --y) {",
      "\t\t\t\tif (y==0 || h[j][y-1]<x) { swap(x,h[j][y]); break; }",
      "\t\t\t\tswaps.eb(x,h[j][y-1],h[j][y]); ",
      "\t\t\t} // also type 2 swaps, but undoing them doesn't change ",
      "\t\t} // anything so no use storing",
      "\t}",
      "\twhile (!sz(h[k-1])) k --;",
      "\tvi nxt(N+1,-1), prv(N+1,-1); // Linked list with k increasing ",
      "\t// subseqs, initially the canonical representation of A",
      "\tF0R(i,k) { // just take first k rows",
      "\t\tprv[h[i][0]] = N;",
      "\t\tFOR(j,1,sz(h[i])) {",
      "\t\t\tint a = h[i][j-1], b = h[i][j];",
      "\t\t\tprv[b] = a, nxt[a] = b;",
      "\t\t}",
      "\t\tnxt[h[i].bk] = N;",
      "\t} // Replay the swaps backwards and adjust subseqs",
      "\tR0F(i,sz(swaps)) { // type 1 swaps: x<y<z, yxz -> yzx",
      "\t\tint x,y,z; tie(x,y,z) = swaps[i]; ",
      "\t\tif (nxt[x] != z) continue; // x and y not in same subseq",
      "\t\tif (nxt[y] == -1) { // swap x,y",
      "\t\t\tprv[y] = prv[x]; nxt[prv[y]] = y;",
      "\t\t\tnxt[y] = z; prv[z] = y;",
      "\t\t\tprv[x] = nxt[x] = -1;",
      "\t\t} else { // Splice lists; a->y->b and c->x->z->d ",
      "\t\t\tnxt[x] = nxt[y]; prv[nxt[x]] = x;",
      "\t\t\tnxt[y] = z; prv[z] = y;",
      "\t\t} // becomes a->y->z->d and c->x->b.",
      "\t} // Reconstruct actual subseqs from linked list",
      "\tint cnt = 0; vi seq(N,-1); vector<vi> res(k);",
      "\tF0R(i,N) if (prv[i] != -1) {",
      "\t\tseq[i] = prv[i] == N ? cnt++ : seq[prv[i]]; ",
      "\t\tres[seq[i]].pb(i); // start new or continue old seq",
      "\t}",
      "\treturn res;",
      "}",
      "",
      "/**",
      "int main() {",
      "\tint N = 10, k = 5; // re(N,k);",
      "\tvi A(N); // re(A);",
      "\tF0R(i,N) A[i] = i;",
      "\trandom_shuffle(all(A));",
      "\tps(A);",
      "\tvector<vi> B = RSKrecover(A, k);",
      "\tF0R(i,sz(B)) {",
      "\t\tF0R(j,sz(B[i])) {",
      "\t\t\tif (j) cout << ' ';",
      "\t\t\tcout << B[i][j];",
      "\t\t}",
      "\t\tcout << endl;",
      "\t}",
      "}",
      "*/"
    ],
    "description": "Recovers \\$k\\$ increasing disjoint subsequences that ,  * cover the maximum possible number of elements from \\$A\\$, ,  * which must be a permutation of \\$[0,N)\\$. , *"
  },
  "BIT": {
    "prefix":["benq_BIT"],
    "body": [
      "/**",
      " * Description: range sum queries and point updates for \\$D\\$ dimensions",
      " * Source: https://codeforces.com/blog/entry/64914",
      " * Verification: SPOJ matsum",
      " * Usage: \\texttt{BIT<int,10,10>} gives 2D BIT",
      " * Time: O((\\log N)^D)",
      " */",
      "",
      "template <class T, int ...Ns> struct BIT {",
      "\tT val = 0; void upd(T v) { val += v; }",
      "\tT query() { return val; }",
      "};",
      "template <class T, int N, int... Ns> struct BIT<T, N, Ns...> {",
      "\tBIT<T,Ns...> bit[N+1];",
      "\ttemplate<typename... Args> void upd(int pos, Args... args) { assert(pos > 0);",
      "\t\tfor (; pos<=N; pos+=pos&-pos) bit[pos].upd(args...); }",
      "\ttemplate<typename... Args> T sum(int r, Args... args) {",
      "\t\tT res=0; for (;r;r-=r&-r) res += bit[r].query(args...); ",
      "\t\treturn res; }",
      "\ttemplate<typename... Args> T query(int l, int r, Args... ",
      "\t\targs) { return sum(r,args...)-sum(l-1,args...); }",
      "}; ",
      "template<class T, int N> int get_kth(const BIT<T,N>& bit, T des) { ",
      "\tassert(des > 0);",
      "\tint ind = 0;",
      "\tfor (int i = 1<<bits(N); i; i /= 2)",
      "\t\tif (ind+i <= N && bit.bit[ind+i].val < des)",
      "\t\t\tdes -= bit.bit[ind += i].val;",
      "\tassert(ind < N); return ind+1;",
      "}"
    ],
    "description": "range sum queries and point updates for \\$D\\$ dimensions, *"
  },
  "BIToff": {
    "prefix":["benq_BIToff"],
    "body": [
      "/**",
      " * Description: Offline BIT with coordinate copmpression. First do all ",
      "   * updates with \\$\\texttt{mode=0}\\$ and then call \\$\\texttt{init()}\\$.",
      " * Source: Own",
      " * Verification: https://codeforces.com/contest/1361/problem/F",
      " */",
      "",
      "template<class T> struct BIToff {",
      "\tbool mode = 0; vi v; vector<T> d;",
      "\tint atMost(int x) { return ub(all(v),x)-begin(v); } // how many <= x",
      "\tvoid upd(int x, T y) {",
      "\t\tif (!mode) { v.pb(x); return; }",
      "\t\tint p = atMost(x); assert(p && v[p-1] == x);",
      "\t\tfor (;p<=sz(v);p+=p&-p) d[p] += y;",
      "\t}\t",
      "\tvoid init() { assert(!mode); mode = 1;",
      "\t\tsort(all(v)); v.erase(unique(all(v)),end(v)); d.rsz(sz(v)+1); }",
      "\tT sum(int x) { assert(mode);",
      "\t\tT ans = 0; for (int p=atMost(x);p;p-=p&-p) ans += d[p];",
      "\t\treturn ans; }",
      "\tT query(int x, int y) { return sum(y)-sum(x-1);}",
      "};"
    ],
    "description": "Offline BIT with coordinate copmpression. First do all ,   * updates with \\$\\texttt{mode=0}\\$ and then call \\$\\texttt{init()}\\$., *"
  },
  "BITrange": {
    "prefix":["benq_BITrange"],
    "body": [
      "/**",
      " * Description: \\$D\\$-dimensional range increment and sum query with \\$2^D\\$ BITs, case \\$D=1\\$",
      " * Source: https://www.geeksforgeeks.org/binary-indexed-tree-range-update-range-queries/",
      " * Verification: CSES",
      " * Time: O(\\log N)",
      " */",
      "",
      "#include \"BIT (9.2).h\"",
      "",
      "template<class T, int SZ> struct BITrange {",
      "\tBIT<T,SZ> bit[2]; // piecewise linear functions",
      "\t// let cum[x] = sum_{i=1}^{x}a[i]",
      "\tvoid upd(int hi, T val) { // add val to a[1..hi]",
      "\t\t// if x <= hi, cum[x] += val*x",
      "\t\tbit[1].upd(1,val), bit[1].upd(hi+1,-val); ",
      "\t\t// if x > hi, cum[x] += val*hi",
      "\t\tbit[0].upd(hi+1,hi*val); ",
      "\t}",
      "\tvoid upd(int lo,int hi,T val){upd(lo-1,-val),upd(hi,val);}",
      "\tT sum(int x) { return bit[1].sum(x)*x+bit[0].sum(x); } ",
      "\tT query(int x, int y) { return sum(y)-sum(x-1); }",
      "}; "
    ],
    "description": "\\$D\\$-dimensional range increment and sum query with \\$2^D\\$ BITs, case \\$D=1\\$, *"
  },
  "LazySeg": {
    "prefix":["benq_LazySeg"],
    "body": [
      "/**",
      " * Description: 1D range increment and sum query.",
      " * Source: USACO Counting Haybales",
      " * Verification: SPOJ Horrible",
      " */",
      "",
      "template<class T, int SZ> struct LazySeg { ",
      "\tstatic_assert(pct(SZ) == 1); // SZ must be power of 2",
      "\tconst T ID = 0; T comb(T a, T b) { return a+b; }",
      "\tT seg[2*SZ], lazy[2*SZ]; ",
      "\tLazySeg() { F0R(i,2*SZ) seg[i] = lazy[i] = ID; }",
      "\tvoid push(int ind, int L, int R) { /// modify values for current node",
      "\t\tseg[ind] += (R-L+1)*lazy[ind]; // dependent on operation",
      "\t\tif (L != R) F0R(i,2) lazy[2*ind+i] += lazy[ind]; /// prop to children",
      "\t\tlazy[ind] = 0; ",
      "\t} // recalc values for current node",
      "\tvoid pull(int ind) { seg[ind] = comb(seg[2*ind],seg[2*ind+1]); }",
      "\tvoid build() { ROF(i,1,SZ) pull(i); }",
      "\tvoid upd(int lo,int hi,T inc,int ind=1,int L=0, int R=SZ-1) {",
      "\t\tpush(ind,L,R); if (hi < L || R < lo) return;",
      "\t\tif (lo <= L && R <= hi) { ",
      "\t\t\tlazy[ind] = inc; push(ind,L,R); return; }",
      "\t\tint M = (L+R)/2; upd(lo,hi,inc,2*ind,L,M); ",
      "\t\tupd(lo,hi,inc,2*ind+1,M+1,R); pull(ind);",
      "\t}",
      "\tT query(int lo, int hi, int ind=1, int L=0, int R=SZ-1) {",
      "\t\tpush(ind,L,R); if (lo > R || L > hi) return ID;",
      "\t\tif (lo <= L && R <= hi) return seg[ind];",
      "\t\tint M = (L+R)/2; ",
      "\t\treturn comb(query(lo,hi,2*ind,L,M),query(lo,hi,2*ind+1,M+1,R));",
      "\t}",
      "};"
    ],
    "description": "1D range increment and sum query., *"
  },
  "LazySegAlt": {
    "prefix":["benq_LazySegAlt"],
    "body": [
      "/**",
      " * Description: 1D range increment and sum query.",
      " * Source: USACO Counting Haybales",
      " \t* https://codeforces.com/blog/entry/82400",
      " * Verification: USACO Counting Haybales",
      " */",
      "",
      "struct LazySeg { ",
      "\tstruct F { // lazy update",
      "\t\tll inc = 0;",
      "\t\tF() {}",
      "\t\tF(int x) { inc = x; }",
      "\t\tF& operator*=(const F& a) { inc += a.inc; return *this; }",
      "\t}; V<F> lazy;",
      "\tstruct T { // data you need to store for each interval",
      "\t\tll sz = 1, mn = INF, sum = 0;",
      "\t\tT() {}",
      "\t\tT(int x) { mn = sum = x; }",
      "\t\tfriend T operator+(const T& a, const T& b) {",
      "\t\t\tT res; res.sz = a.sz+b.sz;",
      "\t\t\tres.mn = min(a.mn,b.mn), res.sum = a.sum+b.sum;",
      "\t\t\treturn res;",
      "\t\t}",
      "\t\tT& operator*=(const F& a) {",
      "\t\t\tmn += a.inc; sum += (ll)sz*a.inc; return *this; }",
      "\t}; V<T> seg;",
      "\tint SZ = 1;",
      "\tvoid init(const V<T>& _seg) {",
      "\t\twhile (SZ < sz(_seg)) SZ *= 2;",
      "\t\tseg.rsz(2*SZ); lazy.rsz(2*SZ);",
      "\t\tF0R(i,SZ) seg[SZ+i] = _seg[i];",
      "\t\tROF(i,1,SZ) pull(i);",
      "\t}",
      "\tvoid push(int ind) { /// modify values for current node",
      "\t\tseg[ind] *= lazy[ind];",
      "\t\tif (ind < SZ) F0R(i,2) lazy[2*ind+i] *= lazy[ind];",
      "\t\tlazy[ind] = F();",
      "\t} // recalc values for current node",
      "\tvoid pull(int ind) { seg[ind] = seg[2*ind]+seg[2*ind+1]; }",
      "\tvoid upd(int lo, int hi, F inc, int ind, int L, int R) {",
      "\t\tpush(ind); if (hi < L || R < lo) return;",
      "\t\tif (lo <= L && R <= hi) { ",
      "\t\t\tlazy[ind] = inc; push(ind); return; }",
      "\t\tint M = (L+R)/2; upd(lo,hi,inc,2*ind,L,M); ",
      "\t\tupd(lo,hi,inc,2*ind+1,M+1,R); pull(ind);",
      "\t}",
      "\tvoid upd(int lo, int hi, int inc) { upd(lo,hi,{inc},1,0,SZ-1); }",
      "\tT query(int lo, int hi, int ind, int L, int R) {",
      "\t\tpush(ind); if (lo > R || L > hi) return T();",
      "\t\tif (lo <= L && R <= hi) return seg[ind];",
      "\t\tint M = (L+R)/2; ",
      "\t\treturn query(lo,hi,2*ind,L,M)+query(lo,hi,2*ind+1,M+1,R);",
      "\t}",
      "\tT query(int lo, int hi) { return query(lo,hi,1,0,SZ-1); }",
      "};"
    ],
    "description": "1D range increment and sum query., *"
  },
  "LichaoSeg": {
    "prefix":["benq_LichaoSeg"],
    "body": [
      "/**",
      " * Description: LiChao Segment Tree",
      " * Source: atatomir, misc",
      " * Verification: CSA Squared Ends",
      "   * https://judge.yosupo.jp/problem/segment_add_get_min",
      " */",
      "",
      "struct Line {",
      "\tint k; ll m;",
      "\tLine(int _k, ll _m) { k = _k, m = _m; }",
      "\tLine() : Line(0,LLONG_MIN) { }",
      "\tll get(ll x) { return k*x+m; }",
      "\tbool majorize(Line X, ll L, ll R) { ",
      "\t\treturn get(L) >= X.get(L) && get(R) >= X.get(R); }",
      "};",
      "",
      "struct lc {",
      "\tlc* c[2]; Line S;",
      "\tlc() { c[0] = c[1] = NULL; S = Line(); }",
      "\t~lc() { F0R(i,2) delete c[i]; }",
      "\tvoid mc(int i) { if (!c[i]) c[i] = new lc(); }",
      "\tll mid(ll x) { return x&1?(x-1)/2:x/2; }",
      "\tll query(ll X, ll L, ll R) {",
      "\t\tll ans = S.get(X), M = mid(L+R);",
      "\t\tif (X <= M) {",
      "\t\t\tif (c[0]) ckmax(ans,c[0]->query(X,L,M));",
      "\t\t} else {",
      "\t\t\tif (c[1]) ckmax(ans,c[1]->query(X,M+1,R));",
      "\t\t}",
      "\t\treturn ans;",
      "\t}",
      "\tvoid modify(Line X, ll L, ll R) {",
      "\t\tif (X.majorize(S,L,R)) swap(X,S);",
      "\t\tif (S.majorize(X,L,R)) return;",
      "\t\tif (S.get(L) < X.get(L)) swap(X,S);",
      "\t\tll M = mid(L+R);",
      "\t\tif (X.get(M) >= S.get(M)) swap(X,S), mc(0), c[0]->modify(X,L,M);",
      "\t\telse mc(1), c[1]->modify(X,M+1,R);",
      "\t}",
      "\tvoid upd(Line X, ll lo, ll hi, ll L, ll R) {",
      "\t\tif (R < lo || hi < L) return;",
      "\t\tif (lo <= L && R <= hi) return modify(X,L,R);",
      "\t\tll M = mid(L+R);",
      "\t\tif (lo <= M) mc(0), c[0]->upd(X,lo,hi,L,M);",
      "\t\tif (hi > M) mc(1), c[1]->upd(X,lo,hi,M+1,R);",
      "\t}",
      "};"
    ],
    "description": "LiChao Segment Tree, *"
  },
  "MaxQuery": {
    "prefix":["benq_MaxQuery"],
    "body": [
      "/**",
      " * Description: insert pair \\$(a,b)\\$ and query max value ",
      " \t* of \\$b\\$ over all pairs satisfying \\$a\\ge x\\$.",
      " * Source: Own",
      " * Verification: https://codeforces.com/gym/102059/problem/K",
      " \t* http://www.usaco.org/index.php?page=viewproblem2&cpid=995",
      " * Time: O(\\log N)",
      " */",
      "",
      "struct MaxQuery {",
      "\tmap<int,ll> m;",
      "\tvoid ins(int a, ll b) {",
      "\t\tauto it = m.lb(a); if (it != end(m) && it->s >= b) return;",
      "\t\tit = m.insert(it,{a,b}); it->s = b;",
      "\t\twhile (it != begin(m) && prev(it)->s <= b) m.erase(prev(it));",
      "\t}",
      "\tll query(int x) { auto it = m.lb(x); ",
      "\t\treturn it == end(m) ? 0 : it->s; }",
      "};"
    ],
    "description": "insert pair \\$(a,b)\\$ and query max value ,  * of \\$b\\$ over all pairs satisfying \\$a\\ge x\\$., *"
  },
  "Mo": {
    "prefix":["benq_Mo"],
    "body": [
      "/**",
      " * Description: Answers queries offline in (N+Q)sqrt(N)",
      "\t* Also see Mo's on trees",
      " * Source: Codeforces",
      " * Verification: https://codeforces.com/contest/617/problem/E",
      " */",
      "",
      "int N, A[MX];",
      "int ans[MX], oc[MX], BLOCK;",
      "vector<array<int,3>> todo; // store left, right, index of ans",
      "",
      "bool cmp(array<int,3> a, array<int,3> b) { // sort queries",
      "\tif (a[0]/BLOCK != b[0]/BLOCK) return a[0] < b[0];",
      "\treturn a[1] < b[1];",
      "}",
      "",
      "int l = 0, r = -1, cans = 0;",
      "",
      "void modify(int x, int y = 1) {",
      "\tx = A[x];",
      "\t// if condition: cans --;",
      "\toc[x] += y;",
      "\t// if condition: cans ++;",
      "}",
      "",
      "int answer(int L, int R) { // modifyjust interval",
      "\twhile (l > L) modify(--l);",
      "\twhile (r < R) modify(++r);",
      "\twhile (l < L) modify(l++,-1);",
      "\twhile (r > R) modify(r--,-1);",
      "\treturn cans;",
      "}",
      "",
      "void solve() {",
      "\tBLOCK = sqrt(N); sort(all(todo),cmp);",
      "\teach(x,todo) {",
      "\t\tanswer(x[0],x[1]);",
      "\t\tans[x[2]] = cans;",
      "\t}",
      "}"
    ],
    "description": "Answers queries offline in (N+Q)sqrt(N), * Also see Mo's on trees, *"
  },
  "PermTree": {
    "prefix":["benq_PermTree"],
    "body": [
      "/**",
      " * Description: Permutation Tree, represents all contiguous subsequences",
      "\t * of permutation whose values are contiguous (good). Works for both 0-",
      "\t * and 1-indexed permutations. \\texttt{typ[i]=1} (increasing) and ",
      "\t * \\texttt{typ[i]=2} (decreasing) represent join nodes - every contiguous ",
      "\t * subsequence of its children is good. \\texttt{typ[i]=0} represents a leaf ",
      "\t * node or a cut node; no contiguous subsequence of its children with length > 1 ",
      "\t * is good. Note that a cut node must have \\$\\ge 4\\$ children. \\texttt{loc[i]}",
      "\t * stores the node corresponding to the \\texttt{i}-th element of the permutation.",
      " * Source: https://codeforces.com/blog/entry/78898",
      " * Verification: CERC17 Intrinsic Interval",
      " * Usage: PermTree P; P.init({0,1,2,3,5,4});",
      " */",
      "",
      "typedef pi T;",
      "const int SZ = 1<<19;",
      "struct LazySeg { ",
      "\tconst T ID = {MOD,0}; ",
      "\tT comb(T l, T r) { return l.f != r.f ? min(l,r) : T{l.f,l.s+r.s}; }",
      "\tT seg[2*SZ]; int lazy[2*SZ]; ",
      "\tLazySeg() { ",
      "\t\tF0R(i,2*SZ) lazy[i] = 0; ",
      "\t\tF0R(i,SZ) seg[SZ+i] = {0,1};",
      "\t\tROF(i,1,SZ) seg[i] = comb(seg[2*i],seg[2*i+1]);",
      "\t}",
      "\tvoid push(int ind, int L, int R) { /// modify values for current node",
      "\t\tif (L != R) F0R(i,2) lazy[2*ind+i] += lazy[ind]; /// prop to children",
      "\t\tseg[ind].f += lazy[ind]; lazy[ind] = 0; ",
      "\t} // recalc values for current node",
      "\tvoid pull(int ind) { seg[ind] = comb(seg[2*ind],seg[2*ind+1]); }",
      "\tvoid build() { ROF(i,1,SZ) pull(i); }",
      "\tvoid upd(int lo,int hi,int inc,int ind=1,int L=0, int R=SZ-1) {",
      "\t\tpush(ind,L,R); if (hi < L || R < lo) return;",
      "\t\tif (lo <= L && R <= hi) { ",
      "\t\t\tlazy[ind] = inc; push(ind,L,R); return; }",
      "\t\tint M = (L+R)/2; upd(lo,hi,inc,2*ind,L,M); ",
      "\t\tupd(lo,hi,inc,2*ind+1,M+1,R); pull(ind);",
      "\t}",
      "\tpi query(int lo, int hi, int ind = 1, int L = 0, int R = SZ-1) {",
      "\t\tpush(ind,L,R); if (hi < L || R < lo) return {MOD,0};",
      "\t\tif (lo <= L && R <= hi) return seg[ind];",
      "\t\tint M = (L+R)/2;",
      "\t\treturn comb(query(lo,hi,2*ind,L,M),query(lo,hi,2*ind+1,M+1,R));",
      "\t}",
      "};",
      "",
      "struct PermTree {",
      "\tvi P; int n; // N = number of nodes in perm tree",
      "\tint N = 0, root; vector<vi> child;",
      "\tvpi inter, range; vi typ, loc; // inter = index range in perm",
      "\tvoid init(vi _P) {",
      "\t\tP = _P; n = sz(P); LazySeg L; ",
      "\t\tvi mn{-1}, mx{-1}, st;",
      "\t\tF0R(i,n) { // L stores max-min-len for each range",
      "\t\t\tif (i) L.upd(0,i-1,-1);",
      "\t\t\t{",
      "\t\t\t\twhile (mn.bk != -1 && P[mn.bk] > P[i]) {",
      "\t\t\t\t\tint t = mn.bk; mn.pop_back();",
      "\t\t\t\t\tL.upd(mn.bk+1,t,P[t]);",
      "\t\t\t\t}",
      "\t\t\t\tL.upd(mn.bk+1,i,-P[i]); mn.pb(i); ",
      "\t\t\t}",
      "\t\t\t{",
      "\t\t\t\twhile (mx.bk != -1 && P[mx.bk] < P[i]) {",
      "\t\t\t\t\tint t = mx.bk; mx.pop_back();",
      "\t\t\t\t\tL.upd(mx.bk+1,t,-P[t]);",
      "\t\t\t\t}",
      "\t\t\t\tL.upd(mx.bk+1,i,P[i]); mx.pb(i);",
      "\t\t\t}",
      "\t\t\tint cur = N++; loc.pb(cur);",
      "\t\t\tinter.pb({i,i}); range.pb({P[i],P[i]}); typ.pb(0); child.eb();",
      "\t\t\tauto add = [](pi a, pi b) -> pi { return {min(a.f,b.f),max(a.s,b.s)}; };",
      "\t\t\tauto adj = [&](int x, int y) { pi a = range[x], b = range[y]; ",
      "\t\t\t\treturn a.s+1 == b.f || b.s+1 == a.f; };",
      "\t\t\twhile (sz(st)) {",
      "\t\t\t\tif (adj(st.bk,cur)) {",
      "\t\t\t\t\tif (sz(child[st.bk]) && adj(child[st.bk].bk,cur)) {",
      "\t\t\t\t\t\tassert(typ[st.bk]); // join node",
      "\t\t\t\t\t\tinter[st.bk] = add(inter[st.bk],inter[cur]);",
      "\t\t\t\t\t\trange[st.bk] = add(range[st.bk],range[cur]);",
      "\t\t\t\t\t\tchild[st.bk].pb(cur); cur = st.bk; st.pop_back();",
      "\t\t\t\t\t} else { // make new join node",
      "\t\t\t\t\t\tint CUR = N++;",
      "\t\t\t\t\t\tinter.pb(add(inter[cur],inter[st.bk]));",
      "\t\t\t\t\t\trange.pb(add(range[cur],range[st.bk]));",
      "\t\t\t\t\t\ttyp.pb(range[st.bk] < range[cur] ? 1 : 2);",
      "\t\t\t\t\t\tchild.pb({st.bk,cur}); cur = CUR; st.pop_back();",
      "\t\t\t\t\t}",
      "\t\t\t\t\tcontinue;",
      "\t\t\t\t}",
      "\t\t\t\tif (L.query(0,inter[cur].f-1).f != 0) break;",
      "\t\t\t\tint CUR = N++;",
      "\t\t\t\tinter.pb(inter[cur]); range.pb(range[cur]); typ.pb(0); child.pb({cur});",
      "\t\t\t\tauto len = [](pi p) { return p.s-p.f; };",
      "\t\t\t\tdo {",
      "\t\t\t\t\tassert(sz(st));",
      "\t\t\t\t\tinter[CUR] = add(inter[CUR],inter[st.bk]);",
      "\t\t\t\t\trange[CUR] = add(range[CUR],range[st.bk]);",
      "\t\t\t\t\tchild[CUR].pb(st.bk); st.pop_back();",
      "\t\t\t\t} while (len(inter.bk) != len(range.bk));",
      "\t\t\t\trev(child[CUR]); cur = CUR;",
      "\t\t\t}",
      "\t\t\tst.pb(cur);",
      "\t\t}",
      "\t\tassert(sz(st) == 1); root = st.bk;",
      "\t\tF0R(i,N) if (typ[i]) {",
      "\t\t\tif (typ[i] == 1) {",
      "\t\t\t\tFOR(j,1,sz(child[i])) assert(range[child[i][j-1]].s+1 == range[child[i][j]].f);",
      "\t\t\t} else {",
      "\t\t\t\tFOR(j,1,sz(child[i])) assert(range[child[i][j-1]].f-1 == range[child[i][j]].s);",
      "\t\t\t}",
      "\t\t}",
      "\t\tdbg(root);",
      "\t\tF0R(i,N) dbg(i,typ[i],inter[i],range[i],child[i]);",
      "\t} // traverse tree by starting at root and DFSing through child",
      "};"
    ],
    "description": "Permutation Tree, represents all contiguous subsequences,  * of permutation whose values are contiguous (good). Works for both 0-,  * and 1-indexed permutations. \\texttt{typ[i]=1} (increasing) and ,  * \\texttt{typ[i]=2} (decreasing) represent join nodes - every contiguous ,  * subsequence of its children is good. \\texttt{typ[i]=0} represents a leaf ,  * node or a cut node; no contiguous subsequence of its children with length > 1 ,  * is good. Note that a cut node must have \\$\\ge 4\\$ children. \\texttt{loc[i]},  * stores the node corresponding to the \\texttt{i}-th element of the permutation., *"
  },
  "PSeg": {
    "prefix":["benq_PSeg"],
    "body": [
      "/**",
      " * Description: Persistent min segtree with lazy updates, no propagation.",
      " \t* If making \\texttt{d} a vector then save the results of",
      " \t* \\texttt{upd} and \\texttt{build} in local variables first to",
      " \t* avoid issues when vector resizes in C++14 or lower.",
      " * Memory: O(N+Q\\log N)",
      " * Source: CF, Franklyn Wang",
      " * Verification: ",
      " \t* https://codeforces.com/contest/1090/problem/G",
      " \t* https://codeforces.com/gym/102423/submission/70170291",
      " */ ",
      "",
      "template<class T, int SZ> struct pseg {",
      "\tstatic const int LIM = 2e7;",
      "\tstruct node { ",
      "\t\tint l, r; T val = 0, lazy = 0; ",
      "\t\tvoid inc(T x) { lazy += x; }",
      "\t\tT get() { return val+lazy; }",
      "\t};",
      "\tnode d[LIM]; int nex = 0;",
      "\tint copy(int c) { d[nex] = d[c]; return nex++; }",
      "\tT comb(T a, T b) { return min(a,b); }",
      "\tvoid pull(int c) { d[c].val = ",
      "\t\tcomb(d[d[c].l].get(), d[d[c].r].get()); } ",
      "\t//// MAIN FUNCTIONS",
      "\tT query(int c, int lo, int hi, int L, int R) {  ",
      "\t\tif (lo <= L && R <= hi) return d[c].get();",
      "\t\tif (R < lo || hi < L) return MOD;",
      "\t\tint M = (L+R)/2;",
      "\t\treturn d[c].lazy+comb(query(d[c].l,lo,hi,L,M),",
      "\t\t\t\t\t\t\tquery(d[c].r,lo,hi,M+1,R));",
      "\t}",
      "\tint upd(int c, int lo, int hi, T v, int L, int R) {",
      "\t\tif (R < lo || hi < L) return c;",
      "\t\tint x = copy(c);",
      "\t\tif (lo <= L && R <= hi) { d[x].inc(v); return x; }",
      "\t\tint M = (L+R)/2;",
      "\t\td[x].l = upd(d[x].l,lo,hi,v,L,M);",
      "\t\td[x].r = upd(d[x].r,lo,hi,v,M+1,R);",
      "\t\tpull(x); return x;",
      "\t}",
      "\tint build(const vector<T>& arr, int L, int R) {",
      "\t\tint c = nex++;",
      "\t\tif (L == R) {",
      "\t\t\tif (L < sz(arr)) d[c].val = arr[L];",
      "\t\t\treturn c;",
      "\t\t}",
      "\t\tint M = (L+R)/2;",
      "\t\td[c].l = build(arr,L,M), d[c].r = build(arr,M+1,R);",
      "\t\tpull(c); return c;",
      "\t}",
      "\tvi loc; //// PUBLIC",
      "\tvoid upd(int lo, int hi, T v) { ",
      "\t\tloc.pb(upd(loc.bk,lo,hi,v,0,SZ-1)); }",
      "\tT query(int ti, int lo, int hi) { ",
      "\t\treturn query(loc[ti],lo,hi,0,SZ-1); }",
      "\tvoid build(const vector<T>&arr) {loc.pb(build(arr,0,SZ-1));}",
      "};"
    ],
    "description": "Persistent min segtree with lazy updates, no propagation.,  * If making \\texttt{d} a vector then save the results of,  * \\texttt{upd} and \\texttt{build} in local variables first to,  * avoid issues when vector resizes in C++14 or lower., * Memory: O(N+Q\\log N), *"
  },
  "RectUnion": {
    "prefix":["benq_RectUnion"],
    "body": [
      "/**",
      " * Description: Area of rectangle union using segment tree that ",
      "\t* keeps track of min and # of mins. Rectangles are in form {{x1,x2},{y1,y2}}.",
      " * Source: Own",
      " * Verification: FHC19 Final D",
      "\t* https://cses.fi/problemset/task/1741/",
      " */",
      "",
      "typedef pi T;",
      "T operator+(const T& l, const T& r) {",
      "\treturn l.f != r.f ? min(l,r) : T{l.f,l.s+r.s}; }",
      "",
      "const int SZ = 1<<18;",
      "struct LazySeg { ",
      "\tconst T ID = {MOD,0}; T comb(T a, T b) { return a+b; }",
      "\tT seg[2*SZ]; int lazy[2*SZ]; ",
      "\tLazySeg() { F0R(i,2*SZ) seg[i] = {0,0}, lazy[i] = 0; }",
      "\tvoid push(int ind, int L, int R) { /// modify values for current node",
      "\t\tif (L != R) F0R(i,2) lazy[2*ind+i] += lazy[ind]; /// prop to children",
      "\t\tseg[ind].f += lazy[ind]; // dependent on operation",
      "\t\tlazy[ind] = 0; ",
      "\t} // recalc values for current node",
      "\tvoid pull(int ind) { seg[ind] = comb(seg[2*ind],seg[2*ind+1]); }",
      "\tvoid build() { ROF(i,1,SZ) pull(i); }",
      "\tvoid upd(int lo,int hi,int inc,int ind=1,int L=0, int R=SZ-1) {",
      "\t\tpush(ind,L,R); if (hi < L || R < lo) return;",
      "\t\tif (lo <= L && R <= hi) { ",
      "\t\t\tlazy[ind] = inc; push(ind,L,R); return; }",
      "\t\tint M = (L+R)/2; upd(lo,hi,inc,2*ind,L,M); ",
      "\t\tupd(lo,hi,inc,2*ind+1,M+1,R); pull(ind);",
      "\t}",
      "};",
      " ",
      "ll area(vector<pair<pi,pi>> v) {",
      "\tLazySeg L;",
      "\tvi y; each(t,v) y.pb(t.s.f), y.pb(t.s.s);",
      "\tsort(all(y)); y.erase(unique(all(y)),y.end());",
      "\tF0R(i,sz(y)-1) L.seg[SZ+i].s = y[i+1]-y[i];",
      "\tL.build();",
      "\tvector<array<int,4>> ev; // sweep line",
      "\teach(t,v) {",
      "\t\tt.s.f = lb(all(y),t.s.f)-begin(y);",
      "\t\tt.s.s = lb(all(y),t.s.s)-begin(y)-1;",
      "\t\tev.pb({t.f.f,1,t.s.f,t.s.s});",
      "\t\tev.pb({t.f.s,-1,t.s.f,t.s.s});",
      "\t}",
      "\tsort(all(ev));",
      "\tll ans = 0;",
      "\tF0R(i,sz(ev)-1) {",
      "\t\tconst auto& t = ev[i]; L.upd(t[2],t[3],t[1]);",
      "\t\tint len = y.bk-y.ft-L.seg[1].s; // L.mn[0].f should equal 0",
      "\t\tans += (ll)(ev[i+1][0]-t[0])*len;",
      "\t}",
      "\treturn ans;",
      "}"
    ],
    "description": "Area of rectangle union using segment tree that , * keeps track of min and # of mins. Rectangles are in form {{x1,x2},{y1,y2}}., *"
  },
  "SegTree": {
    "prefix":["benq_SegTree"],
    "body": [
      "/**",
      " * Description: 1D point update, range query where \\texttt{comb} is",
      " \t* any associative operation. If \\$N=2^p\\$ then \\texttt{seg[1]==query(0,N-1)}.",
      " * Time: O(\\log N)",
      " * Source: ",
      "\t* http://codeforces.com/blog/entry/18051",
      "\t* KACTL",
      " * Verification: SPOJ Fenwick",
      " */",
      "",
      "template<class T> struct Seg { // comb(ID,b) = b",
      "\tconst T ID = 0; T comb(T a, T b) { return a+b; } ",
      "\tint n; vector<T> seg;",
      "\tvoid init(int _n) { n = _n; seg.assign(2*n,ID); }",
      "\tvoid pull(int p) { seg[p] = comb(seg[2*p],seg[2*p+1]); }",
      "\tvoid upd(int p, T val) { // set val at position p",
      "\t\tseg[p += n] = val; for (p /= 2; p; p /= 2) pull(p); }",
      "\tT query(int l, int r) {\t// sum on interval [l, r]",
      "\t\tT ra = ID, rb = ID; ",
      "\t\tfor (l += n, r += n+1; l < r; l /= 2, r /= 2) {",
      "\t\t\tif (l&1) ra = comb(ra,seg[l++]);",
      "\t\t\tif (r&1) rb = comb(seg[--r],rb);",
      "\t\t}",
      "\t\treturn comb(ra,rb);",
      "\t}",
      "};"
    ],
    "description": "1D point update, range query where \\texttt{comb} is,  * any associative operation. If \\$N=2^p\\$ then \\texttt{seg[1]==query(0,N-1)}., * Time: O(\\log N), *"
  },
  "SegTreeBeats": {
    "prefix":["benq_SegTreeBeats"],
    "body": [
      "/**",
      " * Description: Lazy SegTree supports modifications of the form ",
      " \t* \\texttt{ckmin(a\\_i,t)} for all \\$l\\le i\\le r\\$, range max and sum queries. ",
      " \t* \\texttt{SZ} is power of 2.",
      " * Time: O(\\log N)",
      " * Source: http://codeforces.com/blog/entry/57319",
      " * Verification: http://acm.hdu.edu.cn/showproblem.php?pid=5306",
      " */",
      "",
      "template<int SZ> struct SegTreeBeats { // declare globally",
      "\tint N, mx[2*SZ][2], maxCnt[2*SZ];",
      "\tll sum[2*SZ];",
      "\tvoid pull(int ind) {",
      "\t\tF0R(i,2) mx[ind][i] = max(mx[2*ind][i],mx[2*ind+1][i]);",
      "\t\tmaxCnt[ind] = 0;",
      "\t\tF0R(i,2) {",
      "\t\t\tif (mx[2*ind+i][0] == mx[ind][0]) ",
      "\t\t\t\tmaxCnt[ind] += maxCnt[2*ind+i];",
      "\t\t\telse ckmax(mx[ind][1],mx[2*ind+i][0]);",
      "\t\t}",
      "\t\tsum[ind] = sum[2*ind]+sum[2*ind+1];",
      "\t}",
      "\tvoid build(vi& a, int ind = 1, int L = 0, int R = -1) {",
      "\t\tif (R == -1) { R = (N = sz(a))-1; }",
      "\t\tif (L == R) {",
      "\t\t\tmx[ind][0] = sum[ind] = a[L];",
      "\t\t\tmaxCnt[ind] = 1; mx[ind][1] = -1;",
      "\t\t\treturn;",
      "\t\t} ",
      "\t\tint M = (L+R)/2;",
      "\t\tbuild(a,2*ind,L,M); build(a,2*ind+1,M+1,R); pull(ind);",
      "\t}",
      "\tvoid push(int ind, int L, int R) {",
      "\t\tif (L == R) return;",
      "\t\tF0R(i,2) if (mx[2*ind^i][0] > mx[ind][0]) {",
      "\t\t\tsum[2*ind^i] -= (ll)maxCnt[2*ind^i]*",
      "\t\t\t\t\t\t\t(mx[2*ind^i][0]-mx[ind][0]);",
      "\t\t\tmx[2*ind^i][0] = mx[ind][0];",
      "\t\t}",
      "\t}",
      "\tvoid upd(int x, int y, int t, int ind=1, int L=0, int R=-1) { ",
      "\t\tif (R == -1) R += N;",
      "\t\tif (R < x || y < L || mx[ind][0] <= t) return;",
      "\t\tpush(ind,L,R);",
      "\t\tif (x <= L && R <= y && mx[ind][1] < t) {",
      "\t\t\tsum[ind] -= (ll)maxCnt[ind]*(mx[ind][0]-t);",
      "\t\t\tmx[ind][0] = t;",
      "\t\t\treturn;",
      "\t\t}",
      "\t\tif (L == R) return;",
      "\t\tint M = (L+R)/2;",
      "\t\tupd(x,y,t,2*ind,L,M); upd(x,y,t,2*ind+1,M+1,R); pull(ind);",
      "\t}",
      "\tll qsum(int x, int y, int ind = 1, int L = 0, int R = -1) {",
      "\t\tif (R == -1) R += N;",
      "\t\tif (R < x || y < L) return 0;",
      "\t\tpush(ind,L,R);",
      "\t\tif (x <= L && R <= y) return sum[ind];",
      "\t\tint M = (L+R)/2;",
      "\t\treturn qsum(x,y,2*ind,L,M)+qsum(x,y,2*ind+1,M+1,R);",
      "\t}",
      "\tint qmax(int x, int y, int ind = 1, int L = 0, int R = -1) {",
      "\t\tif (R == -1) R += N;",
      "\t\tif (R < x || y < L) return -1;",
      "\t\tpush(ind,L,R);",
      "\t\tif (x <= L && R <= y) return mx[ind][0];",
      "\t\tint M = (L+R)/2;",
      "\t\treturn max(qmax(x,y,2*ind,L,M),qmax(x,y,2*ind+1,M+1,R));",
      "\t}",
      "};"
    ],
    "description": "Lazy SegTree supports modifications of the form ,  * \\texttt{ckmin(a\\_i,t)} for all \\$l\\le i\\le r\\$, range max and sum queries. ,  * \\texttt{SZ} is power of 2., * Time: O(\\log N), *"
  },
  "SparseSeg": {
    "prefix":["benq_SparseSeg"],
    "body": [
      "/**",
      " * Description: Does not allocate storage for nodes with no data",
      " * Source: USACO Mowing the Field",
      " * Verification: ~",
      " */ ",
      "",
      "const int SZ = 1<<17;",
      "template<class T> struct node {",
      "\tT val = 0; node<T>* c[2];",
      "\tnode() { c[0] = c[1] = NULL; }",
      "\tvoid upd(int ind, T v, int L = 0, int R = SZ-1) { // add v",
      "\t\tif (L == ind && R == ind) { val += v; return; }",
      "\t\tint M = (L+R)/2;",
      "\t\tif (ind <= M) {",
      "\t\t\tif (!c[0]) c[0] = new node();",
      "\t\t\tc[0]->upd(ind,v,L,M);",
      "\t\t} else {",
      "\t\t\tif (!c[1]) c[1] = new node();",
      "\t\t\tc[1]->upd(ind,v,M+1,R);",
      "\t\t}",
      "\t\tval = 0; F0R(i,2) if (c[i]) val += c[i]->val;",
      "\t}",
      "\tT query(int lo, int hi, int L = 0, int R = SZ-1) { // query sum of segment",
      "\t\tif (hi < L || R < lo) return 0;",
      "\t\tif (lo <= L && R <= hi) return val;",
      "\t\tint M = (L+R)/2; T res = 0;",
      "\t\tif (c[0]) res += c[0]->query(lo,hi,L,M);",
      "\t\tif (c[1]) res += c[1]->query(lo,hi,M+1,R);",
      "\t\treturn res;",
      "\t}",
      "\tvoid UPD(int ind, node* c0, node* c1, int L = 0, int R = SZ-1) { // for 2D segtree",
      "\t\tif (L != R) {",
      "\t\t\tint M = (L+R)/2;",
      "\t\t\tif (ind <= M) {",
      "\t\t\t\tif (!c[0]) c[0] = new node();",
      "\t\t\t\tc[0]->UPD(ind,c0?c0->c[0]:NULL,c1?c1->c[0]:NULL,L,M);",
      "\t\t\t} else {",
      "\t\t\t\tif (!c[1]) c[1] = new node();",
      "\t\t\t\tc[1]->UPD(ind,c0?c0->c[1]:NULL,c1?c1->c[1]:NULL,M+1,R);",
      "\t\t\t}",
      "\t\t} ",
      "\t\tval = (c0?c0->val:0)+(c1?c1->val:0);",
      "\t}",
      "};"
    ],
    "description": "Does not allocate storage for nodes with no data, *"
  },
  "Wavelet": {
    "prefix":["benq_Wavelet"],
    "body": [
      "/**",
      "* Description: SegTree on values instead of indices. Returns \\$k\\$-th ",
      "\t* largest number in 0-indexed interval \\texttt{[lo,hi)}.",
      "\t* \\$SZ=2^p\\$ and all values in \\$a\\$ must lie in \\$[0,SZ)\\$.",
      "* Memory: O(N\\log N)",
      "* Time: O(\\log N) query",
      "* Source: http://rachitiitr.blogspot.com/2017/06",
      "\t/wavelet-trees-wavelet-trees-editorial.html",
      "* Verification: http://www.spoj.com/problems/MKTHNUM/",
      "*/",
      "",
      "template<int SZ> struct Wavelet { ",
      "\tvi nexl[SZ], nexr[SZ];",
      "\tvoid build(vi a, int ind = 1, int L = 0, int R = SZ-1) { ",
      "\t\tif (L == R) return;",
      "\t\tnexl[ind] = nexr[ind] = {0};",
      "\t\tvi A[2]; int M = (L+R)/2;",
      "\t\teach(t,a) {",
      "\t\t\tA[t>M].pb(t);",
      "\t\t\tnexl[ind].pb(sz(A[0])), nexr[ind].pb(sz(A[1]));",
      "\t\t}",
      "\t\tbuild(A[0],2*ind,L,M), build(A[1],2*ind+1,M+1,R);",
      "\t}",
      "\tint query(int lo,int hi,int k,int ind=1,int L=0,int R=SZ-1) { ",
      "\t\tif (L == R) return L;",
      "\t\tint M = (L+R)/2, t = nexl[ind][hi]-nexl[ind][lo];",
      "\t\tif (t >= k) return query(nexl[ind][lo],",
      "\t\t\t\t\t\tnexl[ind][hi],k,2*ind,L,M);",
      "\t\treturn query(nexr[ind][lo],",
      "\t\t\tnexr[ind][hi],k-t,2*ind+1,M+1,R);",
      "\t}",
      "};"
    ],
    "description": "SegTree on values instead of indices. Returns \\$k\\$-th , * largest number in 0-indexed interval \\texttt{[lo,hi)}., * \\$SZ=2^p\\$ and all values in \\$a\\$ must lie in \\$[0,SZ)\\$.,* Memory: O(N\\log N),* Time: O(\\log N) query,*"
  },
  "BIT2DOff": {
    "prefix":["benq_BIT2DOff"],
    "body": [
      "/**",
      " * Description: point update and rectangle sum with offline 2D BIT. ",
      "\t* For each of the points to be updated, \\$x\\in (0,SZ)\\$ and \\$y\\neq 0\\$.",
      " * Time: O(N\\log^2 N)",
      " * Memory: O(N\\log N)",
      " * Source: Own",
      " * Verification: ",
      " \t* https://dmoj.ca/problem/occ19g4",
      " \t* http://www.usaco.org/index.php?page=viewproblem2&cpid=722 (753 ms)",
      " \t* http://www.usaco.org/index.php?page=viewproblem2&cpid=601 (679 ms)",
      " */",
      "",
      "template<class T, int SZ> struct OffBIT2D { ",
      "\tbool mode = 0; // mode = 1 -> initialized",
      "\tvpi todo; // locations of updates to process",
      "\tint cnt[SZ], st[SZ];",
      "\tvi val; vector<T> bit; // store all BITs in single vector",
      "\tvoid init() { assert(!mode); mode = 1;",
      "\t\tint lst[SZ]; F0R(i,SZ) lst[i] = cnt[i] = 0;",
      "\t\tsort(all(todo),[](const pi& a, const pi& b) { ",
      "\t\t\treturn a.s < b.s; });",
      "\t\teach(t,todo) for (int x = t.f; x < SZ; x += x&-x) ",
      "\t\t\tif (lst[x] != t.s) lst[x] = t.s, cnt[x] ++;",
      "\t\tint sum = 0; F0R(i,SZ) lst[i] = 0, st[i] = (sum += cnt[i]);",
      "\t\tval.rsz(sum); bit.rsz(sum); reverse(all(todo));",
      "\t\teach(t,todo) for (int x = t.f; x < SZ; x += x&-x) ",
      "\t\t\tif (lst[x] != t.s) lst[x] = t.s, val[--st[x]] = t.s;",
      "\t}",
      "\tint rank(int y, int l, int r) {",
      "\t\treturn ub(begin(val)+l,begin(val)+r,y)-begin(val)-l; }",
      "\tvoid UPD(int x, int y, T t) {",
      "\t\tfor (y = rank(y,st[x],st[x]+cnt[x]); y <= cnt[x]; y += y&-y) ",
      "\t\t\tbit[st[x]+y-1] += t; }",
      "\tvoid upd(int x, int y, T t) { ",
      "\t\tif (!mode) todo.pb({x,y});",
      "\t\telse for (;x<SZ;x+=x&-x) UPD(x,y,t); }",
      "\tint QUERY(int x, int y) { T res = 0;",
      "\t\tfor (y = rank(y,st[x],st[x]+cnt[x]); y; y -= y&-y) res += bit[st[x]+y-1];",
      "\t\treturn res; }",
      "\tT query(int x, int y) { assert(mode);",
      "\t\tT res = 0; for (;x;x-=x&-x) res += QUERY(x,y);",
      "\t\treturn res; }",
      "\tT query(int xl, int xr, int yl, int yr) { ",
      "\t\treturn query(xr,yr)-query(xl-1,yr)",
      "\t\t\t-query(xr,yl-1)+query(xl-1,yl-1); }",
      "};"
    ],
    "description": "point update and rectangle sum with offline 2D BIT. , * For each of the points to be updated, \\$x\\in (0,SZ)\\$ and \\$y\\neq 0\\$., * Time: O(N\\log^2 N), * Memory: O(N\\log N), *"
  },
  "BITseg": {
    "prefix":["benq_BITseg"],
    "body": [
      "/**",
      " * Description: BIT of SegTrees. \\$x\\in (0,SZ), y\\in [0,SZ)\\$.",
      " * Memory: O(N\\log^2 N)",
      " * Source: USACO Mowing the Field",
      " * Verification: ",
      " \t* USACO Mowing the Field",
      " \t* http://www.usaco.org/index.php?page=viewproblem2&cpid=722 (13/15, 15/15 and 1857ms with BumpAllocator)",
      " */",
      "",
      "#include \"../1D Range Queries (9.2)/SparseSeg (9.2).h\"",
      "",
      "template<class T> struct BITseg {",
      "\tnode<T> seg[SZ];",
      "\tBITseg() { F0R(i,SZ) seg[i] = node<T>(); }",
      "\tvoid upd(int x, int y, int v) { // add v",
      "\t\tfor (; x < SZ; x += x&-x) seg[x].upd(y,v); }",
      "\tT query(int x, int yl, int yr) {",
      "\t\tT res = 0; for (; x; x-=x&-x) res += seg[x].query(yl,yr);",
      "\t\treturn res; }",
      "\tT query(int xl, int xr, int yl, int yr) { // query sum of rectangle",
      "\t\treturn query(xr,yl,yr)-query(xl-1,yl,yr); }",
      "};"
    ],
    "description": "BIT of SegTrees. \\$x\\in (0,SZ), y\\in [0,SZ)\\$., * Memory: O(N\\log^2 N), *"
  },
  "BITtree": {
    "prefix":["benq_BITtree"],
    "body": [
      "/**",
      " * Description: BIT of indexed sets (or treaps). \\$x\\in (0,SZ)\\$.",
      " \t* Only supports setting value at each point to \\$0\\$ or \\$1\\$.",
      " * Memory: O(N\\log N)",
      " * Verification: ",
      " \t* http://codeforces.com/contest/785/submission/33953058",
      " \t* http://www.usaco.org/index.php?page=viewproblem2&cpid=722 (13/15)",
      " */",
      "",
      "#include \"../STL (5)/IndexedSet.h\"",
      "",
      "template<int SZ> struct BITtree { ",
      "\tTree<pi> val[SZ]; ",
      "\tvoid upd(int x, int y, int t = 1) { ",
      "\t\tfor (int X = x; X < SZ; X += X&-X) {",
      "\t\t\tif (t == 1) val[X].insert({y,x});",
      "\t\t\telse val[X].erase({y,x});",
      "\t\t}",
      "\t}",
      "\tint query(int x, int y) { ",
      "\t\tint res = 0; for (; x; x -= x&-x) res += val[x].ook({y,MOD});",
      "\t\treturn res;",
      "\t}",
      "\tint query(int xl, int xr, int yl, int yr) { ",
      "\t\treturn query(xr,yr)-query(xl-1,yr)",
      "\t\t\t-query(xr,yl-1)+query(xl-1,yl-1); }",
      "};"
    ],
    "description": "None"
  },
  "SegSeg": {
    "prefix":["benq_SegSeg"],
    "body": [
      "/**",
      " * Description: SegTree of SegTrees. \\$x,y\\in [0,SZ).\\$",
      " * Memory: O(N\\log^2 N)",
      " * Source: USACO Mowing the Field",
      " * Verification: ",
      " \t* http://www.usaco.org/index.php?page=viewproblem2&cpid=722 (9/15 w/ BumpAllocator)",
      " \t* http://www.usaco.org/index.php?page=viewproblem2&cpid=601 (4238 ms, 2907 ms w/ BumpAllocator)",
      " */",
      "",
      "#include \"../1D Range Queries (9.2)/SparseSeg (9.2).h\"",
      "",
      "template<class T> struct Node {",
      "\tnode<T> seg; Node* c[2];",
      "\tNode() { c[0] = c[1] = NULL; }",
      "\tvoid upd(int x, int y, T v, int L = 0, int R = SZ-1) { // add v",
      "\t\tif (L == x && R == x) { seg.upd(y,v); return; }",
      "\t\tint M = (L+R)/2;",
      "\t\tif (x <= M) {",
      "\t\t\tif (!c[0]) c[0] = new Node();",
      "\t\t\tc[0]->upd(x,y,v,L,M);",
      "\t\t} else {",
      "\t\t\tif (!c[1]) c[1] = new Node();",
      "\t\t\tc[1]->upd(x,y,v,M+1,R);",
      "\t\t}",
      "\t\tseg.upd(y,v); // only for addition",
      "\t\t// seg.UPD(y,c[0]?&c[0]->seg:NULL,c[1]?&c[1]->seg:NULL);",
      "\t}",
      "\tT query(int x1, int x2, int y1, int y2, int L = 0, int R = SZ-1) { // query sum of rectangle",
      "\t\tif (x1 <= L && R <= x2) return seg.query(y1,y2);",
      "\t\tif (x2 < L || R < x1) return 0;",
      "\t\tint M = (L+R)/2; T res = 0;",
      "\t\tif (c[0]) res += c[0]->query(x1,x2,y1,y2,L,M);",
      "\t\tif (c[1]) res += c[1]->query(x1,x2,y1,y2,M+1,R);",
      "\t\treturn res;",
      "\t}",
      "};"
    ],
    "description": "SegTree of SegTrees. \\$x,y\\in [0,SZ).\\$, * Memory: O(N\\log^2 N), *"
  },
  "PrefixSums": {
    "prefix":["benq_PrefixSums"],
    "body": [
      "/**",
      " * Description: calculates rectangle sums in constant time",
      " * Source: KACTL",
      " * Verification: POI 16 Ticket Inspector",
      " */",
      "",
      "template<class T> struct PrefixSums {",
      "\tvector<vector<T>> sum;",
      "\tvoid init(const vector<vector<T>>& v) {",
      "\t\tint R = sz(v), C = sz(v[0]);",
      "\t\tsum.assign(R+1,vector<T>(C+1));",
      "\t\tF0R(i,R) F0R(j,C) ",
      "\t\t\tsum[i+1][j+1] = v[i][j]+sum[i+1][j]+sum[i][j+1]-sum[i][j];",
      "\t}",
      "\tT get(int X1, int X2, int Y1, int Y2) {",
      "\t\tX2 ++, Y2 ++;",
      "\t\treturn sum[X2][Y2]-sum[X1][Y2]",
      "\t\t\t-sum[X2][Y1]+sum[X1][Y1];",
      "\t}",
      "};"
    ],
    "description": "calculates rectangle sums in constant time, *"
  },
  "RangeQuery": {
    "prefix":["benq_RangeQuery"],
    "body": [
      "/**",
      " * Description: Range queries for any associative operation on static array",
      " * Time: O(n\\log n) build, O(1) query",
      " * Source: own",
      " * Verification: https://www.codechef.com/problems/SEGPROD",
      " */ ",
      " ",
      "template<class T, int SZ> struct RangeQuery {",
      "\tint n;",
      "\tT stor[SZ][32-__builtin_clz(SZ)], id = 1;",
      "\tvector<T> a;",
      "\tT comb (T a, T b) { return mul(a,b); } // associative operation",
      "\tvoid fill(int l, int r, int ind) {",
      "\t\tif (ind < 0) return;",
      "\t\tint m = (l+r)/2;",
      "\t\tT prod = id; ROF(i,l,m) stor[i][ind] = prod = comb(a[i],prod);",
      "\t\tprod = id; FOR(i,m,r) stor[i][ind] = prod = comb(prod,a[i]);",
      "\t\tfill(l,m,ind-1); fill(m,r,ind-1);",
      "\t}",
      "\tvoid init() {",
      "\t\tn = 1; while ((1<<n) < sz(a)) n ++;",
      "\t\ta.rsz(1<<n); fill(0,(1<<n),n-1);",
      "\t}",
      "\tT query(int l, int r) {",
      "\t\tif (l == r) return a[l];",
      "\t\tint t = 31-__builtin_clz(r^l);",
      "\t\treturn comb(stor[l][t],stor[r][t]);",
      "\t}",
      "};"
    ],
    "description": "Range queries for any associative operation on static array, * Time: O(n\\log n) build, O(1) query, *"
  },
  "RMQ": {
    "prefix":["benq_RMQ"],
    "body": [
      "/**",
      " * Description: 1D range minimum query. Can also do queries ",
      " \t* for any associative operation in \\$O(1)\\$ with D\\&C",
      " * Source: KACTL",
      " * Verification: ",
      "\t* https://cses.fi/problemset/stats/1647/",
      "\t* http://wcipeg.com/problem/ioi1223",
      "\t* https://pastebin.com/ChpniVZL",
      " * Memory: O(N\\log N)",
      " * Time: O(1)",
      " */",
      "",
      "template<class T> struct RMQ { // floor(log_2(x))",
      "\tint level(int x) { return 31-__builtin_clz(x); } ",
      "\tvector<T> v; vector<vi> jmp;",
      "\tint comb(int a, int b) { // index of min",
      "\t\treturn v[a]==v[b]?min(a,b):(v[a]<v[b]?a:b); } ",
      "\tvoid init(const vector<T>& _v) {",
      "\t\tv = _v; jmp = {vi(sz(v))}; iota(all(jmp[0]),0);",
      "\t\tfor (int j = 1; 1<<j <= sz(v); ++j) {",
      "\t\t\tjmp.pb(vi(sz(v)-(1<<j)+1));",
      "\t\t\tF0R(i,sz(jmp[j])) jmp[j][i] = comb(jmp[j-1][i],",
      "\t\t\t\t\t\t\t\t\tjmp[j-1][i+(1<<(j-1))]);",
      "\t\t}",
      "\t}",
      "\tint index(int l, int r) { // get index of min element",
      "\t\tassert(l <= r); int d = level(r-l+1);",
      "\t\treturn comb(jmp[d][l],jmp[d][r-(1<<d)+1]); }",
      "\tT query(int l, int r) { return v[index(l,r)]; }",
      "};"
    ],
    "description": "1D range minimum query. Can also do queries ,  * for any associative operation in \\$O(1)\\$ with D\\&C, *"
  },
  "Bset": {
    "prefix":["benq_Bset"],
    "body": [
      "/**",
      " * Description: bitset of variable size",
      " * Source: Own",
      " \t* Also see https://www.hackerrank.com/contests/noi-ph-2019-finals-1/challenges/sumbong-centers/editorial",
      " \t* Order of operations",
      " \t\t* https://en.cppreference.com/w/cpp/language/operator_precedence",
      " * Verification: see bset.cpp",
      " */",
      "",
      "struct bset {",
      "\ttypedef uint64_t ul;",
      "\tint size; vector<ul> b; ",
      "\tbset(int x) : size(x), b((x+63)/64) {}",
      "\tbool get(int x) const { return (b[x/64]>>(x%64))&1; }",
      "\tvoid flip(int x) { b[x/64] ^= (ul)1<<(x%64); }",
      "\tvoid set(int x) { if (!get(x)) flip(x); }",
      "\tint count() {",
      "\t\tint res = 0; each(t,b) res += __builtin_popcountll(t);",
      "\t\treturn res; }",
      "\tfriend void pr(const bset&x){F0R(i,x.size)pr((int)x.get(i));}",
      "\tbset& operator|=(const bset& r) {",
      "\t\tassert(size == r.size); F0R(i,sz(b)) b[i] |= r.b[i]; ",
      "\t\treturn b; }",
      "\tbset& operator&=(const bset& r) {",
      "\t\tassert(size == r.size); F0R(i,sz(b)) b[i] &= r.b[i]; ",
      "\t\treturn b; }",
      "\tbset& operator^=(const bset& r) {",
      "\t\tassert(size == r.size); F0R(i,sz(b)) b[i] ^= r.b[i]; ",
      "\t\treturn b; }",
      "\tbset shift(int inc) { // cyclic shift b to right",
      "\t\tinc %= size; if (inc < 0) inc += size;",
      "\t\tbset res(size);",
      "\t\tint r0 = inc/64, r1 = inc%64;",
      "\t\tint l0 = (size-inc)/64, l1 = (size-inc)%64;",
      "\t\tF0R(i,sz(b)-r0) {",
      "\t\t\tres.b[i+r0] |= b[i]<<r1;",
      "\t\t\tif (r1 && i+r0+1 < sz(b)) ",
      "\t\t\t\tres.b[i+r0+1] |= b[i]>>(64-r1);",
      "\t\t}",
      "\t\tFOR(i,l0,sz(b)) {",
      "\t\t\tres.b[i-l0] |= b[i]>>l1;",
      "\t\t\tif (l1 && i >= l0+1) ",
      "\t\t\t\tres.b[i-l0-1] |= b[i]<<(64-l1);",
      "\t\t}",
      "\t\tint rem = size%64; if (rem) res.b.bk &= ((ul)1<<rem)-1;",
      "\t\treturn res;",
      "\t}",
      "\tint findNext(int x) { // first bit after x",
      "\t\tint i = x < 0 ? -1 : x/64, p = (x+1)%64;",
      "\t\tif (p != 0) {",
      "\t\t\tul a = b[i]; a ^= a&(((ul)1<<p)-1);",
      "\t\t\tint t = __builtin_ffsll(a);",
      "\t\t\tif (t) return 64*i+t-1;",
      "\t\t}",
      "\t\twhile (++i < sz(b)) {",
      "\t\t\tint t = __builtin_ffsll(b[i]);",
      "\t\t\tif (t) return 64*i+t-1;",
      "\t\t}",
      "\t\treturn size;",
      "\t}",
      "};"
    ],
    "description": "bitset of variable size, *"
  },
  "CoordCompress": {
    "prefix":["benq_CoordCompress"],
    "body": [
      "/**",
      " * Description: coordinate compression, get index of x by counting # of elements < x",
      " * Source: Own",
      " * Verification: ?",
      " */",
      "",
      "template<class T> void nor(vector<T>& v) {",
      "\tsort(all(v)); v.erase(unique(all(v)),end(v)); }",
      "template<class T> int ind(vector<T>& v, T x) { ",
      "\treturn lb(all(v),x)-begin(v); }"
    ],
    "description": "coordinate compression, get index of x by counting # of elements < x, *"
  },
  "HashMap": {
    "prefix":["benq_HashMap"],
    "body": [
      "/**",
      " * Description: Hash map with the same API as unordered\\_map, but \\tilde 3x faster.",
      " \t* Initial capacity must be a power of 2 if provided.",
      " * Source: KACTL",
      " * Usage: ht<int,int> h({},{},{},{},{1<<16});",
      " */",
      "",
      "#include <ext/pb_ds/assoc_container.hpp>",
      "using namespace __gnu_pbds;",
      "struct chash { /// use most bits rather than just the lowest ones",
      "\tconst uint64_t C = ll(2e18*PI)+71; // large odd number",
      "\tconst int RANDOM = rng();",
      "\tll operator()(ll x) const { /// https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html",
      "\t\treturn __builtin_bswap64((x^RANDOM)*C); }",
      "};",
      "template<class K,class V> using um = unordered_map<K,V,chash>;",
      "template<class K,class V> using ht = gp_hash_table<K,V,chash>;",
      "template<class K,class V> V get(ht<K,V>& u, K x) {",
      "\tauto it = u.find(x); return it == end(u) ? 0 : it->s; }"
    ],
    "description": "Hash map with the same API as unordered\\_map, but \\tilde 3x faster.,  * Initial capacity must be a power of 2 if provided., *"
  },
  "HashMapSmall": {
    "prefix":["benq_HashMapSmall"],
    "body": [
      "/**",
      " * Description: Unordered map with keys in [0,SZ). (In case you're dumb like me and you need to replace a map rlly quickly ...)",
      " * Source: Own",
      " * Usage: HT<int,1<<20> dp;",
      " */",
      "",
      "template<class T, int SZ> struct HT {",
      "\tvi keys; bitset<SZ> inside; T dat[SZ];",
      "\tvoid clear() { ",
      "\t\teach(t,keys) inside[t] = 0;",
      "\t\tkeys.clear(); ",
      "\t}",
      "\tT& operator[](int k) { ",
      "\t\tif (!inside[k]) {",
      "\t\t\tinside[k] = 1, keys.pb(k); ",
      "\t\t\tdat[k] = 0;",
      "\t\t}",
      "\t\treturn dat[k]; ",
      "\t}",
      "};"
    ],
    "description": "Unordered map with keys in [0,SZ). (In case you're dumb like me and you need to replace a map rlly quickly ...), *"
  },
  "IndexedSet": {
    "prefix":["benq_IndexedSet"],
    "body": [
      "/**",
      " * Description: A set (not multiset!) with support for finding the \\$n\\$'th",
      " * element, and finding the index of an element. Change \\texttt{null\\_type} for map.",
      " * Time: O(\\log N)",
      " * Source: KACTL",
      "   * https://codeforces.com/blog/entry/11080",
      " * Verification: many",
      " */",
      "",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "#include <ext/pb_ds/assoc_container.hpp>",
      "using namespace __gnu_pbds;",
      "template <class T> using Tree = tree<T, null_type, less<T>, ",
      "\trb_tree_tag, tree_order_statistics_node_update>; ",
      "#define ook order_of_key",
      "#define fbo find_by_order",
      "",
      "void treeExample() {",
      "\tTree<int> t, t2; t.insert(8);",
      "\tauto it = t.insert(10).f; assert(it == t.lb(9));",
      "\tassert(t.ook(10) == 1 && t.ook(11) == 2 && *t.fbo(0) == 8);",
      "\tt.join(t2); // assuming T < T2 or T > T2, merge t2 into t",
      "}",
      "",
      "/**",
      "int atMost(Tree<pi>& T, int r) { ",
      "\treturn T.ook({r,MOD}); }",
      "int getSum(Tree<pi>& T, int l, int r) { ",
      "\treturn atMost(T,r)-atMost(T,l-1); }",
      "*/"
    ],
    "description": "A set (not multiset!) with support for finding the \\$n\\$'th, * element, and finding the index of an element. Change \\texttt{null\\_type} for map., * Time: O(\\log N), *"
  },
  "LCDeque": {
    "prefix":["benq_LCDeque"],
    "body": [
      "/**",
      " * Description: LineContainer assuming both slopes and queries monotonic.",
      " * Time: O(1)",
      " * Source: Own",
      " * Verification: http://acm.hdu.edu.cn/diy/contest_showproblem.php?cid=36005&pid=1009",
      " \t* http://www.usaco.org/index.php?page=viewproblem2&cpid=626",
      " */",
      "",
      "#include \"LCold.h\"",
      "",
      "struct LCdeque : deque<Line> { ",
      "\tvoid addBack(Line L) { // assume nonempty",
      "\t\twhile (1) {",
      "\t\t\tauto a = bk; pop_back(); a.lst = a.bet(L);",
      "\t\t\tif (size() && bk.lst >= a.lst) continue;",
      "\t\t\tpb(a); break;",
      "\t\t}",
      "\t\tL.lst = inf; pb(L);",
      "\t}",
      "\tvoid addFront(Line L) {",
      "\t\twhile (1) {",
      "\t\t\tif (!size()) { L.lst = inf; break; }",
      "\t\t\tif ((L.lst = L.bet(ft)) >= ft.lst) pop_front();",
      "\t\t\telse break;",
      "\t\t}",
      "\t\tpush_front(L);",
      "\t}",
      "\tvoid add(ll a, ll b) { // line goes to one end of deque",
      "\t\tif (!size() || a <= ft.a) addFront({a,b,0});",
      "\t\telse assert(a >= bk.a), addBack({a,b,0});",
      "\t}",
      "\tint ord = 0; // 1 = increasing, -1 = decreasing",
      "\tll query(ll x) { ",
      "\t\tassert(ord);",
      "\t\tif (ord == 1) { ",
      "\t\t\twhile (ft.lst < x) pop_front();",
      "\t\t\treturn ft.eval(x);",
      "\t\t} else {",
      "\t\t\twhile(size()>1&&prev(prev(end()))->lst>=x)pop_back();",
      "\t\t\treturn bk.eval(x);",
      "\t\t}",
      "\t}\t",
      "};"
    ],
    "description": "LineContainer assuming both slopes and queries monotonic., * Time: O(1), *"
  },
  "LCnew": {
    "prefix":["benq_LCnew"],
    "body": [
      "/**",
      " * Description: LineContainer. Works with C++14 and beyond.",
      " \t* Given set of lines, computes greatest \\$y\\$-coordinate for any \\$x.\\$",
      " * Time: O(\\log N)",
      " * Source: KACTL",
      "   * https://codeforces.com/blog/entry/63823?#comment-477568",
      " * Verification: ",
      "   * CSA Squared Ends not working :(",
      "   * https://codeforces.com/contest/1083/problem/E",
      "   * https://atcoder.jp/contests/arc066/tasks/arc066_d",
      " */",
      "",
      "struct Line {",
      "\tmutable ll k, m, p; // slope, y-intercept, last optimal x",
      "\tll eval (ll x) { return k*x+m; }",
      "\tbool operator<(const Line& o) const { return k < o.k; }",
      "\tbool operator<(ll x) const { return p < x; }",
      "};",
      "",
      "// for doubles, use inf = 1/.0, div(a,b) = a/b",
      "const ll inf = LLONG_MAX;",
      "// floored division",
      "ll divi(ll a, ll b) { return a/b-((a^b) < 0 && a%b); } ",
      "// last x such that first line is better",
      "ll bet(const Line& x, const Line& y) { ",
      "\tif (x.k == y.k) return x.m >= y.m ? inf : -inf;",
      "\treturn divi(y.m-x.m,x.k-y.k);",
      "}",
      "",
      "struct LC : multiset<Line,less<>> { ",
      "\t// updates x->p, determines if y is unneeded",
      "\tbool isect(iterator x, iterator y) { ",
      "\t\tif (y == end()) { x->p = inf; return 0; }",
      "\t\tx->p = bet(*x,*y); return x->p >= y->p;",
      "\t}",
      "\tvoid add(ll k, ll m) {",
      "\t\tauto z = insert({k,m,0}), y = z++, x = y;",
      "\t\twhile (isect(y, z)) z = erase(z);",
      "\t\tif (x != begin() && isect(--x, y)) isect(x, y = erase(y));",
      "\t\twhile ((y = x) != begin() && (--x)->p >= y->p) ",
      "\t\t\tisect(x, erase(y));",
      "\t}",
      "\tll query(ll x) {",
      "\t\tassert(!empty());",
      "\t\tauto l = *lb(x); return l.k*x+l.m;",
      "\t}",
      "};"
    ],
    "description": "LineContainer. Works with C++14 and beyond.,  * Given set of lines, computes greatest \\$y\\$-coordinate for any \\$x.\\$, * Time: O(\\log N), *"
  },
  "LCold": {
    "prefix":["benq_LCold"],
    "body": [
      "/**",
      " * Description: LineContainer; add lines of the form \\$ax+b\\$, ",
      " \t* compute greatest \\$y\\$-coordinate for any \\$x\\$.",
      " * Time: O(\\log N)",
      " * Source: KACTL",
      "   * https://github.com/kth-competitive-programming/kactl/commit/165807e28402c9be906f6e6a09452431787bb70d?diff=unified",
      " * Verification: https://judge.yosupo.jp/problem/line_add_get_min",
      " */",
      "",
      "using T = ll; // ll or db",
      "db fdiv(db a, db b) { return a/b; } // for doubles just divide normally",
      "// for lls do floored division",
      "",
      "const T inf = LLONG_MAX; bool _Q;",
      "struct Line { // a and b -> slope and y-intercept ",
      "\tmutable T a, b, lst; // lst can change",
      "\t/// friend str ts(const Line& L) { return ts(vl{L.a,L.b,L.lst}); }",
      "\tT eval(T x) const { return a*x+b; }",
      "\tbool operator<(const Line& y) const { return _Q?lst<y.lst:a<y.a; }",
      "\tT bet(const Line& y) const { assert(a <= y.a);",
      "\t\treturn a == y.a ? (b >= y.b ? inf : -inf) : fdiv(b-y.b,y.a-a); }",
      "};",
      "",
      "struct LC : multiset<Line> {",
      "\tbool rem(iterator IT) { auto it = IT++; // update lst for it",
      "\t\tif (IT == end()) return it->lst = inf, 0;",
      "\t\treturn (it->lst = it->bet(*IT)) >= IT->lst; }",
      "\tvoid add(T a, T b) { // y -> inserted pos",
      "\t\tauto z = insert({a,b,0}), y = z++, x = y; ",
      "\t\twhile (rem(y)) erase(z++); /// remove stuff after insertion pos",
      "\t\tif (x != begin() && rem(--x)) erase(y), rem(x); /// remove inserted line",
      "\t\twhile ((y = x) != begin() && (--x)->lst >= y->lst) ",
      "\t\t\terase(y), rem(x); /// remove stuff before insertion pos",
      "\t}",
      "\tT query(T p) { ",
      "\t\tassert(size()); _Q = 1; ",
      "\t\tT ret = lb({0,0,p})->eval(p); _Q = 0; return ret; }",
      "};"
    ],
    "description": "LineContainer; add lines of the form \\$ax+b\\$, ,  * compute greatest \\$y\\$-coordinate for any \\$x\\$., * Time: O(\\log N), *"
  },
  "MapComparator": {
    "prefix":["benq_MapComparator"],
    "body": [
      "/**",
      " * Description: example of function object (functor) for map or set",
      " * Source: StackOverflow",
      " * Usage: set<int,cmp> s; map<int,int,cmp> m;",
      " */",
      "",
      "struct cmp{bool operator()(int l,int r)const{return l>r;}};"
    ],
    "description": "example of function object (functor) for map or set, *"
  },
  "MinDeque": {
    "prefix":["benq_MinDeque"],
    "body": [
      "/**",
      " * Description: maintains minimum of deque while adding ",
      "\telements to back or deleting elements from front",
      " * Source: own",
      " * Verification: USACO Jan 18 Lifeguards",
      " */",
      "",
      "template<class T> struct MinDeque { ",
      "\tint lo = 0, hi = -1;",
      "\tdeque<pair<T,int>> d;",
      "\tint size() { return hi-lo+1; }",
      "\tvoid push(T x) { // add to back",
      "\t\twhile (sz(d) && d.back().f >= x) d.pop_back();",
      "\t\td.pb({x,++hi});",
      "\t}",
      "\tvoid pop() { // delete from front",
      "\t\tassert(size());",
      "\t\tif (d.front().s == lo++) d.pop_front();",
      "\t}",
      "\tT mn() { return size() ? d.front().f : MOD; }",
      "\t// change MOD based on T",
      "};"
    ],
    "description": "maintains minimum of deque while adding , elements to back or deleting elements from front, *"
  },
  "PQ": {
    "prefix":["benq_PQ"],
    "body": [
      "/**",
      " * Description: Priority queue w/ modification. Use for Dijkstra?",
      " * Source: https://gcc.gnu.org/onlinedocs/libstdc++/ext/pb_ds/pq_design.html",
      " * Verification: ?",
      " */",
      "",
      "#include <ext/pb_ds/priority_queue.hpp>",
      "",
      "void pqExample() {",
      "\t__gnu_pbds::priority_queue<int> p;",
      "\tvi act; vector<decltype(p)::point_iterator> v;",
      "\tint n = 1000000;",
      "\tF0R(i,n) { int r = rand(); act.pb(r), v.pb(p.push(r)); }",
      "\tF0R(i,n) { int r = rand(); act[i] = r, p.modify(v[i],r); }",
      "\tsort(rall(act));",
      "\tF0R(i,n) { assert(act[i] == p.top()); p.pop(); }",
      "}"
    ],
    "description": "Priority queue w/ modification. Use for Dijkstra?, *"
  },
  "Rope": {
    "prefix":["benq_Rope"],
    "body": [
      "/**",
      " * Description: insert element at \\$i\\$-th position, cut a substring and ",
      " \t* re-insert somewhere else. At least 2 times slower than handwritten treap.",
      " * Time: O(\\log N) per operation? not well tested",
      " * Source: https://codeforces.com/blog/entry/10355",
      " * Verification: CEOI 2018 Day 2 Triangles",
      "\t* https://szkopul.edu.pl/problemset/problem/AzKAZ2RDiVTjeWSBolwoC5zl/site/?key=statement",
      "\t* vector is faster for this problem ...",
      " */",
      "",
      "#include <ext/rope>",
      "using namespace __gnu_cxx;",
      "void ropeExample() {",
      "\trope<int> v(5,0); // initialize with 5 zeroes",
      "\tF0R(i,sz(v)) v.mutable_reference_at(i) = i+1; ",
      "\tF0R(i,5) v.pb(i+1); // constant time pb",
      "\trope<int> cur = v.substr(1,2); ",
      "\tv.erase(1,3); // erase 3 elements starting from 1st element",
      "\tfor (rope<int>::iterator it = v.mutable_begin(); ",
      "\t\tit != v.mutable_end(); ++it) pr((int)*it,' ');",
      "\tps(); // 1 5 1 2 3 4 5",
      "\tv.insert(v.mutable_begin()+2,cur); // or just 2",
      "\tv += cur; F0R(i,sz(v)) pr(v[i],' ');",
      "\tps(); // 1 5 2 3 1 2 3 4 5 2 3",
      "}"
    ],
    "description": "insert element at \\$i\\$-th position, cut a substring and ,  * re-insert somewhere else. At least 2 times slower than handwritten treap., * Time: O(\\log N) per operation? not well tested, *"
  },
  "DynaCon": {
    "prefix":["benq_DynaCon"],
    "body": [
      "/**",
      " * Description: Dynamic Connectivity with Euler Tour Trees",
      " * Time: O(\\log^2 N)",
      " * Source:",
      " \t* https://courses.csail.mit.edu/6.851/spring12/scribe/L20.pdf",
      " * Verification:",
      " \t* https://www.spoj.com/problems/DYNACON1/ (data is very weak though)",
      " \t* https://dmoj.ca/problem/wac4p7 (first two subtasks)",
      " */",
      "",
      "// TREAP OPERATIONS",
      "",
      "constexpr int MAX_N = 1e5+5, MAX_M = 1e5+5;",
      "",
      "int N;",
      "",
      "template<int SZ> struct Treap {",
      "\tint cnt, pri[SZ], par[SZ], sz[SZ]; // ETT node for each edge",
      "\tbitset<SZ> specialNode, existsSpecialNode;",
      "\tbitset<SZ> specialEdge, existsSpecialEdge;",
      "\tint edgeId[SZ];",
      "\tAR<int,2> c[SZ];",
      "\tint makeEdge(int label) {",
      "\t\tedgeId[++cnt] = label; pri[cnt] = rng(); sz[cnt] = 1;",
      "\t\treturn cnt;",
      "\t}",
      "\tvoid calc(int x) {",
      "\t\tint a = c[x][0], b = c[x][1];",
      "\t\tsz[x] = 1+sz[a]+sz[b];",
      "\t\texistsSpecialNode[x]=specialNode[x]|existsSpecialNode[a]|existsSpecialNode[b];",
      "\t\texistsSpecialEdge[x]=specialEdge[x]|existsSpecialEdge[a]|existsSpecialEdge[b];",
      "\t}",
      "\tint extractSpecialEdge(int x) {",
      "\t\tint a = c[x][0], b = c[x][1], res;",
      "\t\tassert(existsSpecialEdge[x]);",
      "\t\tif (specialEdge[x]) {",
      "\t\t\tres = edgeId[x], specialEdge[x] = 0;",
      "\t\t} else if (existsSpecialEdge[a]) res = extractSpecialEdge(a);",
      "\t\telse res = extractSpecialEdge(b);",
      "\t\tassert(res >= 0); calc(x); return res;",
      "\t}",
      "\tint extractSpecialNode(int x) {",
      "\t\tassert(existsSpecialNode[x]);",
      "\t\tint a = c[x][0], b = c[x][1];",
      "\t\tif (specialNode[x]) return x;",
      "\t\tif (existsSpecialNode[a]) return extractSpecialNode(a);",
      "\t\treturn extractSpecialNode(b);",
      "\t}",
      "\tint getRoot(int x) { // get top node in ETT",
      "\t\twhile (par[x]) x = par[x];",
      "\t\treturn x;",
      "\t}",
      "\tbool con(int a, int b) { return getRoot(a) == getRoot(b); }",
      "\tvoid link(int x, int d, int y) { // set d-th child of x to y",
      "\t\tassert(x); assert(d == 0 || d == 1);",
      "\t\tassert(!c[x][d]), c[x][d] = y; ",
      "\t\tif (y) assert(!par[y]), par[y] = x;",
      "\t\tcalc(x);",
      "\t}",
      "\tint dis(int x, int d) { // disconnected d-th child of x",
      "\t\tassert(x); assert(d == 0 || d == 1);",
      "\t\tint y = c[x][d]; c[x][d] = 0; calc(x);",
      "\t\tif (y) assert(par[y] == x), par[y] = 0;",
      "\t\treturn y;",
      "\t}",
      "\tpi split(int x) { // x and everything to right goes in p.s",
      "\t\t// everything else goes in p.f",
      "\t\tpi p = {dis(x,0),x};",
      "\t\twhile (par[x]) {",
      "\t\t\tint y = par[x];",
      "\t\t\tif (c[y][0] == x) {",
      "\t\t\t\tdis(y,0), link(y,0,p.s),  p.s = y;",
      "\t\t\t} else {",
      "\t\t\t\tassert(c[y][1] == x);",
      "\t\t\t\tdis(y,1), link(y,1,p.f); p.f = y;",
      "\t\t\t}",
      "\t\t\tx = y;",
      "\t\t}",
      "\t\tassert(!par[p.f] && !par[p.s]); return p;",
      "\t}",
      "\tint merge(int x, int y) {",
      "\t\tassert(!par[x] && !par[y]);",
      "\t\tif (!x || !y) return max(x,y);",
      "\t\tif (pri[x] > pri[y]) {",
      "\t\t\tint X = dis(x,1);",
      "\t\t\tlink(x,1,merge(X,y));",
      "\t\t\treturn x;",
      "\t\t} else {",
      "\t\t\tint Y = dis(y,0);",
      "\t\t\tlink(y,0,merge(x,Y));",
      "\t\t\treturn y;",
      "\t\t}",
      "\t}",
      "\tint getFirst(int x) {",
      "\t\tif (!x) return 0;",
      "\t\twhile (c[x][0]) x = c[x][0];",
      "\t\treturn x;",
      "\t}",
      "\tint makeFirst(int x) { // rotate ETT of x such that x is first",
      "\t\tassert(x); pi p = split(x); return merge(p.s,p.f); }",
      "\tvoid remFirst(int x) { // remove first node of ETT rooted at x",
      "\t\tassert(x && !par[x]);",
      "\t\twhile (c[x][0]) x = c[x][0];",
      "\t\tint y = dis(x,1), p = par[x];",
      "\t\tif (p) dis(p,0), link(p,0,y);",
      "\t\twhile (p) {",
      "\t\t\tcalc(p);",
      "\t\t\tp = par[p];",
      "\t\t}",
      "\t}",
      "\tint reroot(int x) { ",
      "\t\tassert(1 <= x && x <= N); return makeFirst(x); }",
      "\tvoid markSpecialNode(int x, int val) {",
      "\t\tif (specialNode[x] == val) return;",
      "\t\tfor(specialNode[x]=val;x;x=par[x]) ",
      "\t\t\tcalc(x);",
      "\t}",
      "};",
      "",
      "vpi ed; vi edgeLevel; vb span; // vertices which edge connects, level of edge, whether edge is part of spanning tree",
      "struct ETT {",
      "\tTreap<MAX_N+2*MAX_M> T;",
      "\tint level; // level of ETT, 0 to log(N)",
      "\tvpi nonSpan[MAX_N]; // list of non-spanning edges adjacent to each vertex",
      "\tpi edgeNodes[MAX_M]; // list of spanning edges",
      "\tint spanEdges;",
      "\tvoid init(int _level) {",
      "\t\tlevel = _level; ",
      "\t\tF0R(i,N) T.makeEdge(-1);",
      "\t}",
      "\tbool con(int a, int b) { return T.con(a,b); }",
      "\tbool add(int label) {",
      "\t\tassert(level <= edgeLevel[label]);",
      "\t\tint a = ed[label].f, b = ed[label].s;",
      "\t\tif (con(a,b)) {",
      "\t\t\tassert(!span[label]);",
      "\t\t\tnonSpan[a].pb({label,b}), nonSpan[b].pb({label,a});",
      "\t\t\tT.markSpecialNode(a,1), T.markSpecialNode(b,1); ",
      "\t\t\treturn 0;",
      "\t\t} else {",
      "\t\t\tspanEdges ++;",
      "\t\t\tspan[label] = 1;",
      "\t\t\tint ta = T.reroot(a), tb = T.reroot(b); ",
      "\t\t\tif (ta||tb) assert(ta != tb);",
      "\t\t\tint x = T.makeEdge(label), y = T.makeEdge(label);",
      "\t\t\tedgeNodes[label] = {x,y};",
      "\t\t\tif (level == edgeLevel[label]) {",
      "\t\t\t\tT.specialEdge[x] = T.existsSpecialEdge[x] = 1;",
      "\t\t\t}",
      "\t\t\tT.merge(T.merge(ta,x),T.merge(tb,y));",
      "\t\t\treturn 1;",
      "\t\t}",
      "\t}",
      "\tvoid rem(int label) { // remove smth that's in the spanning tree",
      "\t\tint x,y; tie(x,y) = edgeNodes[label]; assert(x && y);",
      "\t\tT.makeFirst(x);",
      "\t\tpi p = T.split(y); assert(T.getFirst(p.f) == x && T.getFirst(p.s) == y);",
      "\t\tT.remFirst(p.f), T.remFirst(p.s); spanEdges --;",
      "\t}",
      "\tpair<vi,int> replace(int x, int y) {",
      "\t\t// dbg(\"FIND REPLACEMENT\",level,x,y);",
      "\t\tx = T.getRoot(x), y = T.getRoot(y); // try to find replacement edge for (x,y)",
      "\t\tif (T.sz[x] > T.sz[y]) swap(x,y); // loop over smaller component",
      "\t\tpair<vi,int> res = {{},-1};",
      "\t\twhile (T.existsSpecialEdge[x]) {",
      "\t\t\t// increase levels of all spanning tree edges",
      "\t\t\tint ind = T.extractSpecialEdge(x);",
      "\t\t\tassert(edgeLevel[ind] == level); ",
      "\t\t\tres.f.pb(ind); edgeLevel[ind] ++;",
      "\t\t}",
      "\t\twhile (T.existsSpecialNode[x]) {",
      "\t\t\tint t = T.extractSpecialNode(x);",
      "\t\t\twhile (sz(nonSpan[t])) {",
      "\t\t\t\tpi u = nonSpan[t].bk; nonSpan[t].pop_back();",
      "\t\t\t\tif (edgeLevel[u.f] > level || span[u.f]) continue; // outdated information",
      "\t\t\t\tassert(edgeLevel[u.f] == level);",
      "\t\t\t\tint r = T.getRoot(u.s); ",
      "\t\t\t\tassert(r == x || r == y);",
      "\t\t\t\tif (r == y) { res.s = u.f; return res; } // wow done!",
      "\t\t\t\tres.f.pb(u.f); edgeLevel[u.f] ++;",
      "\t\t\t}",
      "\t\t\tT.markSpecialNode(t,0);",
      "\t\t}",
      "\t\treturn res;",
      "\t}",
      "};",
      "",
      "struct DynaCon {",
      "\tETT E[17]; void init() { F0R(i,17) E[i].init(i); }",
      "\tbool con(int a, int b) { return E[0].con(a,b); }",
      "\tmap<pi,vi> edges;",
      "\tvoid add(int a, int b) { // add an edge",
      "\t\tif (a > b) swap(a,b);",
      "\t\t// dbg(\"add\",a,b);",
      "\t\tint label = sz(ed);",
      "\t\ted.pb({a,b}); edgeLevel.pb(0); span.pb(0);",
      "\t\tedges[{a,b}].pb(label); ",
      "\t\tE[0].add(label);",
      "\t}",
      "\tvoid rem(int a, int b) { // remove an edge",
      "\t\tif (a > b) swap(a,b);",
      "\t\tvi& edgeLabels = edges[{a,b}]; assert(sz(edgeLabels));",
      "\t\tint label = edgeLabels.bk; edgeLabels.pop_back();",
      "\t\tREM(label);",
      "\t}",
      "\tvoid REM(int label) {",
      "\t\tint L = edgeLevel[label]; edgeLevel[label] = MOD;",
      "\t\tif (!span[label]) return;",
      "\t\tF0R(i,L+1) E[i].rem(label); // remove from spanning tree",
      "\t\twhile (L >= 0) {",
      "\t\t\tpair<vi,int> p = E[L].replace(ed[label].f,ed[label].s);",
      "\t\t\teach(t,p.f) {",
      "\t\t\t\tassert(edgeLevel[t] == L+1);",
      "\t\t\t\tif (span[t]) assert(E[L+1].add(t));",
      "\t\t\t\telse {",
      "\t\t\t\t\tassert(!E[L+1].add(t));",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\tif (p.s != -1) { // found a replacement edge!",
      "\t\t\t\tassert(!span[p.s]);",
      "\t\t\t\tF0R(i,L+1) assert(E[i].add(p.s));",
      "\t\t\t\tassert(span[p.s]);",
      "\t\t\t\treturn;",
      "\t\t\t}",
      "\t\t\tL --;",
      "\t\t}",
      "\t}",
      "};",
      "",
      "DynaCon D;",
      "set<pi> lo, hi;",
      "int a[MAX_M],b[MAX_M],d[MAX_M],t[MAX_M];",
      "bool LO[MAX_M];",
      "",
      "int main() {",
      "\tint M,Q; re(N,M,Q);",
      "\tD.init();",
      "\tF0R(i,M) {",
      "\t\tre(a[i],b[i],d[i],t[i]);",
      "\t}",
      "\tvi edgeInds(M); iota(all(edgeInds),0);",
      "\tsort(all(edgeInds),[&](int x, int y) { return d[x] < d[y]; });",
      "\teach(i,edgeInds) hi.insert({t[i],i});",
      "\tV<AR<int,3>> query;",
      "\tF0R(i,Q) {",
      "\t\tint x,y; re(x,y);",
      "\t\tquery.pb({x,y,i});",
      "\t}",
      "\tsort(all(query));",
      "\tint ind = 0;",
      "\tvb ans(Q);",
      "\teach(_,query) {",
      "\t\twhile (ind < sz(edgeInds) && d[edgeInds[ind]] < _[0]) {",
      "\t\t\tint x = edgeInds[ind++];",
      "\t\t\tif (LO[x]) lo.erase({t[x],x}), D.rem(a[x],b[x]);",
      "\t\t\telse hi.erase({t[x],x});",
      "\t\t}",
      "\t\twhile (sz(hi) && D.E[0].spanEdges < N-1) {",
      "\t\t\tint x = hi.begin()->s; hi.erase(begin(hi));",
      "\t\t\tlo.insert({t[x],x}); D.add(a[x],b[x]); LO[x] = 1;",
      "\t\t}",
      "\t\tif (D.E[0].spanEdges == N-1 && lo.rbegin()->f <= _[1]) {",
      "\t\t\tans[_[2]] = 1;",
      "\t\t}",
      "\t}",
      "\tfor (bool a: ans) ps(a?\"YES\":\"NO\");",
      "}"
    ],
    "description": "Dynamic Connectivity with Euler Tour Trees, * Time: O(\\log^2 N), *"
  },
  "ETT": {
    "prefix":["benq_ETT"],
    "body": [
      "/**",
      " * Description: Euler Tour Tree using treap, each edge is",
      " \t* represented by two nodes. Supports reroot, insert edge, ",
      " \t* delete edge, get connected component. Can support",
      " \t* aggregate over vertices in connected component by ",
      " \t* introducing self-loops.",
      " * Time: O(\\log N)",
      " * Source:",
      " \t* https://codeforces.com/blog/entry/53265 (Rerooting dynamic Euler tour trees)",
      " \t* https://codeforces.com/blog/entry/18369 (On Euler tour trees)",
      " * Verification:",
      " \t* https://www.spoj.com/problems/DYNACON1/",
      " */",
      "",
      "// TREAP OPERATIONS",
      "int cnt, pri[MX], par[MX]; // ETT node for each edge",
      "AR<int,2> c[MX];",
      "",
      "int getRoot(int x) { // get top node in ETT",
      "\twhile (par[x]) x = par[x];",
      "\treturn x;",
      "}",
      "void link(int x, int d, int y) { // set d-th child of x to y",
      "\tassert(x); assert(d == 0 || d == 1);",
      "\tassert(!c[x][d]), c[x][d] = y; ",
      "\tif (y) assert(!par[y]), par[y] = x;",
      "}",
      "int dis(int x, int d) { // disconnected d-th child of x",
      "\tassert(x); assert(d == 0 || d == 1);",
      "\tint y = c[x][d]; c[x][d] = 0;",
      "\tif (y) assert(par[y] == x), par[y] = 0;",
      "\treturn y;",
      "}",
      "pi split(int x) { // x and everything to right goes in p.s",
      "\t// everything else goes in p.f",
      "\tpi p = {dis(x,0),x};",
      "\twhile (par[x]) {",
      "\t\tint y = par[x];",
      "\t\tif (c[y][0] == x) {",
      "\t\t\tdis(y,0), link(y,0,p.s),  p.s = y;",
      "\t\t} else {",
      "\t\t\tassert(c[y][1] == x);",
      "\t\t\tdis(y,1), link(y,1,p.f); p.f = y;",
      "\t\t}",
      "\t\tx = y;",
      "\t}",
      "\tassert(!par[p.f] && !par[p.s]); return p;",
      "}",
      "",
      "int merge(int x, int y) {",
      "\tassert(!par[x] && !par[y]);",
      "\tif (!x || !y) return max(x,y);",
      "\tif (pri[x] > pri[y]) {",
      "\t\tint X = dis(x,1);",
      "\t\tlink(x,1,merge(X,y));",
      "\t\treturn x;",
      "\t} else {",
      "\t\tint Y = dis(y,0);",
      "\t\tlink(y,0,merge(x,Y));",
      "\t\treturn y;",
      "\t}",
      "}",
      "",
      "// int getFirst(int x) {",
      "// \tif (!x) return 0;",
      "// \twhile (c[x][0]) x = c[x][0];",
      "// \treturn x;",
      "// }",
      "int makeFirst(int x) { // rotate ETT of x such that x is first",
      "\tassert(x); pi p = split(x);",
      "\treturn merge(p.s,p.f);",
      "}",
      "void remFirst(int x) { // remove first node of ETT rooted at x",
      "\tassert(x && !par[x]);",
      "\twhile (c[x][0]) x = c[x][0];",
      "\tint y = dis(x,1), p = par[x];",
      "\tif (p) dis(p,0), link(p,0,y);",
      "}",
      "",
      "// ETT OPERATIONS",
      "map<int,int> adj[MX];",
      "int makeEdge(int a, int b) {",
      "\tadj[a][b] = ++cnt; pri[cnt] = rng();",
      "\treturn cnt;",
      "}",
      "int reroot(int x) { // make edge beginning with x",
      "\tif (!sz(adj[x])) return 0;",
      "\treturn makeFirst(begin(adj[x])->s);",
      "}",
      "bool con(int a, int b) {",
      "\tif (!sz(adj[a]) || !sz(adj[b])) return 0;",
      "\ta = begin(adj[a])->s, b = begin(adj[b])->s;",
      "\treturn getRoot(a) == getRoot(b);",
      "}",
      "void add(int a, int b) { // connect A and B with edge",
      "\tint ta = reroot(a), tb = reroot(b); if (ta||tb) assert(ta != tb);",
      "\tint x = makeEdge(a,b), y = makeEdge(b,a); // make two nodes for new edge",
      "\tmerge(merge(ta,x),merge(tb,y));",
      "}",
      "void rem(int a, int b) {",
      "\tint x = adj[a][b], y = adj[b][a]; makeFirst(x);",
      "\tpi p = split(y); // assert(getFirst(p.f) == x && getFirst(p.s) == y);",
      "\tremFirst(p.f), remFirst(p.s);",
      "\tadj[a].erase(b), adj[b].erase(a);",
      "}",
      "",
      "int main() {",
      "\tint N,M; re(N,M);",
      "\tF0R(i,M) {",
      "\t\tstr s; int A,B; re(s,A,B);",
      "\t\tif (s == \"add\") {",
      "\t\t\tadd(A,B);",
      "\t\t} else if (s == \"rem\") {",
      "\t\t\trem(A,B);",
      "\t\t} else {",
      "\t\t\tif (con(A,B)) ps(\"YES\");",
      "\t\t\telse ps(\"NO\");",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "Euler Tour Tree using treap, each edge is,  * represented by two nodes. Supports reroot, insert edge, ,  * delete edge, get connected component. Can support,  * aggregate over vertices in connected component by ,  * introducing self-loops., * Time: O(\\log N), *"
  },
  "LeftistHeap": {
    "prefix":["benq_LeftistHeap"],
    "body": [
      "/**",
      " * Description: Persistent meldable heap.",
      " * Time: O(\\log N) per meld",
      " * Memory: O(\\log N) per meld",
      " * Source:",
      " \t* https://judge.yosupo.jp/submission/11843",
      " \t* https://en.wikipedia.org/wiki/Leftist_tree",
      " * Verification: See Kth Walk",
      " */",
      "",
      "typedef pair<ll,int> T;",
      "typedef struct heap* ph;",
      "struct heap { // min heap",
      "\tph l = NULL, r = NULL;",
      "\tint s = 0; T v; // s: path to leaf",
      "\theap(T _v):v(_v) {}",
      "};",
      "",
      "ph meld(ph p, ph q) {",
      "\tif (!p || !q) return p?:q;",
      "\tif (p->v > q->v) swap(p,q);",
      "\tph P = new heap(*p); P->r = meld(P->r,q);",
      "\tif (!P->l || P->l->s < P->r->s) swap(P->l,P->r);",
      "\tP->s = (P->r?P->r->s:0)+1; return P;",
      "}",
      "ph ins(ph p, T v) { return meld(p, new heap(v)); }",
      "ph pop(ph p) { return meld(p->l,p->r); }"
    ],
    "description": "Persistent meldable heap., * Time: O(\\log N) per meld, * Memory: O(\\log N) per meld, *"
  },
  "Treap": {
    "prefix":["benq_Treap"],
    "body": [
      "/**",
      " * Description: Easy BBST. Use split and merge to implement insert and delete.",
      " * Time: O(\\log N)",
      " * Source: https://cp-algorithms.com/data_structures/treap.html + others. Also consider",
      " \t* https://codeforces.com/contest/1340/submission/77861280 (no pointers -> faster)",
      " \t* https://codeforces.com/contest/1340/submission/77852254 (shared_ptr -> destroyed when nothing refers to it)",
      " * Verification: http://www.spoj.com/problems/ORDERSET/",
      " */",
      "",
      "typedef struct tnode* pt;",
      "struct tnode {",
      "\tint pri, val; pt c[2]; // essential",
      "\tint sz; ll sum; // for range queries",
      "\tbool flip = 0; // lazy update",
      "\ttnode (int _val) {",
      "\t\tpri = rng(); sum = val = _val; ",
      "\t\tsz = 1; c[0] = c[1] = NULL;",
      "\t}",
      "\t~tnode() { F0R(i,2) delete c[i]; } // assume no sharing of data",
      "};",
      "int getsz(pt x) { return x?x->sz:0; }",
      "ll getsum(pt x) { return x?x->sum:0; }",
      "pt prop(pt x) { // lazy propagation",
      "\tif (!x || !x->flip) return x;\t",
      "\tswap(x->c[0],x->c[1]);",
      "\tx->flip = 0; F0R(i,2) if (x->c[i]) x->c[i]->flip ^= 1;",
      "\treturn x;",
      "}",
      "pt calc(pt x) {",
      "\tpt a = x->c[0], b = x->c[1];",
      "\tassert(!x->flip); prop(a), prop(b);",
      "\tx->sz = 1+getsz(a)+getsz(b);",
      "\tx->sum = x->val+getsum(a)+getsum(b);",
      "\treturn x;",
      "}",
      "void tour(pt x, vi& v) { // print values of nodes, ",
      "\tif (!x) return; // inorder traversal",
      "\tprop(x); tour(x->c[0],v); v.pb(x->val); tour(x->c[1],v);",
      "}",
      "pair<pt,pt> split(pt t, int v) { // >= v goes to the right",
      "\tif (!t) return {t,t};",
      "\tprop(t);",
      "\tif (t->val >= v) {",
      "\t\tauto p = split(t->c[0], v); t->c[0] = p.s;",
      "\t\treturn {p.f,calc(t)};",
      "\t} else {",
      "\t\tauto p = split(t->c[1], v); t->c[1] = p.f;",
      "\t\treturn {calc(t),p.s};",
      "\t}",
      "}",
      "pair<pt,pt> splitsz(pt t, int sz) { // sz nodes go to left",
      "\tif (!t) return {t,t};",
      "\tprop(t);",
      "\tif (getsz(t->c[0]) >= sz) {",
      "\t\tauto p = splitsz(t->c[0],sz); t->c[0] = p.s;",
      "\t\treturn {p.f,calc(t)};",
      "\t} else {",
      "\t\tauto p=splitsz(t->c[1],sz-getsz(t->c[0])-1); t->c[1]=p.f;",
      "\t\treturn {calc(t),p.s};",
      "\t}",
      "}",
      "pt merge(pt l, pt r) { // merge treaps, keys in left < keys in right",
      "\tif (!l || !r) return l?:r;",
      "\tprop(l), prop(r); pt t;",
      "\tif (l->pri > r->pri) l->c[1] = merge(l->c[1],r), t = l;",
      "\telse r->c[0] = merge(l,r->c[0]), t = r;",
      "\treturn calc(t);",
      "}",
      "pt ins(pt x, int v) { // insert v",
      "\tauto a = split(x,v), b = split(a.s,v+1);",
      "\treturn merge(a.f,merge(new tnode(v),b.s)); }",
      "pt del(pt x, int v) { // delete v",
      "\tauto a = split(x,v), b = split(a.s,v+1);",
      "\treturn merge(a.f,b.s); }"
    ],
    "description": "Easy BBST. Use split and merge to implement insert and delete., * Time: O(\\log N), *"
  },
  "Hull3D": {
    "prefix":["benq_Hull3D"],
    "body": [
      "/**",
      " * Description: Incremental 3D convex hull where not all points ",
      " \t* are coplanar. Normals to returned faces point outwards. ",
      " \t* If coordinates are ints at most \\$B\\$ then \\texttt{T} ",
      " \t* should be large enough to support ints on the order ",
      " \t* of \\$B^3\\$.",
      " * Time: O(N^2), O(N\\log N)",
      " * Source: ",
      " \t* KACTL",
      " \t* https://codeforces.com/blog/entry/73366?#comment-575862 (mango_lassi)",
      " \t* https://codeforces.com/blog/entry/81768 (Monogon)",
      " \t* https://people.csail.mit.edu/indyk/6.838-old/handouts/lec10.pdf (presentation)",
      " \t* https://www2.cs.duke.edu/courses/spring07/cps296.2/papers/clarkson-shor.pdf",
      " * Verification: https://www.spoj.com/problems/CH3D/",
      " \t* https://code.google.com/codejam/contest/6314486/dashboard#s=p3",
      " */",
      "",
      "// using T = ll;",
      "T above(const P3&a,const P3&b,const P3&c,const P3&p) { ",
      "\treturn DC(a,b,c,p) > 0; } // is p strictly above plane",
      "void prep(vP3& p) { // rearrange points such that",
      "\tint num = 1; // first four are not coplanar",
      "\tFOR(i,1,sz(p)) ",
      "\t\tif (num == 1) {",
      "\t\t\tif (p[0] != p[i]) swap(p[1],p[i]), num ++;",
      "\t\t} else if (num == 2) {",
      "\t\t\tif (!collinear(p[0],p[1],p[i])) ",
      "\t\t\t\tswap(p[2],p[i]), num ++;",
      "\t\t} else if (num == 3) {",
      "\t\t\tif (!coplanar(p[0],p[1],p[2],p[i]))",
      "\t\t\t\tswap(p[3],p[i]), num ++;",
      "\t\t}",
      "\tassert(num == 4);",
      "}",
      "",
      "using F = AR<int,3>; // face",
      "V<F> hull3d(vP3& p) { // order of points is changed s.t. first four points form tetra",
      "\tprep(p); int N = sz(p); V<F> hull; // triangle for each face",
      "\tauto ad = [&](int a, int b, int c) { hull.pb({a,b,c}); }; // add a new face to hull",
      "\tad(0,1,2), ad(0,2,1); // initialize hull as first three points",
      "\tV<vb> in(N,vb(N)); // is zero before each iteration",
      "\tFOR(i,3,N) { // incremental construction",
      "\t\tV<F> def, HULL; swap(hull,HULL); // HULL now contains old hull",
      "\t\tauto ins = [&](int a, int b, int c) {",
      "\t\t\tif (in[b][a]) in[b][a] = 0; // kill reverse face",
      "\t\t\telse in[a][b] = 1, ad(a,b,c);",
      "\t\t};",
      "\t\teach(f,HULL) {",
      "\t\t\tif (above(p[f[0]],p[f[1]],p[f[2]],p[i]))  // recalc all faces such that point is above face",
      "\t\t\t\tF0R(j,3) ins(f[j],f[(j+1)%3],i);",
      "\t\t\telse def.pb(f); ",
      "\t\t}",
      "\t\teach(t,hull) if (in[t[0]][t[1]]) // edge is exposed, add a new face",
      "\t\t\tin[t[0]][t[1]] = 0, def.pb(t);",
      "\t\tswap(hull,def);",
      "\t}",
      "\treturn hull;",
      "}",
      "V<F> hull3dFast(vP3& p) { // order of points is changed s.t. first four points form tetra",
      "\tshuffle(all(p),rng); prep(p); int N = sz(p); V<F> hull; ",
      "\tvb active; V<vi> rvis; V<AR<pi,3>> other; // whether face is active",
      "\t// points visible from each face, other face adjacent to each edge of face",
      "\tV<vi> vis(N); // faces visible from each point",
      "\tauto ad = [&](int a, int b, int c) { ",
      "\t\thull.pb({a,b,c}); active.pb(1); rvis.eb(); other.eb(); };",
      "\tauto ae = [&](int a, int b) { vis[b].pb(a), rvis[a].pb(b); };",
      "\tauto abv = [&](int a, int b) {",
      "\t\tF f = hull[a]; return above(p[f[0]],p[f[1]],p[f[2]],p[b]); };",
      "\tauto edge = [&](pi e) -> pi { return {hull[e.f][e.s],hull[e.f][(e.s+1)%3]}; };",
      "\tauto glue = [&](pi a, pi b) { // link two faces by an edge",
      "\t\tpi x = edge(a); assert(edge(b) == mp(x.s,x.f));",
      "\t\tother[a.f][a.s] = b, other[b.f][b.s] = a;",
      "\t}; ",
      "\tad(0,1,2), ad(0,2,1); if (abv(1,3)) swap(p[1],p[2]); // ensure face 0 is removed when i=3",
      "\tF0R(i,3) glue({0,i},{1,2-i});",
      "\tFOR(i,3,N) ae(abv(1,i),i); // those that are coplanar go in rvis[0]",
      "\tvi label(N,-1);",
      "\tFOR(i,3,N) { // incremental construction",
      "\t\tvi rem; each(t,vis[i]) if (active[t]) active[t] = 0, rem.pb(t);",
      "\t\tif (!sz(rem)) continue; // hull unchanged",
      "\t\tint st = -1; ",
      "\t\teach(r,rem) F0R(j,3) {",
      "\t\t\tint o = other[r][j].f;",
      "\t\t\tif (active[o]) { // create new face!",
      "\t\t\t\tint a,b; tie(a,b) = edge({r,j}); ad(a,b,i); st = a;",
      "\t\t\t\tint cur = sz(rvis)-1; label[a] = cur; ",
      "\t\t\t\tvi tmp; set_union(all(rvis[r]),all(rvis[o]),back_inserter(tmp)); ",
      "\t\t\t\t// merge sorted vectors ignoring duplicates",
      "\t\t\t\teach(x,tmp) if (abv(cur,x)) ae(cur,x);",
      "\t\t\t\t// if no rounding errors then guaranteed that only x > i matters",
      "\t\t\t\tglue({cur,0},other[r][j]); // glue old face with new face",
      "\t\t\t}",
      "\t\t}",
      "\t\tfor (int x = st, y; ; x = y) { // glue new faces together",
      "\t\t\tint X = label[x]; glue({X,1},{label[y=hull[X][1]],2});",
      "\t\t\tif (y == st) break;",
      "\t\t}",
      "\t}",
      "\tV<F> ans; F0R(i,sz(hull)) if (active[i]) ans.pb(hull[i]);",
      "\treturn ans;",
      "}"
    ],
    "description": "Incremental 3D convex hull where not all points ,  * are coplanar. Normals to returned faces point outwards. ,  * If coordinates are ints at most \\$B\\$ then \\texttt{T} ,  * should be large enough to support ints on the order ,  * of \\$B^3\\$., * Time: O(N^2), O(N\\log N), *"
  },
  "Hull3D_kactl": {
    "prefix":["benq_Hull3D_kactl"],
    "body": [
      "/**",
      " * Description: 3D convex hull where no four points coplanar, polyedron volume",
      " * Time: O(N^2)",
      " * Source: KACTL",
      " * Verification: https://open.kattis.com/problems/starsinacan",
      " */",
      "",
      "#include \"Point3D.h\"",
      "",
      "struct ED {",
      "\tvoid ins(int x) { (a == -1 ? a : b) = x; }",
      "\tvoid rem(int x) { (a == x ? a : b) = -1; }",
      "\tint cnt() { return (a != -1)+(b != -1); }",
      "\tint a, b;",
      "};",
      "struct F { P3 q; int a, b, c; };",
      "",
      "vector<F> hull3d(const vP3& A) { ",
      "\tassert(sz(A) >= 4);",
      "\tvector<vector<ED>> E(sz(A), vector<ED>(sz(A), {-1, -1}));",
      "\t#define E(x,y) E[f.x][f.y]",
      "\tvector<F> FS; // faces",
      "\tauto mf = [&](int i, int j, int k, int l) { // make face",
      "\t\tP3 q = cross(A[j]-A[i],A[k]-A[i]);",
      "\t\tif (dot(q,A[l]) > dot(q,A[i])) q *= -1; // make sure q points outward",
      "\t\tF f{q, i, j, k};",
      "\t\tE(a,b).ins(k); E(a,c).ins(j); E(b,c).ins(i);",
      "\t\tFS.pb(f);",
      "\t};",
      "\tF0R(i,4) FOR(j,i+1,4) FOR(k,j+1,4) mf(i, j, k, 6-i-j-k);",
      "\tFOR(i,4,sz(A)) {",
      "\t\tF0R(j,sz(FS)) {",
      "\t\t\tF f = FS[j];",
      "\t\t\tif (dot(f.q,A[i]) > dot(f.q,A[f.a])) { // face is visible, remove edges",
      "\t\t\t\tE(a,b).rem(f.c), E(a,c).rem(f.b), E(b,c).rem(f.a);",
      "\t\t\t\tswap(FS[j--], FS.bk);",
      "\t\t\t\tFS.pop_back();",
      "\t\t\t}",
      "\t\t}",
      "\t\tF0R(j,sz(FS)) { // add faces with new point",
      "\t\t\tF f = FS[j];",
      "\t\t\t#define C(a, b, c) if (E(a,b).cnt() != 2) mf(f.a, f.b, i, f.c);",
      "\t\t\tC(a, b, c); C(a, c, b); C(b, c, a);",
      "\t\t}",
      "\t}",
      "\teach(it, FS) if (dot(cross(A[it.b]-A[it.a],A[it.c]-A[it.a]),it.q) <= 0) ",
      "\t\tswap(it.c, it.b);",
      "\treturn FS;",
      "} ",
      "",
      "T signedPolyVolume(const vP3& p, const vector<F>& trilist) {",
      "\tT v = 0;",
      "\teach(i,trilist) v += dot(cross(p[i.a],p[i.b]),p[i.c]);",
      "\treturn v/6;",
      "}"
    ],
    "description": "3D convex hull where no four points coplanar, polyedron volume, * Time: O(N^2), *"
  },
  "Point3D": {
    "prefix":["benq_Point3D"],
    "body": [
      "/**",
      " * Description: Basic 3D geometry. ",
      " * Source: Own",
      " * Verification: (haven't done much 3D geo yet)",
      "\t* AMPPZ 2011 Cross Spider",
      "\t* https://atcoder.jp/contests/JAG2013Spring/tasks/icpc2013spring_h",
      "\t* https://codeforces.com/gym/102040 - I",
      "\t* https://codeforces.com/gym/102452/problem/F",
      " */",
      "",
      "#include \"../Primitives/Point.h\"",
      "",
      "/**",
      "using T = ld;",
      "int sgn(T x) { return (x>0)-(x<0); }",
      "T sq(T x) { return x*x; }",
      "*/",
      "",
      "typedef array<T,3> P3;",
      "typedef array<P3,3> tri;",
      "typedef vector<P3> vP3;",
      "T norm(const P3& x) { ",
      "\tT sum = 0; F0R(i,3) sum += sq(x[i]);",
      "\treturn sum; }",
      "T abs(const P3& x) { return sqrt(norm(x)); }",
      "",
      "P3& operator+=(P3& l, const P3& r) { F0R(i,3) l[i] += r[i]; ",
      "\treturn l; }",
      "P3& operator-=(P3& l, const P3& r) { F0R(i,3) l[i] -= r[i]; ",
      "\treturn l; }",
      "P3& operator*=(P3& l, const T& r) { F0R(i,3) l[i] *= r; ",
      "\treturn l; }",
      "P3& operator/=(P3& l, const T& r) { F0R(i,3) l[i] /= r; ",
      "\treturn l; }",
      "P3 operator-(P3 l) { l *= -1; return l; }",
      "P3 operator+(P3 l, const P3& r) { return l += r; }",
      "P3 operator-(P3 l, const P3& r) { return l -= r; }",
      "P3 operator*(P3 l, const T& r) { return l *= r; }",
      "P3 operator*(const T& r, const P3& l) { return l*r; }",
      "P3 operator/(P3 l, const T& r) { return l /= r; }",
      "",
      "P3 unit(const P3& x) { return x/abs(x); }",
      "T dot(const P3& a, const P3& b) { ",
      "\tT sum = 0; F0R(i,3) sum += a[i]*b[i]; ",
      "\treturn sum; }",
      "P3 cross(const P3& a, const P3& b) {",
      "\treturn {a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],",
      "\t\t\ta[0]*b[1]-a[1]*b[0]}; }",
      "P3 cross(const P3& a, const P3& b, const P3& c) {",
      "\treturn cross(b-a,c-a); }",
      "P3 perp(const P3& a, const P3& b, const P3& c) {",
      "\treturn unit(cross(a,b,c)); }",
      "",
      "bool isMult(const P3& a, const P3& b) { // for long longs",
      "\tP3 c = cross(a,b); F0R(i,sz(c)) if (c[i] != 0) return 0; ",
      "\treturn 1; }",
      "bool collinear(const P3& a, const P3& b, const P3& c) { ",
      "\treturn isMult(b-a,c-a); }",
      "",
      "T DC(const P3&a,const P3&b,const P3&c,const P3&p) { ",
      "\treturn dot(cross(a,b,c),p-a); }",
      "bool coplanar(const P3&a,const P3&b,const P3&c,const P3&p) { ",
      "\treturn DC(a,b,c,p) == 0; }",
      "bool op(const P3& a, const P3& b) { ",
      "\tint ind = 0; // going in opposite directions?",
      "\tFOR(i,1,3) if (std::abs(a[i]*b[i])>std::abs(a[ind]*b[ind])) ",
      "\t\tind = i;",
      "\treturn a[ind]*b[ind] < 0;",
      "}",
      "// coplanar points, b0 and b1 on opposite sides of a0-a1?",
      "bool opSide(const P3&a,const P3&b,const P3&c,const P3&d) { ",
      "\treturn op(cross(a,b,c),cross(a,b,d)); }",
      "// coplanar points, is a in triangle b",
      "bool inTri(const P3& a, const tri& b) { ",
      "\tF0R(i,3)if(opSide(b[i],b[(i+1)%3],b[(i+2)%3],a))return 0;",
      "\treturn 1; }",
      "",
      "// point-seg dist",
      "T psDist(const P3&p,const P3&a,const P3&b) { ",
      "\tif (dot(a-p,a-b) <= 0) return abs(a-p);",
      "\tif (dot(b-p,b-a) <= 0) return abs(b-p);",
      "\treturn abs(cross(p,a,b))/abs(a-b);",
      "}",
      "// projection onto line",
      "P3 foot(const P3& p, const P3& a, const P3& b) { ",
      "\tP3 d = unit(b-a); return a+dot(p-a,d)*d; }",
      "// rotate p about axis",
      "P3 rotAxis(const P3& p, const P3& a, const P3& b, T theta) {",
      "\tP3 dz = unit(b-a), f = foot(p,a,b); ",
      "\tP3 dx = p-f, dy = cross(dz,dx);",
      "\treturn f+cos(theta)*dx+sin(theta)*dy;",
      "}",
      "// projection onto plane",
      "P3 foot(const P3& a, const tri& b) {",
      "\tP3 c = perp(b[0],b[1],b[2]);",
      "\treturn a-c*(dot(a,c)-dot(b[0],c)); }",
      "// line-plane intersection",
      "P3 lpIntersect(const P3&a0,const P3&a1,const tri&b) { ",
      "\tP3 c = unit(cross(b[2]-b[0],b[1]-b[0]));",
      "\tT x = dot(a0,c)-dot(b[0],c), y = dot(a1,c)-dot(b[0],c);",
      "\treturn (y*a0-x*a1)/(y-x);",
      "}"
    ],
    "description": "Basic 3D geometry. , *"
  },
  "PolySaVol": {
    "prefix":["benq_PolySaVol"],
    "body": [
      "/**",
      " * Description: surface area and volume of polyhedron,",
      " \t* normals to faces must point outwards",
      " * Source: KACTL",
      " * Verification: See Hull3D",
      " */",
      "",
      "#include \"Hull3D.h\"",
      "",
      "pair<T,T> SaVol(vP3 p, V<F> faces) {",
      "\tT s = 0, v = 0; ",
      "\teach(i,faces) {",
      "\t\tP3 a = p[i[0]], b = p[i[1]], c = p[i[2]];",
      "\t\ts += abs(cross(a,b,c)); v += dot(cross(a,b),c);",
      "\t}",
      "\treturn {s/2,v/6};",
      "}"
    ],
    "description": "surface area and volume of polyhedron,,  * normals to faces must point outwards, *"
  },
  "Quater": {
    "prefix":["benq_Quater"],
    "body": [
      "/**",
      " * Description: Operations on quaternions, useful for totations in 3D",
      " * Source: https://codeforces.com/blog/entry/46744",
      " * Verification:",
      " \t* https://codeforces.com/gym/102354/problem/F",
      "\t* https://codeforces.com/contest/1375/problem/I",
      " */",
      "",
      "using T = ld; const T EPS = 1e-9;",
      "int sgn(T x) { return (x>0)-(x<0); }",
      "T sq(T x) { return x*x; }",
      " ",
      "/////// DEFINING QUATER",
      "using Q = array<T,4>; using vQ = vector<Q>; // represent quater as (x,y,z,s)",
      "Q vec(T x, T y, T z) { return {x,y,z,0}; } // vector to quater",
      "Q vec(Q a) { a[3] = 0; return a; } // quater to vector",
      "void isVec(const Q& q) { assert(q[3] == 0); } // assert that quater is vector",
      "const Q ex = vec(1,0,0), ey = vec(0,1,0), ez = vec(0,0,1); // unit vectors for each of three axes",
      "Q conj(Q x) { F0R(i,3) x[i] *= -1; // conjugate",
      "\treturn x; }",
      "Q ortho(const Q& x) { isVec(x); // return any nonzero vector perpendicular to q",
      "\treturn abs(x[1]) > EPS ? vec(x[1],-x[0],0) : vec(x[2],0,-x[0]); }",
      "Q vrand() { // random vector",
      "\tQ q = Q(); F0R(i,3) q[i] = rng()%(2*MOD)-MOD;",
      "\treturn q; }",
      "T norm(const Q& x) { // sum of squares",
      "\tT sum = 0; each(t,x) sum += t*t;",
      "\treturn sum; }",
      "T abs(const Q& x) { return sqrt(norm(x)); }",
      "",
      "/////// BASIC ARITHMETIC",
      "Q& operator+=(Q& l, const Q& r) { F0R(i,4) l[i] += r[i]; ",
      "\treturn l; }",
      "Q& operator-=(Q& l, const Q& r) { F0R(i,4) l[i] -= r[i]; ",
      "\treturn l; }",
      "Q& operator*=(Q& l, const T& r) { F0R(i,4) l[i] *= r; ",
      "\treturn l; }",
      "Q& operator/=(Q& l, const T& r) { F0R(i,4) l[i] /= r; ",
      "\treturn l; }",
      "Q operator-(Q l) { return l *= -1; }",
      "Q operator+(Q l, const Q& r) { return l += r; }",
      "Q operator-(Q l, const Q& r) { return l -= r; }",
      "Q operator*(Q l, const T& r) { return l *= r; }",
      "Q operator*(const T& r, const Q& l) { return l*r; }",
      "Q operator/(Q l, const T& r) { return l /= r; }",
      "Q unit(Q x) { return x/abs(x); }",
      "Q inv(const Q& x) { return conj(x)/norm(x); }",
      "bool eq(Q a, Q b) { return abs(a-b) < EPS; }",
      "",
      "Q operator*(const Q& x, const Q& y) { Q z = Q(); // multiply quaters",
      "\tF0R(i,4) F0R(j,4) // i=3 or j=3 -> multiplying by constant, just add product",
      "\t\tz[i^j^3] += ((i==3||j==3||(i+1)%3 == j)?1:-1)*x[i]*y[j];",
      "\treturn z; }",
      "Q operator/(const Q& l, const Q& r) { return l*inv(r); }",
      "Q& operator*=(Q& l, const Q& r) { return l = l*r; }",
      "Q& operator/=(Q& l, const Q& r) { return l = l/r; }",
      "",
      "T dot(const Q& l, const Q& r) { isVec(l), isVec(r); // dot product of vectors",
      "\tT res = 0; F0R(i,3) res += l[i]*r[i];",
      "\treturn res; }",
      "Q cross(const Q& l, const Q& r) { isVec(l), isVec(r); // cross product of vectors",
      "\treturn vec(l*r); }",
      "T mix(const Q& a, const Q& b, const Q& c) { isVec(a), isVec(b), isVec(c);",
      "\treturn dot(a,cross(b,c)); } // mixed product",
      "",
      "// rotating phi about axis i -> rotation quater is in the form rot=cos(phi/2)+i*sin(phi/2)",
      "Q rotate(const Q& rot, const Q& x) { isVec(x); ",
      "\treturn vec(rot*x/rot); } // rot doesn't have to be normalized",
      "Q minRotation(const Q& a, const Q& b) { isVec(a), isVec(b); // min rotation from a to b",
      "\treturn eq(a,-b) ? ortho(b) : (a+b)*a; } // if a == -b then infinitely many possible ...",
      "T getAngle(const Q& a) { return remainder(2*acos(a[3]/abs(a)),2*PI); }  // get phi",
      "Q basisRotation(const Q& a, const Q& b) { isVec(a), isVec(b); // bring ex to a and ey to b",
      "\tQ ra = minRotation(ex,a); Q EY = rotate(ra,ey); // first rotate ex to a",
      "\tQ rb = eq(EY,-b) ? a : minRotation(EY,b); // then rotate ey to b",
      "\treturn rb*ra; }",
      "Q basisRotation(const Q& a, const Q& b, const Q& A, const Q& B) { // rotation that brings a to A and b to B",
      "\treturn basisRotation(A,B)/basisRotation(a,b); } // a -> ex -> A, b -> ey -> B",
      "",
      "/////// EIGENBASIS of positive semidefinite matrix, use for PCA",
      "// eigenvectors for different eigenvalues are orthogonal",
      "// https://en.wikipedia.org/wiki/Definite_symmetric_matrix",
      "// https://en.wikipedia.org/wiki/Principal_component_analysis",
      "typedef array<array<T,3>,3> Mat;",
      "Q operator*(const Mat& l, const Q& r) { isVec(r); // multiply matrix by vector",
      "\tQ res = Q(); F0R(i,3) F0R(j,3) res[i] += l[i][j]*r[j];",
      "\treturn res; }",
      "Q flatten(const vQ& basis, Q x) { isVec(x); // reduce x given orthonormal basis",
      "\teach(t,basis) x -= t*dot(t,x);",
      "\treturn unit(x); }",
      "Q findEigenvec(const vQ& basis, const Mat& A) { // if we keep applying it will converge to vector corresponding to largest eigenvalue",
      "\tQ x = flatten(basis,vrand());",
      "\tF0R(_,1e5) {",
      "\t\tQ X = A*x; if (abs(X) < EPS) return x; // eigenvalue 0?",
      "\t\tx = flatten(basis,X);",
      "\t}",
      "\treturn x;",
      "}",
      "vQ eigenBasis(const Mat& A) { ",
      "\tvQ basis; F0R(z,3) basis.pb(findEigenvec(basis,A));",
      "\treturn basis; }",
      "",
      "/////// GCD of Hurwitz Quaternions",
      "// https://en.wikipedia.org/wiki/Hurwitz_quaternion",
      "// all coordinates are integer or all coordinates are half-integer",
      "// multiples of Hurwitz quater a are in the form a*v",
      "Q round(const Q& q) { Q a, b; // get closest Hurwitz quaternion",
      "\tF0R(i,4) a[i] = round(q[i]); // try int",
      "\tF0R(i,4) b[i] = round(q[i]-0.5)+0.5; // and half-int",
      "\treturn norm(a-q) < norm(b-q) ? a : b; }",
      "Q operator%(const Q& a, const Q& b) { return a-b*round(inv(b)*a); }",
      "Q gcd(Q a, Q b) { if (norm(a) > norm(b)) swap(a,b);",
      "\treturn norm(a) == 0 ? b : gcd(b%a,a); }"
    ],
    "description": "Operations on quaternions, useful for totations in 3D, *"
  },
  "Circle": {
    "prefix":["benq_Circle"],
    "body": [
      "/**",
      " * Description: represent circle as \\{center,radius\\}",
      " * Source: Own",
      " * Verification: see circle intersection",
      " */",
      "",
      "#include \"../Primitives/Point.h\"",
      "",
      "using Circ = pair<P,T>;",
      "int in(const Circ& x, const P& y) { // -1 if inside, 0, 1",
      "\treturn sgn(abs(y-x.f)-x.s); }",
      "T arc_length(const Circ& x, P a, P b) { // precondition: a and b on x",
      "\tP d = (a-x.f)/(b-x.f); return x.s*acos(d.f); }"
    ],
    "description": "represent circle as \\{center,radius\\}, *"
  },
  "CircleIsect": {
    "prefix":["benq_CircleIsect"],
    "body": [
      "/**",
      " * Description: Circle intersection points and intersection area. ",
      " \t* Tangents will be returned twice.",
      " * Source: Own",
      "\t* also see http://mathworld.wolfram.com/Circle-CircleIntersection.html",
      " * Verification:https://codefights.com/tournaments/s8thqrnQL2YPK7XQt/L",
      " */",
      "",
      "#include \"Circle.h\"",
      "",
      "vP isect(const Circ& x, const Circ& y) { // precondition: x != y",
      "\tT d = abs(x.f-y.f), a = x.s, b = y.s; ",
      "\tif (sgn(d) == 0) { assert(a != b); return {}; }",
      "\tT C = (a*a+d*d-b*b)/(2*a*d); ",
      "\tif (abs(C) > 1+EPS) return {};",
      "\tT S = sqrt(max(1-C*C,(T)0)); P tmp = (y.f-x.f)/d*x.s;",
      "\treturn {x.f+tmp*P(C,S),x.f+tmp*P(C,-S)};",
      "}",
      "vP isect(const Circ& x, const Line& y) {",
      "\tP c = foot(x.f,y); T sq_dist = sq(x.s)-norm(x.f-c);",
      "\tif (sgn(sq_dist) < 0) return {};",
      "\tP offset = unit(y.s-y.f)*sqrt(max(sq_dist,T(0)));",
      "\treturn {c+offset,c-offset};",
      "}",
      "T isect_area(Circ x, Circ y) { // not thoroughly tested",
      "\tT d = abs(x.f-y.f), a = x.s, b = y.s; if (a < b) swap(a,b);",
      "\tif (d >= a+b) return 0;",
      "\tif (d <= a-b) return PI*b*b;",
      "\tT ca = (a*a+d*d-b*b)/(2*a*d), cb = (b*b+d*d-a*a)/(2*b*d);",
      "\tT s = (a+b+d)/2, h = 2*sqrt(s*(s-a)*(s-b)*(s-d))/d;",
      "\treturn a*a*acos(ca)+b*b*acos(cb)-d*h;",
      "}"
    ],
    "description": "Circle intersection points and intersection area. ,  * Tangents will be returned twice., *"
  },
  "CircleTangents": {
    "prefix":["benq_CircleTangents"],
    "body": [
      " /**",
      " * Description: internal and external tangents between two circles",
      " * Source: Own",
      " * Verification: USACO Laser Cows",
      " */",
      "",
      "#include \"Circle.h\"",
      "",
      "P tangent(P x, Circ y, int t = 0) {",
      "\ty.s = abs(y.s); // abs needed because internal calls y.s < 0",
      "\tif (y.s == 0) return y.f;",
      "\tT d = abs(x-y.f);",
      "\tP a = pow(y.s/d,2)*(x-y.f)+y.f;",
      "\tP b = sqrt(d*d-y.s*y.s)/d*y.s*unit(x-y.f)*dir(PI/2); ",
      "\treturn t == 0 ? a+b : a-b;",
      "}",
      "V<pair<P,P>> external(Circ x, Circ y) { ",
      "\tV<pair<P,P>> v; ",
      "\tif (x.s == y.s) {",
      "\t\tP tmp = unit(x.f-y.f)*x.s*dir(PI/2);",
      "\t\tv.eb(x.f+tmp,y.f+tmp);",
      "\t\tv.eb(x.f-tmp,y.f-tmp);",
      "\t} else {",
      "\t\tP p = (y.s*x.f-x.s*y.f)/(y.s-x.s);",
      "\t\tF0R(i,2) v.eb(tangent(p,x,i),tangent(p,y,i));",
      "\t}",
      "\treturn v;",
      "}",
      "V<pair<P,P>> internal(Circ x, Circ y) { ",
      "\treturn external({x.f,-x.s},y); }"
    ],
    "description": "internal and external tangents between two circles, *"
  },
  "Circumcenter": {
    "prefix":["benq_Circumcenter"],
    "body": [
      "/**",
      " * Description: returns \\{circumcenter,circumradius\\}",
      " * Source: EGMO",
      " * Verification: see MEC",
      " */",
      "",
      "#include \"Circle.h\"",
      "",
      "circ ccCenter(P a, P b, P c) { ",
      "\tb -= a; c -= a;",
      "\tP res = b*c*(conj(c)-conj(b))/(b*conj(c)-conj(b)*c);",
      "\treturn {a+res,abs(res)};",
      "}"
    ],
    "description": "returns \\{circumcenter,circumradius\\}, *"
  },
  "MinEnclosingCirc": {
    "prefix":["benq_MinEnclosingCirc"],
    "body": [
      "/**",
      " * Description: minimum enclosing circle",
      " * Time: expected \\$O(N)\\$",
      " * Source: KACTL",
      " * Verification: USACO Camp 2019 Contest 2 #4",
      " */",
      "",
      "#include \"Circumcenter.h\"",
      "",
      "circ mec(vP ps) {",
      "\tshuffle(all(ps), rng);",
      "\tP o = ps[0]; T r = 0, EPS = 1+1e-8;",
      "\tF0R(i,sz(ps)) if (abs(o-ps[i]) > r*EPS) {",
      "\t\to = ps[i], r = 0; // point is on MEC",
      "\t\tF0R(j,i) if (abs(o-ps[j]) > r*EPS) {",
      "\t\t\to = (ps[i]+ps[j])/2, r = abs(o-ps[i]);",
      "\t\t\tF0R(k,j) if (abs(o-ps[k]) > r*EPS) ",
      "\t\t\t\ttie(o,r) = ccCenter(ps[i],ps[j],ps[k]);",
      "\t\t}",
      "\t}",
      "\treturn {o,r};",
      "}"
    ],
    "description": "minimum enclosing circle, * Time: expected \\$O(N)\\$, *"
  },
  "ClosestPair": {
    "prefix":["benq_ClosestPair"],
    "body": [
      "/**",
      " * Description: line sweep to find two closest points ",
      " * Time: O(N\\log N)",
      " * Source: Own",
      " * Verification: https://open.kattis.com/problems/closestpair2",
      " */",
      "",
      "#include \"../Primitives/Point.h\"",
      "",
      "pair<P,P> solve(vP v) {",
      "\tpair<ld,pair<P,P>> bes; bes.f = INF;",
      "\tset<P> S; int ind = 0;",
      "\tsort(all(v));",
      "\tF0R(i,sz(v)) {",
      "\t\tif (i && v[i] == v[i-1]) return {v[i],v[i]};",
      "\t\tfor (; v[i].f-v[ind].f >= bes.f; ++ind) ",
      "\t\t\tS.erase({v[ind].s,v[ind].f});",
      "\t\tfor (auto it = S.ub({v[i].s-bes.f,INF});",
      "\t\t\tit != end(S) && it->f < v[i].s+bes.f; ++it) {",
      "\t\t\tP t = {it->s,it->f};",
      "\t\t\tckmin(bes,{abs(t-v[i]),{t,v[i]}});",
      "\t\t}",
      "\t\tS.insert({v[i].s,v[i].f});",
      "\t}",
      "\treturn bes.s;",
      "}"
    ],
    "description": "line sweep to find two closest points , * Time: O(N\\log N), *"
  },
  "Delaunay3": {
    "prefix":["benq_Delaunay3"],
    "body": [
      "/**",
      " * Description: Delaunay triangulation with 3D hull. ",
      " \t* Fails when all points collinear.",
      " * Source: KACTL",
      " * Verification: https://dmoj.ca/problem/cco08p6",
      " */",
      "",
      "#include \"../Primitives/Point.h\"",
      "#include \"Hull3D.h\"",
      "#include \"AngleCmp.h\"",
      "",
      "V<AR<P,3>> triHull(vP p) {",
      "\tV<P3> p3; V<AR<P,3>> res; each(x,p) p3.pb({x.f,x.s,norm(x)});",
      "\tbool ok = 0; each(t,p3) if (!coplanar(p3[0],p3[1],p3[2],t)) ok = 1;",
      "\tif (!ok) { // all points concyclic",
      "\t\tsort(1+all(p),[&p](P a, P b) { return cross(a-p[0],b-p[0]) > 0; });",
      "\t\tFOR(i,1,sz(p)-1) res.pb({p[0],p[i],p[i+1]});",
      "\t} else {",
      "\t\t#define nor(x) P(p3[x][0],p3[x][1])",
      "\t\teach(t,hull3dFast(p3)) ",
      "\t\t\tif (dot(cross(p3[t[0]],p3[t[1]],p3[t[2]]),{0,0,1}) < 0)",
      "\t\t\t\tres.pb({nor(t[0]),nor(t[2]),nor(t[1])});",
      "\t}",
      "\treturn res;",
      "}"
    ],
    "description": "Delaunay triangulation with 3D hull. ,  * Fails when all points collinear., *"
  },
  "DelaunayFast": {
    "prefix":["benq_DelaunayFast"],
    "body": [
      "/**",
      " * Description: Fast Delaunay triangulation assuming no duplicates and not ",
      " \t* all points collinear (in latter case, result will be empty). Should ",
      " \t* work for doubles as well, though there may be precision issues in 'circ'.",
      "\t* Returns triangles in ccw order. Each circumcircle will contain none ",
      "\t* of the input points. If coordinates are ints at most \\$B\\$ then \\texttt{T} ",
      "\t* should be large enough to support ints on the order of \\$B^4\\$.",
      " * Time: O(N\\log N)",
      " * Source: KACTL",
      " * Verification: https://dmoj.ca/problem/cco08p6",
      " */",
      "",
      "#include \"../Primitives/Point.h\"",
      "",
      "// using T = ll;",
      "using lll = __int128; // (can be ll if coords are < 2e4)",
      "bool inCircle(P p, P a, P b, P c) {",
      "\ta -= p, b -= p, c -= p; // assert(cross(a,b,c)>0);",
      "\tlll x = (lll)norm(a)*cross(b,c)+(lll)norm(b)*cross(c,a)",
      "\t\t\t+(lll)norm(c)*cross(a,b);",
      "\treturn x*(cross(a,b,c)>0?1:-1) > 0;",
      "}",
      "",
      "P arb(LLONG_MAX,LLONG_MAX); // not equal to any other point",
      "typedef struct Quad* Q;",
      "struct Quad {",
      "\tbool mark; Q o, rot; P p;",
      "\tP F() { return r()->p; }",
      "\tQ r() { return rot->rot; }",
      "\tQ prev() { return rot->o->rot; }",
      "\tQ next() { return r()->prev(); }",
      "};",
      "Q makeEdge(P orig, P dest) {",
      "\tQ q[] = {new Quad{0,0,0,orig}, new Quad{0,0,0,arb},",
      "\t\t\t new Quad{0,0,0,dest}, new Quad{0,0,0,arb}};",
      "\tF0R(i,4) q[i]->o = q[-i & 3], q[i]->rot = q[(i+1) & 3];",
      "\treturn *q;",
      "}",
      "void splice(Q a, Q b) { swap(a->o->rot->o, b->o->rot->o); swap(a->o, b->o); }",
      "Q connect(Q a, Q b) {",
      "\tQ q = makeEdge(a->F(), b->p);",
      "\tsplice(q, a->next()); splice(q->r(), b);",
      "\treturn q;",
      "}",
      "pair<Q,Q> rec(const vP& s) {",
      "\tif (sz(s) <= 3) {",
      "\t\tQ a = makeEdge(s[0], s[1]), b = makeEdge(s[1], s.bk);",
      "\t\tif (sz(s) == 2) return { a, a->r() };",
      "\t\tsplice(a->r(), b);",
      "\t\tauto side = cross(s[0], s[1], s[2]);",
      "\t\tQ c = side ? connect(b, a) : 0;",
      "\t\treturn {side < 0 ? c->r() : a, side < 0 ? c : b->r() };",
      "\t}",
      "",
      "#define H(e) e->F(), e->p",
      "#define valid(e) (cross(e->F(),H(base)) > 0)",
      "\tQ A, B, ra, rb;",
      "\tint half = sz(s) / 2;",
      "\ttie(ra, A) = rec({all(s)-half});",
      "\ttie(B, rb) = rec({sz(s)-half+all(s)});",
      "\twhile ((cross(B->p,H(A)) < 0 && (A = A->next())) ||",
      "\t\t   (cross(A->p,H(B)) > 0 && (B = B->r()->o)));",
      "\tQ base = connect(B->r(), A);",
      "\tif (A->p == ra->p) ra = base->r();",
      "\tif (B->p == rb->p) rb = base;",
      "",
      "#define DEL(e, init, dir) Q e = init->dir; if (valid(e)) \\",
      "\t\twhile (inCircle(e->dir->F(), H(base), e->F())) { \\",
      "\t\t\tQ t = e->dir; \\",
      "\t\t\tsplice(e, e->prev()); \\",
      "\t\t\tsplice(e->r(), e->r()->prev()); \\",
      "\t\t\te = t; \\",
      "\t\t}",
      "\twhile (1) {",
      "\t\tDEL(LC, base->r(), o);\tDEL(RC, base, prev());",
      "\t\tif (!valid(LC) && !valid(RC)) break;",
      "\t\tif (!valid(LC) || (valid(RC) && inCircle(H(RC), H(LC))))",
      "\t\t\tbase = connect(RC, base->r());",
      "\t\telse base = connect(base->r(), LC->r());",
      "\t}",
      "\treturn {ra, rb};",
      "}",
      "vector<array<P,3>> triangulate(vP pts) {",
      "\tsort(all(pts)); assert(unique(all(pts)) == end(pts)); // no duplicates",
      "\tif (sz(pts) < 2) return {};",
      "\tQ e = rec(pts).f; vector<Q> q = {e};",
      "\twhile (cross(e->o->F(), e->F(), e->p) < 0) e = e->o;",
      "#define ADD { Q c = e; do { c->mark = 1; pts.pb(c->p); \\",
      "\tq.pb(c->r()); c = c->next(); } while (c != e); }",
      "\tADD; pts.clear();",
      "\tint qi = 0; while (qi < sz(q)) if (!(e = q[qi++])->mark) ADD;",
      "\tvector<array<P,3>> ret(sz(pts)/3); ",
      "\tF0R(i,sz(pts)) ret[i/3][i%3] = pts[i];",
      "\treturn ret;",
      "}"
    ],
    "description": "Fast Delaunay triangulation assuming no duplicates and not ,  * all points collinear (in latter case, result will be empty). Should ,  * work for doubles as well, though there may be precision issues in 'circ'., * Returns triangles in ccw order. Each circumcircle will contain none , * of the input points. If coordinates are ints at most \\$B\\$ then \\texttt{T} , * should be large enough to support ints on the order of \\$B^4\\$., * Time: O(N\\log N), *"
  },
  "DelaunayIncremental": {
    "prefix":["benq_DelaunayIncremental"],
    "body": [
      "/**",
      " * Description: Bowyer-Watson where not all points collinear. ",
      " \t* Works for \\$|x|,|y|\\le 10^4,\\$ assuming that all circumradii ",
      " \t* in final triangulation are \\$\\ll 10^9.\\$",
      " * Time: O(N^2\\log N)",
      " * Source: Own",
      " * Verification: ",
      "\t* ICPC WF 2018 Panda Preserve",
      "\t* https://dmoj.ca/problem/cco08p6 (32/37)",
      " */",
      "",
      "#include \"DelaunayFast.h\"",
      "",
      "const T BIG = 1e9; // >>(10^4)^2",
      "vector<array<int,3>> triIncrement(vP v) {",
      "\tv.pb({-BIG,-BIG}); v.pb({BIG,0}); v.pb({0,BIG});",
      "\tvector<array<int,3>> ret, tmp;",
      "\tret.pb({sz(v)-3,sz(v)-2,sz(v)-1});",
      "\tF0R(i,sz(v)-3) {",
      "\t\tmap<pi,int> m; ",
      "\t\teach(a,ret) {",
      "\t\t\tif (inCircle(v[i],v[a[0]],v[a[1]],v[a[2]]))",
      "\t\t\t\tm[{a[0],a[1]}]++, m[{a[1],a[2]}]++, m[{a[0],a[2]}]++;",
      "\t\t\telse tmp.pb(a);",
      "\t\t}",
      "\t\teach(a,m) if (a.s == 1) {",
      "\t\t\tarray<int,3> x = {a.f.f,a.f.s,i}; ",
      "\t\t\tsort(all(x)); tmp.pb(x);",
      "\t\t}",
      "\t\tswap(ret,tmp); tmp.clear();",
      "\t}",
      "\teach(a,ret) if (a[2] < sz(v)-3) tmp.pb(a);",
      "\treturn tmp;",
      "}",
      "/**void printAsy(vP x) { // produces asymptote code",
      "\tps(\"[asy]\");",
      "\tps(\"pair[] A = {\");",
      "\tF0R(i,sz(x)) {",
      "\t\tif (i) pr(\",\");",
      "\t\tpr(x[i]); ",
      "\t}",
      "\tps(\"};\");",
      "\tps(\"for (int i = 0; i < \",sz(x),\"; ++i) {\\n\\tdot(A[i]);\\n}\");",
      "\teach(b,triangulate(x)) ",
      "\t\tps(\"draw(A[\",b[0],\"]--A[\",b[1],\"]--A[\",b[2],\"]--cycle);\");",
      "\tps(\"[/asy]\");",
      "}*/"
    ],
    "description": "Bowyer-Watson where not all points collinear. ,  * Works for \\$|x|,|y|\\le 10^4,\\$ assuming that all circumradii ,  * in final triangulation are \\$\\ll 10^9.\\$, * Time: O(N^2\\log N), *"
  },
  "KDtree": {
    "prefix":["benq_KDtree"],
    "body": [
      "/**",
      " * Description: nearest neighbor to point and squared dist",
      " * Time: Assume points are distributed uniformly at random. ",
      " \t* Insertion and find nearest neighbor are \\$O(\\log N)\\$,",
      " \t* rectangle queries are \\$O(N^{1-1/D})\\$ on average.",
      " * Source: KACTL, Stanford",
      " \t* https://en.wikipedia.org/wiki/K-d_tree",
      " \t* https://www.cise.ufl.edu/class/cot5520sp15/CG_RangeKDtrees.pdf",
      " \t* https://arxiv.org/pdf/1903.04936.pdf",
      " * Verification: ",
      " \t* https://open.kattis.com/problems/closestpair1",
      " \t* https://dmoj.ca/problem/wac5p7",
      " */",
      "",
      "static const int D = 2; using P = array<int,D>;",
      "const array<pi,D> ID{pi{-1e7,1e7},pi{-1e7,1e7}};",
      "",
      "struct KDTree {",
      "\tint root = -1; vector<P> pos; vector<array<int,2>> chi;",
      "\tll sq(ll x) { return x*x; }",
      "\tll dist(const P& a, const P& b) { ",
      "\t\tll d = 0; F0R(i,D) d += sq(a[i]-b[i]);",
      "\t\treturn d; }",
      "\tll minDist(const array<pi,D>& b, const P& loc) { ",
      "\t\tll d = 0; F0R(i,2) d += sq(loc[i]-max(min(loc[i],b[i].s),b[i].f));",
      "\t\treturn d; }",
      "\tpair<ll,int> query(int cur, int side, const array<pi,D>& b, const P& loc, pair<ll,int> ans) {",
      "\t\tif (cur == -1 || minDist(b,loc) >= ans.f) return ans;",
      "\t\tif (ckmin(ans.f,dist(pos[cur],loc))) ans.s = cur;",
      "\t\tarray<array<pi,D>,2> B = {b,b};",
      "\t\tB[0][side].s = pos[cur][side]; B[1][side].f = pos[cur][side];",
      "\t\tvl ret(2); F0R(i,2) ret[i] = minDist(B[i],loc);",
      "\t\tint ind = 0; if (ret[1] < ret[0]) ind = 1;",
      "\t\tans = query(chi[cur][ind],side^1,B[ind],loc,ans);",
      "\t\tind ^= 1; ans = query(chi[cur][ind],side^1,B[ind],loc,ans);",
      "\t\treturn ans;",
      "\t}",
      "\tvoid ins(int& cur, int side, int nex) {",
      "\t\tif (cur == -1) cur = nex;",
      "\t\telse ins(chi[cur][pos[nex][side] > pos[cur][side]],side^1,nex);",
      "\t}",
      "\tpair<ll,int> query(P p) { return query(root,0,ID,p,{INF,-1}); }",
      "\tint add(P p) {",
      "\t\tpos.pb(p); chi.pb({-1,-1});",
      "\t\tint ind = sz(pos)-1; ins(root,0,ind); return ind;",
      "\t}",
      "};"
    ],
    "description": "nearest neighbor to point and squared dist, * Time: Assume points are distributed uniformly at random. ,  * Insertion and find nearest neighbor are \\$O(\\log N)\\$,,  * rectangle queries are \\$O(N^{1-1/D})\\$ on average., *"
  },
  "ManhattanMST": {
    "prefix":["benq_ManhattanMST"],
    "body": [
      "/**",
      " * Description: Given \\$N\\$ points, returns up to \\$4N\\$ edges which are guaranteed",
      "\t* to contain a MST for graph with edge weights \\$w(p,q) =|p.x-q.x|+|p.y-q.y|.\\$ ",
      "\t* Edges are in the form \\texttt{\\{dist, \\{src, dst\\}\\}}. ",
      " * Time: O(N\\log N)",
      " * Source: KACTL",
      " \t* https://github.com/spaghetti-source/algorithm/blob/master/geometry/rectilinear_mst.cc",
      " * Verification: https://open.kattis.com/problems/gridmst",
      " */",
      "",
      "#include \"DSU (7.6).h\"",
      "",
      "// Use standard MST algorithm on the result to find the final MST.",
      "vector<pair<int,pi>> manhattanMst(vpi v) {",
      "\tvi id(sz(v)); iota(all(id),0);",
      "\tvector<pair<int,pi>> ed;",
      "\tF0R(k,4) {",
      "\t\tsort(all(id),[&](int i, int j) { ",
      "\t\t\treturn v[i].f+v[i].s < v[j].f+v[j].s; });",
      "\t\tmap<int,int> sweep; // find first octant neighbors",
      "\t\teach(i,id) { // those in sweep haven't found neighbor yet",
      "\t\t\tfor (auto it = sweep.lb(-v[i].s); ",
      "\t\t\t\tit != end(sweep); sweep.erase(it++)) {",
      "\t\t\t\tint j = it->s;",
      "\t\t\t\tpi d{v[i].f-v[j].f,v[i].s-v[j].s};if (d.s>d.f)break;",
      "\t\t\t\ted.pb({d.f+d.s,{i,j}});",
      "\t\t\t}",
      "\t\t\tsweep[-v[i].s] = i;",
      "\t\t}",
      "\t\teach(p,v) {",
      "\t\t\tif (k&1) p.f *= -1;",
      "\t\t\telse swap(p.f,p.s);",
      "\t\t}",
      "\t}",
      "\treturn ed;",
      "}"
    ],
    "description": "Given \\$N\\$ points, returns up to \\$4N\\$ edges which are guaranteed, * to contain a MST for graph with edge weights \\$w(p,q) =|p.x-q.x|+|p.y-q.y|.\\$ , * Edges are in the form \\texttt{\\{dist, \\{src, dst\\}\\}}. , * Time: O(N\\log N), *"
  },
  "MaxCollinear": {
    "prefix":["benq_MaxCollinear"],
    "body": [
      "/**",
      " * Description: Compute the maximum number of points which lie on the same line in O(n^2logn)",
      " * Source: own",
      " * Verification: https://open.kattis.com/problems/maxcolinear",
      " */",
      "",
      "pair<pi,int> getline(pi a, pi b) {",
      "\tpi z = {b.f-a.f,b.s-a.s};",
      "\tswap(z.f,z.s); z.f *= -1;",
      "\tint g = __gcd(z.f,z.s); z.f /= g, z.s /= g;",
      "\tckmin(z,{-z.f,-z.s});",
      "\treturn {z,z.f*a.f+z.s*a.s};",
      "}",
      "",
      "int solve(vpi p) {",
      "\tint n = sz(p);",
      "\tmap<pair<pi,int>,int> m;",
      "\tF0R(i,n) FOR(j,i+1,n) m[getline(p[i],p[j])] ++;",
      "",
      "\tint mx = 0; each(a,m) ckmax(mx,a.s);",
      "\tint ans = 0; FOR(i,1,n+1) if (i*(i-1)/2 <= mx) ans = i;",
      "\treturn ans;",
      "}"
    ],
    "description": "Compute the maximum number of points which lie on the same line in O(n^2logn), *"
  },
  "ConvexHull": {
    "prefix":["benq_ConvexHull"],
    "body": [
      "/**",
      " * Description: top-bottom convex hull",
      " * Time: O(N\\log N)",
      " * Source: Wikibooks, KACTL",
      " * Verification:",
      "\t* https://open.kattis.com/problems/convexhull",
      " */",
      "",
      "#include \"../Primitives/Point.h\"",
      "",
      "/// typedef ll T;",
      "pair<vi,vi> ulHull(const vP& v) {",
      "\tvi p(sz(v)), u, l; iota(all(p), 0);",
      "\tsort(all(p), [&v](int a, int b) { return v[a] < v[b]; });",
      "\teach(i,p) {",
      "\t\t#define ADDP(C, cmp) while (sz(C) > 1 && cross(\\",
      "\t\t\tv[C[sz(C)-2]],v[C.bk],v[i]) cmp 0) C.pop_back(); C.pb(i);",
      "\t\tADDP(u, >=); ADDP(l, <=);",
      "\t}",
      "\treturn {u,l};",
      "}",
      "vi hullInd(const vP& v) {",
      "\tvi u,l; tie(u,l) = ulHull(v); if (sz(l) <= 1) return l;",
      "\tif (v[l[0]] == v[l[1]]) return {0};",
      "\tl.insert(end(l),1+rall(u)-1); return l;",
      "}",
      "vP hull(const vP& v) {",
      "\tvi w = hullInd(v); vP res; each(t,w) res.pb(v[t]);",
      "\treturn res; }"
    ],
    "description": "top-bottom convex hull, * Time: O(N\\log N), *"
  },
  "ConvexHull2": {
    "prefix":["benq_ConvexHull2"],
    "body": [
      "/**",
      " * Description: Graham Scan",
      " * Time: O(N\\log N)",
      " * Source: Own",
      " * Verification:",
      "\t* https://open.kattis.com/problems/convexhull",
      " */",
      "",
      "#include \"../Primitives/Point.h\"",
      "",
      "/// typedef ll T;",
      "vi hullInd(const vP& v) {",
      "\tint ind = min_element(all(v))-begin(v);",
      "\tvi cand(sz(v)),C; iota(all(cand),0);",
      "\tsort(all(cand),[&](int a, int b) { ",
      "\t\tP x = v[a]-v[ind], y = v[b]-v[ind]; T t = cross(x,y);",
      "\t\treturn t != 0 ? t > 0 : norm(x) < norm(y);",
      "\t});",
      "\t#define bad(x) cross(v[C[sz(C)-2]],v[C.bk],v[x]) <= 0",
      "\teach(t,cand) {",
      "\t\twhile (sz(C) > 1 && bad(t)) C.pop_back();",
      "\t\tC.pb(t); } // if hull has > 1 point",
      "\tif (v[ind]!=v[C.bk])while(sz(C)>2&&bad(ind))C.pop_back();",
      "\treturn C;",
      "}",
      "/**vP hull(const vP& v) {",
      "\tvi w = hullInd(v); vP res; each(t,w) res.pb(v[t]);",
      "\treturn res; }*/"
    ],
    "description": "Graham Scan, * Time: O(N\\log N), *"
  },
  "Diameter": {
    "prefix":["benq_Diameter"],
    "body": [
      "/**",
      " * Description: rotating caliphers, gives greatest distance between two points in \\$P\\$",
      " * Time: \\$O(N)\\$ given convex hull",
      " * Source: KACTL",
      " * Verification: https://open.kattis.com/problems/roberthood",
      " */",
      "",
      "#include \"ConvexHull (13.2).h\"",
      "",
      "ld diameter(vP P) { ",
      "\tP = hull(P);",
      "\tint n = sz(P), ind = 1; ld ans = 0;",
      "\tF0R(i,n) for (int j = (i+1)%n;;ind = (ind+1)%n) {",
      "\t\tckmax(ans,abs(P[i]-P[ind]));",
      "\t\tif (cross(P[j]-P[i],P[(ind+1)%n]-P[ind]) <= 0) break;",
      "\t}",
      "\treturn ans;",
      "}"
    ],
    "description": "rotating caliphers, gives greatest distance between two points in \\$P\\$, * Time: \\$O(N)\\$ given convex hull, *"
  },
  "HalfPlaneIsect": {
    "prefix":["benq_HalfPlaneIsect"],
    "body": [
      "/**",
      " * Description: half-plane intersection area",
      " * Time: O(N\\log N)",
      " * Source: Own",
      " \t* http://www.cs.umd.edu/class/spring2020/cmsc754/Lects/lect06-duality.pdf might be of interest",
      " * Verification:",
      "\t* https://open.kattis.com/problems/bigbrother ",
      "\t* (planes through two points with integer coordinates <= 10^7)",
      " */",
      "",
      "#include \"Point.h\"",
      "",
      "using Half = AR<T,3>; // half-plane",
      "using vH = V<Half>;",
      "P hp_point(const Half& h) { return {h[0],h[1]}; } // direction of half-plane",
      "P isect(const Half& h0, const Half& h1) { // Cramer's rule to intersect half-planes",
      "\tAR<T,3> vals;",
      "\tFOR(i,-1,2) {",
      "\t\tint x = (i == 0 ? 2 : 0), y = (i == 1 ? 2 : 1);",
      "\t\tvals[1+i] = h0[x]*h1[y]-h0[y]*h1[x];",
      "\t}",
      "\tassert(vals[0] != 0); return {vals[1]/vals[0],vals[2]/vals[0]};",
      "}",
      "T eval(const Half& h, T x) { assert(h[1] != 0); // evaluate half-plane at x-coordinate",
      "\treturn (h[2]-h[0]*x)/h[1]; }",
      "T x_isect(const Half& h0, const Half& h1) { return isect(h0,h1).f; } // x-coordinate of intersection",
      "",
      "vH construct_lower(P x, vH planes) { // similar to convex hull (by duality)",
      "\tsort(all(planes),[](const Half& a, const Half& b) {",
      "\t\treturn cross(hp_point(a),hp_point(b)) > 0; });",
      "\tvH res{{1,0,x.f}}; // >= x.f",
      "\tplanes.pb({-1,0,-x.s}); // <= x.s",
      "\tauto lst_x = [&](Half a, Half b) {",
      "\t\tif (cross(hp_point(a),hp_point(b)) == 0) // parallel half-planes, remove lower one",
      "\t\t\treturn a[2]/a[1] <= b[2]/b[1] ? x.f : x.s;",
      "\t\treturn x_isect(a,b);",
      "\t};",
      "\teach(t,planes) {",
      "\t\twhile (sz(res) > 1 && lst_x(res.bk,t) <= lst_x(end(res)[-2],res.bk))",
      "\t\t\tres.pop_back();",
      "\t\tres.pb(t);",
      "\t}",
      "\treturn res;",
      "}",
      "",
      "T isect_area(vH planes) {",
      "\tconst T BIG = 1e9; P x{-BIG,BIG};",
      "\tplanes.pb({0,1,-BIG}); // y >= -BIG",
      "\tplanes.pb({0,-1,-BIG}); // -y >= -BIG",
      "\tvH upper, lower;",
      "\teach(t,planes) {",
      "\t\tif (t[1] == 0) { // vertical line",
      "\t\t\tT quo = t[2]/t[0];",
      "\t\t\tif (t[0] > 0) ckmax(x.f,quo);",
      "\t\t\telse ckmin(x.s,quo); // -x >=",
      "\t\t} else if (t[1] > 0) lower.pb(t);",
      "\t\telse upper.pb(t);",
      "\t}",
      "\tif (x.f >= x.s) return 0;",
      "\tlower = construct_lower(x,lower);",
      "",
      "\teach(t,upper) t[0] *= -1, t[1] *= -1; ",
      "\tupper = construct_lower({-x.s,-x.f},upper);",
      "\teach(t,upper) t[0] *= -1, t[1] *= -1;",
      "\treverse(all(upper));",
      "\tint iu = 1, il = 1;",
      "\tT lst = x.f, lst_dif = eval(upper[1],lst)-eval(lower[1],lst);",
      "\tT ans = 0;",
      "\twhile (iu < sz(upper)-1 && il < sz(lower)-1) { // sweep vertical line through lower and upper hulls",
      "\t\tT nex_upper = x_isect(upper[iu],upper[iu+1]);",
      "\t\tT nex_lower = x_isect(lower[il],lower[il+1]);",
      "\t\tT nex = min(nex_upper,nex_lower);",
      "\t\tT nex_dif = eval(upper[iu],nex)-eval(lower[il],nex);",
      "\t\tauto avg_val = [](T a, T b) -> T {",
      "\t\t\tif (a > b) swap(a,b);",
      "\t\t\tif (b <= 0) return 0;",
      "\t\t\tif (a >= 0) return (a+b)/2;",
      "\t\t\treturn b/(b-a)*b/2;",
      "\t\t};",
      "\t\tans += (nex-lst)*avg_val(lst_dif,nex_dif);",
      "\t\tassert(x.f <= nex && nex <= x.s);",
      "\t\tlst = nex, lst_dif = nex_dif;",
      "\t\tiu += lst == nex_upper;",
      "\t\til += lst == nex_lower;",
      "\t}",
      "\treturn ans;",
      "}",
      "",
      "Half plane_right(P a, P b) { // half-plane to right of a -> b",
      "\treturn {b.s-a.s,a.f-b.f,(b.s-a.s)*a.f+(a.f-b.f)*a.s}; }",
      "Half plane_through(P p, P dir) { // half-plane through p in direction dir",
      "\treturn {dir.f,dir.s,dot(p,dir)}; }"
    ],
    "description": "half-plane intersection area, * Time: O(N\\log N), *"
  },
  "HullTangents": {
    "prefix":["benq_HullTangents"],
    "body": [
      "/** ",
      " * Description: Given convex polygon with no three points collinear and a point ",
      " \t* strictly outside of it, computes the lower and upper tangents.",
      " * Source: Own",
      " * Time: O(\\log N)",
      " * Verification: tested",
      " */",
      "",
      "#include \"../Primitives/Point.h\"",
      "",
      "bool lower;",
      "bool better(P a, P b, P c) { ",
      "\tT z = cross(a,b,c); ",
      "\treturn lower ? z < 0 : z > 0; }",
      "int tangent(const vP& a, P b) {",
      "\tif (sz(a) == 1) return 0;",
      "\tint lo, hi;",
      "\tif (better(b,a[0],a[1])) {",
      "\t\tlo = 0, hi = sz(a)-1;",
      "\t\twhile (lo < hi) {",
      "\t\t\tint mid = (lo+hi+1)/2;",
      "\t\t\tif (better(b,a[0],a[mid])) lo = mid;",
      "\t\t\telse hi = mid-1;",
      "\t\t}",
      "\t\tlo = 0;",
      "\t} else {",
      "\t\tlo = 1, hi = sz(a);",
      "\t\twhile (lo < hi) {",
      "\t\t\tint mid = (lo+hi)/2;",
      "\t\t\tif (!better(b,a[0],a[mid])) lo = mid+1;",
      "\t\t\telse hi = mid;",
      "\t\t}",
      "\t\thi = sz(a);",
      "\t}",
      "\twhile (lo < hi) {",
      "\t\tint mid = (lo+hi)/2;",
      "\t\tif (better(b,a[mid],a[(mid+1)%sz(a)])) lo = mid+1;",
      "\t\telse hi = mid;",
      "\t}",
      "\treturn lo%sz(a);",
      "}",
      "pi tangents(const vP& a, P b) {",
      "\tlower = 1; int x = tangent(a,b); ",
      "\tlower = 0; int y = tangent(a,b); ",
      "\treturn {x,y};",
      "}"
    ],
    "description": "Given convex polygon with no three points collinear and a point ,  * strictly outside of it, computes the lower and upper tangents., *"
  },
  "LineHull": {
    "prefix":["benq_LineHull"],
    "body": [
      "/**",
      " * Description: \\texttt{lineHull} accepts line and ccw convex polygon. If all vertices in poly ",
      " \t* lie to one side of the line, returns a vector of closest vertices to line as well as ",
      " \t* orientation of poly with respect to line (\\$\\pm 1\\$ for above/below). Otherwise, returns ",
      " \t* the range of vertices that lie on or below the line. \\texttt{extrVertex} returns the point ",
      " \t* of a hull with the max projection onto a line.",
      " * Source: https://github.com/kth-competitive-programming/kactl/blob/master/content/geometry/LineHullIntersection.h",
      " * Time: O(\\log N)",
      " * Verification: tested",
      " */",
      "",
      "#include \"../Primitives/Point.h\"",
      "",
      "typedef array<P,2> Line;",
      "#define cmp(i,j) sgn(-dot(dir,poly[(i)%n]-poly[(j)%n]))",
      "#define extr(i) cmp(i+1,i) >= 0 && cmp(i,i-1+n) < 0",
      "int extrVertex(const vP& poly, P dir) {",
      "\tint n = sz(poly), lo = 0, hi = n;",
      "\tif (extr(0)) return 0;",
      "\twhile (lo+1 < hi) {",
      "\t\tint m = (lo+hi)/2;",
      "\t\tif (extr(m)) return m;",
      "\t\tint ls = cmp(lo+1,lo), ms = cmp(m+1,m);",
      "\t\t(ls < ms || (ls == ms && ls == cmp(lo,m)) ? hi : lo) = m;",
      "\t}",
      "\treturn lo;",
      "}",
      "vi same(Line line, const vP& poly, int a) { ",
      "\t// points on same parallel as a",
      "\tint n = sz(poly); P dir = perp(line[0]-line[1]); ",
      "\tif (cmp(a+n-1,a) == 0) return {(a+n-1)%n,a};",
      "\tif (cmp(a,a+1) == 0) return {a,(a+1)%n};",
      "\treturn {a};",
      "}",
      "#define cmpL(i) sgn(cross(line[0],line[1],poly[i]))",
      "pair<int,vi> lineHull(Line line, const vP& poly) {",
      "\tint n = sz(poly); assert(n>1);",
      "\tint endA = extrVertex(poly,perp(line[0]-line[1])); // lowest",
      "\tif (cmpL(endA) >= 0) return {1,same(line,poly,endA)};",
      "\tint endB = extrVertex(poly,perp(line[1]-line[0])); // highest",
      "\tif (cmpL(endB) <= 0) return {-1,same(line,poly,endB)}; ",
      "\tarray<int,2> res;",
      "\tF0R(i,2) {",
      "\t\tint lo = endA, hi = endB; if (hi < lo) hi += n;",
      "\t\twhile (lo < hi) {",
      "\t\t\tint m = (lo+hi+1)/2;",
      "\t\t\tif (cmpL(m%n) == cmpL(endA)) lo = m;",
      "\t\t\telse hi = m-1;",
      "\t\t}",
      "\t\tres[i] = lo%n; swap(endA,endB);",
      "\t}",
      "\tif (cmpL((res[0]+1)%n) == 0) res[0] = (res[0]+1)%n;",
      "\treturn {0,{(res[1]+1)%n,res[0]}};",
      "}"
    ],
    "description": "\\texttt{lineHull} accepts line and ccw convex polygon. If all vertices in poly ,  * lie to one side of the line, returns a vector of closest vertices to line as well as ,  * orientation of poly with respect to line (\\$\\pm 1\\$ for above/below). Otherwise, returns ,  * the range of vertices that lie on or below the line. \\texttt{extrVertex} returns the point ,  * of a hull with the max projection onto a line., *"
  },
  "PolyCenArea": {
    "prefix":["benq_PolyCenArea"],
    "body": [
      "/**",
      " * Description: centroid (center of mass) of a polygon with ",
      " \t* constant mass per unit area and SIGNED area",
      " * Time: O(N)",
      " * Source: http://codeforces.com/blog/entry/22175, KACTL",
      " * Verification: kattis polygonarea, VT HSPC 2018 Holiday Stars",
      " */",
      "",
      "#include \"../Primitives/Point.h\"",
      "",
      "pair<P,T> cenArea(const vP& v) { ",
      "\tP cen(0,0); T area = 0; ",
      "\tF0R(i,sz(v)) {",
      "\t\tint j = (i+1)%sz(v); T a = cross(v[i],v[j]);",
      "\t\tcen += a*(v[i]+v[j]); area += a;",
      "\t}",
      "\treturn {cen/area/(T)3,area/2};",
      "}"
    ],
    "description": "centroid (center of mass) of a polygon with ,  * constant mass per unit area and SIGNED area, * Time: O(N), *"
  },
  "PolyIn": {
    "prefix":["benq_PolyIn"],
    "body": [
      "/** ",
      " * Description: Tests whether point is inside, on, or outside of a polygon ",
      " \t* (returns -1, 0, or 1). Both CW and CCW polygons are ok.",
      " * Time: O(N)",
      " * Verification: https://open.kattis.com/problems/pointinpolygon",
      " */",
      "",
      "#include \"../Primitives/Point.h\"",
      "",
      "int p_in_poly(const P& p, const vP& poly) {",
      "\tint n = sz(poly), ans = 0;",
      "\tF0R(i,n) {",
      "\t\tP x = poly[i], y = poly[(i+1)%n]; if (x.s > y.s) swap(x,y);",
      "\t\tif (p_on_seg(p,{x,y})) return 0;",
      "\t\tans ^= (x.s <= p.s && p.s < y.s && cross(p,x,y) > 0);",
      "\t}",
      "\treturn ans ? -1 : 1;",
      "}"
    ],
    "description": "None"
  },
  "AngleCmp": {
    "prefix":["benq_AngleCmp"],
    "body": [
      "/**",
      " * Description: Sorts points in ccw order about origin in the same way as",
      " \t* \\texttt{atan2}, which returns real in \\$(-\\pi,\\pi]\\$ so points on ",
      " \t* negative \\$x\\$-axis come last.",
      " * Verification: https://codeforces.com/contest/1284/submission/68175790",
      " \t* https://codeforces.com/contest/1284/submission/68207607 ",
      " \t* (don't use atan2, weird stuff happens!)",
      " */",
      "",
      "#include \"Point.h\"",
      "",
      "int half(P x) { return x.s != 0 ? sgn(x.s) : -sgn(x.f); } // -1 if lower half, 0 if origin, 1 if upper half",
      "bool angleCmp(P a, P b) { ",
      "\tint A = half(a), B = half(b);",
      "\treturn A == B ? cross(a,b) > 0 : A < B; }",
      "",
      "/** Usage: ",
      " \t* vP v;",
      " \t* sort(all(v),[](P a, P b) { return ",
      " \t\tatan2(a.s,a.f) < atan2(b.s,b.f); });",
      " \t* sort(all(v),angleCmp); // should give same result",
      "*/"
    ],
    "description": "None"
  },
  "Complex": {
    "prefix":["benq_Complex"],
    "body": [
      "/**",
      " * Description: Easy geo. ",
      " * Source: http://codeforces.com/blog/entry/22175, KACTL",
      " \t* https://codeforces.com/blog/entry/22175#comment-582178",
      " * Verification: various",
      " */",
      "",
      "typedef ld T; // or db, not ll",
      "int sgn(T a) { return (a>0)-(a<0); }",
      "T sq(T a) { return a*a; }",
      "",
      "#define x real()",
      "#define y imag()",
      "typedef complex<T> P; typedef vector<P> vP;",
      "namespace std { // take care of comparisons",
      "\tbool operator<(P l, P r) { return mp(l.x,l.y) < mp(r.x,r.y); } }",
      "P dir(T ang) { return polar((T)1,ang); }",
      "P unit(P p) { return p/abs(p); }",
      "T dot(P a, P b) { return a.x*b.x+a.y*b.y; }",
      "T cross(P a, P b) { return a.x*b.y-a.y*b.x; }",
      "T cross(P p, P a, P b) { return cross(a-p,b-p); }",
      "P reflect(P p,P a,P b) { return a+conj((p-a)/(b-a))*(b-a); }",
      "P foot(P p, P a, P b) { return (p+reflect(p,a,b))/(T)2; }",
      "bool onSeg(P p, P a, P b) { ",
      "\treturn cross(a,b,p) == 0 && dot(p-a,p-b) <= 0; }"
    ],
    "description": "Easy geo. , *"
  },
  "ComplexComp": {
    "prefix":["benq_ComplexComp"],
    "body": [
      "/**",
      " * Description: Allows you to sort complex numbers.",
      " * Source: http://codeforces.com/blog/entry/22175, KACTL",
      " \t* https://codeforces.com/blog/entry/22175#comment-582178",
      " * Verification: various",
      " */",
      "",
      "#define x real()",
      "#define y imag()",
      "typedef complex<db> P;",
      "namespace std { ",
      "\tbool operator<(P l,P r) { return mp(l.x,l.y)<mp(r.x,r.y); } }",
      "/// vector<P> v = {{4,5},{3,6},{5,7}}; sort(all(v)); ps(v);"
    ],
    "description": "Allows you to sort complex numbers., *"
  },
  "LineIsect": {
    "prefix":["benq_LineIsect"],
    "body": [
      "/** ",
      " * Description: Computes the intersection point(s) of lines \\$AB\\$, \\$CD.\\$",
      " \t* Returns \\$\\{-1,\\{0,0\\}\\}\\$ if infinitely many, \\$\\{0,\\{0,0\\}\\}\\$ if none, ",
      " \t* \\$\\{1,x\\}\\$ if \\$x\\$ is the unique point.",
      " * Source: KACTL",
      " * Verification: ?",
      " */",
      "",
      "#include \"Point.h\"",
      "",
      "P ext(P a, P b, P c, P d) { // extension in asymptote",
      "\tT x = cross(a,b,c), y = cross(a,b,d);",
      "\treturn (d*x-c*y)/(x-y); }",
      "pair<int,P> lineIsect(P a, P b, P c, P d) { ",
      "\treturn cross(b-a,d-c) == 0 ? mp(-(cross(a,c,d) == 0),P()) ",
      "\t: mp(1,ext(a,b,c,d)); }"
    ],
    "description": "Computes the intersection point(s) of lines \\$AB\\$, \\$CD.\\$,  * Returns \\$\\{-1,\\{0,0\\}\\}\\$ if infinitely many, \\$\\{0,\\{0,0\\}\\}\\$ if none, ,  * \\$\\{1,x\\}\\$ if \\$x\\$ is the unique point., *"
  },
  "Point": {
    "prefix":["benq_Point"],
    "body": [
      "/**",
      " * Description: Use in place of \\texttt{complex<T>}.",
      " * Source: http://codeforces.com/blog/entry/22175, KACTL",
      " * Verification: various",
      " */",
      "",
      "using T = db; // or long long",
      "const T EPS = 1e-9; // might want to change",
      "using P = pair<T,T>; using vP = V<P>; using Line = pair<P,P>;",
      "int sgn(T a) { return (a>EPS)-(a<-EPS); }",
      "T sq(T a) { return a*a; }",
      "",
      "bool close(const P& a, const P& b) { ",
      "\treturn sgn(a.f-b.f) == 0 && sgn(a.s-b.s) == 0; } ",
      "T norm(const P& p) { return sq(p.f)+sq(p.s); }",
      "T abs(const P& p) { return sqrt(norm(p)); }",
      "T arg(const P& p) { return atan2(p.s,p.f); }",
      "P conj(const P& p) { return P(p.f,-p.s); }",
      "P perp(const P& p) { return P(-p.s,p.f); }",
      "P dir(T ang) { return P(cos(ang),sin(ang)); }",
      "",
      "P operator-(const P& l) { return P(-l.f,-l.s); }",
      "P operator+(const P& l, const P& r) { ",
      "\treturn P(l.f+r.f,l.s+r.s); }",
      "P operator-(const P& l, const P& r) { ",
      "\treturn P(l.f-r.f,l.s-r.s); }",
      "P operator*(const P& l, const T& r) { ",
      "\treturn P(l.f*r,l.s*r); }",
      "P operator*(const T& l, const P& r) { return r*l; }",
      "P operator/(const P& l, const T& r) { ",
      "\treturn P(l.f/r,l.s/r); }",
      "P operator*(const P& l, const P& r) { ",
      "\treturn P(l.f*r.f-l.s*r.s,l.s*r.f+l.f*r.s); }",
      "P operator/(const P& l, const P& r) { ",
      "\treturn l*conj(r)/norm(r); }",
      "P& operator+=(P& l, const P& r) { return l = l+r; }",
      "P& operator-=(P& l, const P& r) { return l = l-r; }",
      "P& operator*=(P& l, const T& r) { return l = l*r; }",
      "P& operator/=(P& l, const T& r) { return l = l/r; }",
      "P& operator*=(P& l, const P& r) { return l = l*r; }",
      "P& operator/=(P& l, const P& r) { return l = l/r; }",
      "",
      "P unit(const P& p) { return p/abs(p); }",
      "T dot(const P& a, const P& b) { return a.f*b.f+a.s*b.s; }",
      "T cross(const P& a, const P& b) { return a.f*b.s-a.s*b.f; }",
      "T cross(const P& p, const P& a, const P& b) {",
      "\treturn cross(a-p,b-p); }",
      "P reflect(const P& p, const Line& l) { ",
      "\tP a = l.f, d = l.s-l.f;",
      "\treturn a+conj((p-a)/d)*d; }",
      "P foot(const P& p, const Line& l) { ",
      "\treturn (p+reflect(p,l))/(T)2; }",
      "bool p_on_seg(const P& p, const Line& l) {",
      "\treturn sgn(cross(l.f,l.s,p)) == 0 && sgn(dot(p-l.f,p-l.s)) <= 0; }"
    ],
    "description": "Use in place of \\texttt{complex<T>}., *"
  },
  "PointShort": {
    "prefix":["benq_PointShort"],
    "body": [
      "/**",
      " * Description: Use in place of \\texttt{complex<T>}.",
      " * Source: http://codeforces.com/blog/entry/22175",
      " \t* https://github.com/kth-competitive-programming/kactl/blob/master/content/geometry/Point.h",
      " * Verification: various",
      " */",
      "",
      "using T = ld;",
      "int sgn(T a) { return (a>0)-(a<0); }",
      "T sq(T a) { return a*a; }",
      "",
      "typedef pair<T,T> P; typedef vector<P> vP;",
      "T norm(P p) { return sq(p.f)+sq(p.s); }",
      "T abs(P p) { return sqrt(norm(p)); }",
      "T arg(P p) { return atan2(p.s,p.f); }",
      "P conj(P p) { return P(p.f,-p.s); }",
      "P perp(P p) { return P(-p.s,p.f); }",
      "P operator+(P l, P r) { return P(l.f+r.f,l.s+r.s); }",
      "P operator-(P l, P r) { return P(l.f-r.f,l.s-r.s); }",
      "P operator*(P l, T r) { return P(l.f*r,l.s*r); }",
      "P operator/(P l, T r) { return P(l.f/r,l.s/r); }",
      "P operator*(P l, P r) { // complex # multiplication ",
      "\treturn P(l.f*r.f-l.s*r.s,l.s*r.f+l.f*r.s); }",
      "P operator/(P l, P r) { return l*conj(r)/norm(r); }",
      "",
      "P unit(P p) { return p/abs(p); }",
      "T dot(P a, P b) { return a.f*b.f+a.s*b.s; }",
      "T cross(P a, P b) { return a.f*b.s-a.s*b.f; }",
      "T cross(P p, P a, P b) { return cross(a-p,b-p); }",
      "P reflect(P p, P a, P b) { ",
      "\treturn a+conj((p-a)/(b-a))*(b-a); }",
      "P foot(P p, P a, P b) { return (p+reflect(p,a,b))/(T)2; }",
      "bool onSeg(P p, P a, P b) { ",
      "\treturn cross(a,b,p) == 0 && dot(p-a,p-b) <= 0; }",
      "ostream& operator<<(ostream& os, P p) {",
      "\treturn os << \"(\" << p.f << \",\" << p.s << \")\"; }"
    ],
    "description": "Use in place of \\texttt{complex<T>}., *"
  },
  "SegDist": {
    "prefix":["benq_SegDist"],
    "body": [
      "/**",
      " * Description: computes distance between \\$P\\$ and line (segment) \\$AB\\$",
      " * Source: own",
      " * Verification: https://open.kattis.com/problems/segmentdistance",
      " */",
      "",
      "#include \"Point.h\"",
      "",
      "T lineDist(P p, P a, P b) { ",
      "\treturn abs(cross(p,a,b))/abs(a-b); }",
      "T segDist(P p, P a, P b) { ",
      "\tif (dot(p-a,b-a) <= 0) return abs(p-a);",
      "\tif (dot(p-b,a-b) <= 0) return abs(p-b);",
      "\treturn lineDist(p,a,b); }"
    ],
    "description": "computes distance between \\$P\\$ and line (segment) \\$AB\\$, *"
  },
  "SegIsect": {
    "prefix":["benq_SegIsect"],
    "body": [
      "/** ",
      " * Description: computes the intersection point(s) of line segments \\$AB\\$, \\$CD\\$",
      " * Source: KACTL",
      " * Verification: https://open.kattis.com/problems/segmentintersection",
      " */",
      "",
      "#include \"Point.h\"",
      "",
      "vP strict_isect(const Line& a, const Line& b) {",
      "\tT a0 = cross(a.f,a.s,b.f), a1 = cross(a.f,a.s,b.s); ",
      "\tT b0 = cross(b.f,b.s,a.f), b1 = cross(b.f,b.s,a.s); ",
      "\tif (sgn(a0)*sgn(a1) < 0 && sgn(b0)*sgn(b1) < 0) // strict intersection",
      "\t\treturn {(b.s*a0-b.f*a1)/(a0-a1)};",
      "\treturn {};",
      "}",
      "",
      "vP isect(const Line& a, const Line& b) { ",
      "\tvP v = strict_isect(a,b); if (sz(v)) return v;",
      "\tset<P> s;",
      "\t#define i(x,y) if (p_on_seg(x,y)) s.ins(x)",
      "\ti(a.f,b); i(a.s,b); i(b.f,a); i(b.s,a);",
      "\treturn {all(s)};",
      "}"
    ],
    "description": "computes the intersection point(s) of line segments \\$AB\\$, \\$CD\\$, *"
  },
  "DirectedMST": {
    "prefix":["benq_DirectedMST"],
    "body": [
      "/**",
      " * Description: Chu-Liu-Edmonds algorithm. Computes minimum weight directed ",
      " \t* spanning tree rooted at \\$r\\$, edge from \\$par[i]\\to i\\$ for all \\$i\\neq r.\\$",
      " \t* Use DSU with rollback if need to return edges.",
      " * Time: O(M\\log M)",
      " * Source: KACTL",
      " \t* https://courses.cs.washington.edu/courses/cse490u/17wi/slides/CLE.pdf",
      " * Verification: ",
      " \t* https://open.kattis.com/problems/fastestspeedrun",
      " \t* https://codeforces.com/problemset/problem/240/E",
      " */",
      "",
      "#include \"../DSU/DSUrb (15.5).h\"",
      "",
      "struct Edge { int a, b; ll w; };",
      "struct Node { // lazy skew heap node",
      "\tEdge key; Node *l, *r; ll delta;",
      "\tvoid prop() {",
      "\t\tkey.w += delta;",
      "\t\tif (l) l->delta += delta;",
      "\t\tif (r) r->delta += delta;",
      "\t\tdelta = 0;",
      "\t}",
      "\tEdge top() { prop(); return key; }",
      "};",
      "Node *merge(Node *a, Node *b) {",
      "\tif (!a || !b) return a ?: b;",
      "\ta->prop(), b->prop();",
      "\tif (a->key.w > b->key.w) swap(a, b);",
      "\tswap(a->l, a->r = merge(b, a->r));",
      "\treturn a;",
      "}",
      "void pop(Node*& a) { a->prop(); a = merge(a->l, a->r); }",
      "",
      "pair<ll,vi> dmst(int n, int r, const vector<Edge>& g) {",
      "\tDSUrb dsu; dsu.init(n); ",
      "\tvector<Node*> heap(n); // store edges entering each vertex ",
      "\t// in increasing order of weight",
      "\teach(e,g) heap[e.b] = merge(heap[e.b], new Node{e});",
      "\tll res = 0; vi seen(n,-1); seen[r] = r; ",
      "\tvpi in(n,{-1,-1}); // edge entering each vertex in MST",
      "\tvector<pair<int,vector<Edge>>> cycs;",
      "\tF0R(s,n) {",
      "\t\tint u = s, w;",
      "\t\tvector<pair<int,Edge>> path; ",
      "\t\twhile (seen[u] < 0) {",
      "\t\t\tif (!heap[u]) return {-1,{}};",
      "\t\t\tseen[u] = s;",
      "\t\t\tEdge e = heap[u]->top(); path.pb({u,e}); ",
      "\t\t\theap[u]->delta -= e.w, pop(heap[u]);",
      "\t\t\tres += e.w, u = dsu.get(e.a); ",
      "\t\t\tif (seen[u] == s) { // found cycle, contract",
      "\t\t\t\tNode* cyc = 0; cycs.eb();",
      "\t\t\t\tdo {",
      "\t\t\t\t\tcyc = merge(cyc, heap[w = path.bk.f]);",
      "\t\t\t\t\tcycs.bk.s.pb(path.bk.s);",
      "\t\t\t\t\tpath.pop_back(); ",
      "\t\t\t\t} while (dsu.unite(u,w));",
      "\t\t\t\tu = dsu.get(u); heap[u] = cyc, seen[u] = -1;",
      "\t\t\t\tcycs.bk.f = u;",
      "\t\t\t}",
      "\t\t}",
      "\t\teach(t,path) in[dsu.get(t.s.b)] = {t.s.a,t.s.b}; ",
      "\t} // found path from root to s, done",
      "\twhile (sz(cycs)) { // expand cycs to restore sol",
      "\t\tauto c = cycs.bk; cycs.pop_back();",
      "\t\tpi inEdge = in[c.f];",
      "\t\teach(t,c.s) dsu.rollback();",
      "\t\teach(t,c.s) in[dsu.get(t.b)] = {t.a,t.b};",
      "\t\tin[dsu.get(inEdge.s)] = inEdge;",
      "\t}",
      "\tvi par(n); F0R(i,n) par[i] = in[i].f; ",
      "\t// i == r ? in[i].s == -1 : in[i].s == i",
      "\treturn {res,par};",
      "}"
    ],
    "description": "Chu-Liu-Edmonds algorithm. Computes minimum weight directed ,  * spanning tree rooted at \\$r\\$, edge from \\$par[i]\\to i\\$ for all \\$i\\neq r.\\$,  * Use DSU with rollback if need to return edges., * Time: O(M\\log M), *"
  },
  "DirectedMST_KACTL": {
    "prefix":["benq_DirectedMST_KACTL"],
    "body": [
      "/**",
      " * Description: computes weight of minimum directed spanning tree",
      " * Time: O(M\\log M)",
      " * Source: KACTL",
      " \t* https://courses.cs.washington.edu/courses/cse490u/17wi/slides/CLE.pdf",
      " * Verification: https://open.kattis.com/problems/fastestspeedrun",
      " */",
      "",
      "#include \"../Fundamentals/DSU (7.6).h\"",
      "",
      "struct Edge { int a, b; ll w; };",
      "struct Node { /// lazy skew heap node",
      "\tEdge key;",
      "\tNode *l, *r;",
      "\tll delta;",
      "\tvoid prop() {",
      "\t\tkey.w += delta;",
      "\t\tif (l) l->delta += delta;",
      "\t\tif (r) r->delta += delta;",
      "\t\tdelta = 0;",
      "\t}",
      "\tEdge top() { prop(); return key; }",
      "};",
      "Node *merge(Node *a, Node *b) {",
      "\tif (!a || !b) return a ?: b;",
      "\ta->prop(), b->prop();",
      "\tif (a->key.w > b->key.w) swap(a, b);",
      "\tswap(a->l, (a->r = merge(b, a->r)));",
      "\treturn a;",
      "}",
      "void pop(Node*& a) { a->prop(); a = merge(a->l, a->r); }",
      "",
      "ll dmstKACTL(int n, int r, const vector<Edge>& g) {",
      "\tDSU dsu; dsu.init(n);",
      "\tvector<Node*> heap(n);",
      "\teach(e, g) heap[e.b] = merge(heap[e.b], new Node{e});",
      "\tll res = 0;",
      "\tvi seen(n, -1), path(n); seen[r] = r;",
      "\tF0R(s,n) {",
      "\t\tint u = s, qi = 0, w;",
      "\t\twhile (seen[u] < 0) {",
      "\t\t\tpath[qi++] = u, seen[u] = s;",
      "\t\t\tif (!heap[u]) return -1;",
      "\t\t\tEdge e = heap[u]->top();",
      "\t\t\theap[u]->delta -= e.w, pop(heap[u]);",
      "\t\t\tres += e.w, u = dsu.get(e.a);",
      "\t\t\tif (seen[u] == s) {",
      "\t\t\t\tNode* cyc = 0;",
      "\t\t\t\tdo cyc = merge(cyc, heap[w = path[--qi]]);",
      "\t\t\t\twhile (dsu.unite(u, w));",
      "\t\t\t\tu = dsu.get(u);",
      "\t\t\t\theap[u] = cyc, seen[u] = -1;",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\treturn res;",
      "}"
    ],
    "description": "computes weight of minimum directed spanning tree, * Time: O(M\\log M), *"
  },
  "DominatorTree": {
    "prefix":["benq_DominatorTree"],
    "body": [
      "/**",
      " * Description: Used only a few times. Assuming that all nodes are ",
      " \t* reachable from \\$root,\\$ \\$a\\$ dominates \\$b\\$ iff every path from ",
      " \t* \\$root\\$ to \\$b\\$ passes through \\$a.\\$",
      " * Time: O(M\\log N)",
      " * Source: https://tanujkhattar.wordpress.com/2016/01/11/dominator-tree-of-a-directed-graph/",
      " * Verification: ",
      " \t* https://codeforces.com/gym/100513/problem/L",
      " \t* https://open.kattis.com/problems/skiresort",
      " */",
      "",
      "template<int SZ> struct Dominator {",
      "\tvi adj[SZ], ans[SZ]; // input edges, edges of dominator tree",
      "\tvi radj[SZ], child[SZ], sdomChild[SZ];",
      "\tint label[SZ], rlabel[SZ], sdom[SZ], dom[SZ], co = 0;",
      "\tint par[SZ], bes[SZ]; ",
      "\tvoid ae(int a, int b) { adj[a].pb(b); }",
      "\tint get(int x) { // DSU with path compression",
      "\t\t// get vertex with smallest sdom on path to root",
      "\t\tif (par[x] != x) {",
      "\t\t\tint t = get(par[x]); par[x] = par[par[x]];",
      "\t\t\tif (sdom[t] < sdom[bes[x]]) bes[x] = t;",
      "\t\t}",
      "\t\treturn bes[x];",
      "\t} ",
      "\tvoid dfs(int x) { // create DFS tree",
      "\t\tlabel[x] = ++co; rlabel[co] = x; ",
      "\t\tsdom[co] = par[co] = bes[co] = co;",
      "\t\teach(y,adj[x]) {",
      "\t\t\tif (!label[y]) {",
      "\t\t\t\tdfs(y); child[label[x]].pb(label[y]); }",
      "\t\t\tradj[label[y]].pb(label[x]);",
      "\t\t}",
      "\t}",
      "\tvoid init(int root) {",
      "\t\tdfs(root);",
      "\t\tROF(i,1,co+1) {",
      "\t\t\teach(j,radj[i]) ckmin(sdom[i],sdom[get(j)]);",
      "\t\t\tif (i > 1) sdomChild[sdom[i]].pb(i);",
      "\t\t\teach(j,sdomChild[i]) {",
      "\t\t\t\tint k = get(j);",
      "\t\t\t\tif (sdom[j] == sdom[k]) dom[j] = sdom[j];",
      "\t\t\t\telse dom[j] = k;",
      "\t\t\t}",
      "\t\t\teach(j,child[i]) par[j] = i;",
      "\t\t}",
      "\t\tFOR(i,2,co+1) {",
      "\t\t\tif (dom[i] != sdom[i]) dom[i] = dom[dom[i]];",
      "\t\t\tans[rlabel[dom[i]]].pb(rlabel[i]);",
      "\t\t}",
      "\t}",
      "};"
    ],
    "description": "Used only a few times. Assuming that all nodes are ,  * reachable from \\$root,\\$ \\$a\\$ dominates \\$b\\$ iff every path from ,  * \\$root\\$ to \\$b\\$ passes through \\$a.\\$, * Time: O(M\\log N), *"
  },
  "EdgeColor": {
    "prefix":["benq_EdgeColor"],
    "body": [
      "/**",
      " * Description: Used only once. Naive implementation of Misra \\& Gries edge coloring. ",
      " * By Vizing's Theorem, a simple graph with max degree \\$d\\$ can be ",
      " * edge colored with at most \\$d+1\\$ colors ",
      " * Time: O(N^2M), faster in practice",
      " * Source: ",
      "\t* https://en.m.wikipedia.org/wiki/Vizing%27s_theorem ",
      "\t* https://en.wikipedia.org/wiki/Misra_%26_Gries_edge_coloring_algorithm",
      "\t* https://apps.dtic.mil/dtic/tr/fulltext/u2/a093097.pdf (optimal edge color on bipartite)",
      "\t* https://codeforces.com/blog/entry/62593",
      " * Verification: https://open.kattis.com/problems/gamescheduling",
      " */",
      " ",
      "template<int SZ> struct EdgeColor {",
      "\tint N = 0, maxDeg = 0, adj[SZ][SZ], deg[SZ];",
      "\tvoid init(int _N) { N = _N;",
      "\t\tF0R(i,N) { deg[i] = 0; F0R(j,N) adj[i][j] = 0; } }",
      "\tvoid ae(int a, int b, int c) { ",
      "\t\tadj[a][b] = adj[b][a] = c; }",
      "\tint delEdge(int a, int b) {",
      "\t\tint c = adj[a][b]; adj[a][b] = adj[b][a] = 0;",
      "\t\treturn c; }",
      "\tvector<bool> genCol(int x) { ",
      "\t\tvector<bool> col(N+1); F0R(i,N) col[adj[x][i]] = 1;",
      "\t\treturn col; }",
      "\tint freeCol(int u) {",
      "\t\tauto col = genCol(u); int x = 1; ",
      "\t\twhile (col[x]) x ++; return x; }",
      "\tvoid invert(int x, int d, int c) {",
      "\t\tF0R(i,N) if (adj[x][i] == d) ",
      "\t\t\tdelEdge(x,i), invert(i,c,d), ae(x,i,c); }",
      "\tvoid ae(int u, int v) { ",
      "\t\t// check if you can add edge w/o doing any work",
      "\t\tassert(N); ckmax(maxDeg,max(++deg[u],++deg[v]));",
      "\t\tauto a = genCol(u), b = genCol(v);",
      "\t\tFOR(i,1,maxDeg+2) if (!a[i] && !b[i]) ",
      "\t\t\treturn ae(u,v,i); ",
      "\t\t/// 2. find maximal fan of u starting at v",
      "\t\tvector<bool> use(N); vi fan = {v}; use[v] = 1;",
      "\t\twhile (1) {",
      "\t\t\tauto col = genCol(fan.bk);",
      "\t\t\tif (sz(fan) > 1) col[adj[fan.bk][u]] = 0;",
      "\t\t\tint i=0; while (i<N && (use[i] || col[adj[u][i]])) i++;",
      "\t\t\tif (i < N) fan.pb(i), use[i] = 1;",
      "\t\t\telse break;",
      "\t\t} ",
      "\t\t/// 3. choose free cols c and d for endpoints of fan",
      "\t\t/// 4. invert cd_u path",
      "\t\tint c = freeCol(u), d = freeCol(fan.bk); invert(u,d,c); ",
      "\t\t/// 5. find i such that d is free on fan[i]",
      "\t\tint i = 0; while (i < sz(fan) && genCol(fan[i])[d] ",
      "\t\t\t&& adj[u][fan[i]] != d) i ++; ",
      "\t\tassert (i != sz(fan));",
      "\t\t/// 6. rotate fan from 0 to i",
      "\t\tF0R(j,i) ae(u,fan[j],delEdge(u,fan[j+1]));",
      "\t\t/// 7. add new edge",
      "\t\tae(u,fan[i],d);",
      "\t}",
      "};"
    ],
    "description": "Used only once. Naive implementation of Misra \\& Gries edge coloring. , * By Vizing's Theorem, a simple graph with max degree \\$d\\$ can be , * edge colored with at most \\$d+1\\$ colors , * Time: O(N^2M), faster in practice, *"
  },
  "EdgeColorBip": {
    "prefix":["benq_EdgeColorBip"],
    "body": [
      "=/**",
      " * Description: Partition each edge of bipartite graph into one of",
      " \t* \\$maxDeg\\$ parts such that no two edges in the same part share",
      " \t* a vertex.",
      " * Time: O(M\\log M)",
      " * Source: https://www.tau.ac.il/~nogaa/PDFS/lex2.pdf",
      " \t* maybe also check https://codeforces.com/blog/entry/75431",
      " * Verification: https://judge.yosupo.jp/problem/bipartite_edge_coloring",
      " */",
      "",
      "template<int SZ, bool directed> struct Euler { // modified Euler cycle",
      "\tvpi adj[SZ]; vpi::iterator its[SZ];",
      "\tbool inVert[SZ]; vi verts;",
      "\tvector<bool> used;",
      "\tEuler() { F0R(i,SZ) inVert[i] = 0; }",
      "\tvi ans;",
      "\tvoid clr() {",
      "\t\teach(t,verts) adj[t].clear(), inVert[t] = 0;",
      "\t\tverts.clear(); used.clear(); ans.clear();",
      "\t}",
      "\tvoid addVert(int x) {",
      "\t\tif (inVert[x]) return;",
      "\t\tinVert[x] = 1; verts.pb(x);",
      "\t}",
      "\tvoid ae(int a, int b) {",
      "\t\tint M = sz(used); used.pb(0); ",
      "\t\taddVert(a); addVert(b);",
      "\t\tadj[a].eb(b,M); if (!directed) adj[b].eb(a,M); ",
      "\t}",
      "\tvoid go(int src) {",
      "\t\tvector<pair<pi,int>> ret, s = {{{src,-1},-1}}; ",
      "\t\t// {{vert, prev vert}, edge label}",
      "\t\twhile (sz(s)) {",
      "\t\t\tint x = s.bk.f.f; auto& it = its[x], en = end(adj[x]);",
      "\t\t\twhile (it != en && used[it->s]) it ++;",
      "\t\t\tif (it == en) { // no more edges out of vertex",
      "\t\t\t\tif (sz(ret) && ret.bk.f.s != x) exit(5);",
      "\t\t\t\tret.pb(s.bk), s.pop_back(); ",
      "\t\t\t} else { s.pb({{it->f,x},it->s}); used[it->s] = 1; }",
      "\t\t}",
      "\t\tF0R(i,sz(ret)-1) ans.pb(ret[i].s);",
      "\t\tassert(sz(ans)%2 == 0);",
      "\t}",
      "\tarray<vi,2> tour() {",
      "\t\teach(v,verts) {",
      "\t\t\tassert(sz(adj[v])%2 == 0);",
      "\t\t\tits[v] = begin(adj[v]);",
      "\t\t}",
      "\t\teach(v,verts) each(e,adj[v]) if (!used[e.s]) go(v);",
      "\t\tarray<vi,2> res; F0R(i,sz(ans)) res[i%2].pb(ans[i]);",
      "\t\treturn res;",
      "\t}",
      "};",
      "",
      "typedef array<int,2> T;",
      "struct EdgeColorBip {",
      "\tint N; vector<T> ed; // # verts on each side, edges",
      "\tEuler<200000,0> E; // at least 2*N",
      "\tarray<vi,2> split(vi lab) { // K is even, split into two parts",
      "\t\tE.clr(); each(t,lab) E.ae(ed[t][0],ed[t][1]);",
      "\t\tauto v = E.tour(); // get half edges on each",
      "\t\tF0R(i,2) each(t,v[i]) t = lab[t];",
      "\t\treturn v;",
      "\t}",
      "\tvi match(vi lab) { // find perfect matching in MlogM",
      "\t\tassert(sz(lab) && sz(lab)%N == 0); int K = sz(lab)/N;",
      "\t\tint p = 0; while ((1<<p) < N*K) p ++; ",
      "\t\tint a = (1<<p)/K; int b = (1<<p)-K*a; // multiply edge good edge by a",
      "\t\tvi cntGood(sz(lab),a), cntBad(N,b); // now each edge is adjacent to 2^t",
      "\t\tfor (;p;--p) { // divide by two!!",
      "\t\t\tE.clr(); vi tmp;",
      "\t\t\tF0R(i,N*K) {",
      "\t\t\t\tif (cntGood[i]&1) E.ae(ed[lab[i]][0],ed[lab[i]][1]), tmp.pb(i);",
      "\t\t\t\tcntGood[i] /= 2;",
      "\t\t\t}",
      "\t\t\tint numLab = sz(tmp);",
      "\t\t\tF0R(i,N) {",
      "\t\t\t\tif (cntBad[i]&1) E.ae(i,N+i), tmp.pb(i);",
      "\t\t\t\tcntBad[i] /= 2;",
      "\t\t\t}",
      "\t\t\tarray<vi,2> x = E.tour(); T cnt = T();",
      "\t\t\tF0R(i,2) each(t,x[i]) cnt[i] += t >= numLab;",
      "\t\t\tif (cnt[0] > cnt[1]) swap(x[0],x[1]);",
      "\t\t\teach(t,x[0]) {",
      "\t\t\t\tif (t < numLab) cntGood[tmp[t]] ++;",
      "\t\t\t\telse cntBad[tmp[t]] ++;",
      "\t\t\t}",
      "\t\t}",
      "\t\tvi v; F0R(i,sz(lab)) if (cntGood[i]) v.pb(lab[i]);",
      "\t\tassert(sz(v) == N);",
      "\t\treturn v;",
      "\t}",
      "\tvector<bool> used;",
      "\tvector<vi> edgeColor(vi lab) { // regular bipartite graph!",
      "\t\tassert(sz(lab)%N == 0); int K = sz(lab)/N;",
      "\t\tif (K == 0) return {};",
      "\t\tif (K == 1) return {lab};",
      "\t\tif (pct(K) == 1) {",
      "\t\t\tarray<vi,2> p = split(lab); ",
      "\t\t\tvector<vi> a = edgeColor(p[0]), b = edgeColor(p[1]);",
      "\t\t\ta.insert(end(a),all(b)); return a;",
      "\t\t}",
      "\t\tif (K%2 == 0) {",
      "\t\t\tarray<vi,2> p = split(lab); auto a = edgeColor(p[0]);",
      "\t\t\tint cur = K/2;",
      "\t\t\twhile (pct(cur)>1) {",
      "\t\t\t\tcur ++; p[1].insert(end(p[1]),all(a.bk));",
      "\t\t\t\ta.pop_back();",
      "\t\t\t}",
      "\t\t\tauto b = edgeColor(p[1]); a.insert(end(a),all(b)); return a;",
      "\t\t} else {",
      "\t\t\tvi v = match(lab); each(t,v) used[t] = 1;",
      "\t\t\tvi LAB; each(t,lab) if (!used[t]) LAB.pb(t);",
      "\t\t\teach(t,v) used[t] = 0;",
      "\t\t\tauto a = edgeColor(LAB); a.pb(v); return a;",
      "\t\t}",
      "\t}",
      "\tvector<vi> calc(vector<T> _ed) {",
      "\t\tT side = T(); each(t,_ed) F0R(i,2) ckmax(side[i],t[i]+1);",
      "\t\tvi deg[2], cmp[2], sz[2]; ",
      "\t\tF0R(i,2) deg[i].rsz(side[i]), cmp[i].rsz(side[i]);",
      "\t\teach(t,_ed) F0R(i,2) deg[i][t[i]] ++;",
      "\t\tint K = 0; F0R(i,2) each(t,deg[i]) ckmax(K,t);",
      "\t\tF0R(s,2) for (int i = 0; i < side[s]; ) {",
      "\t\t\tsz[s].pb(0);",
      "\t\t\twhile (i < side[s] && sz[s].bk+deg[s][i] <= K) ",
      "\t\t\t\tcmp[s][i] = sz(sz[s])-1, sz[s].bk += deg[s][i++]; ",
      "\t\t}",
      "\t\tF0R(i,2) while (sz(sz[i]) < sz(sz[i^1])) sz[i].pb(0);",
      "\t\tN = sz(sz[0]); ",
      "\t\teach(t,_ed) ed.pb({cmp[0][t[0]],N+cmp[1][t[1]]});",
      "\t\tint ind = 0;",
      "\t\tF0R(i,N) while (sz[0][i] < K) {",
      "\t\t\twhile (sz[1][ind] == K) ind ++;",
      "\t\t\tsz[0][i] ++, sz[1][ind] ++; ed.pb({i,N+ind});",
      "\t\t}",
      "\t\tused.rsz(N*K); vi lab(N*K); iota(all(lab),0);",
      "\t\treturn edgeColor(lab);",
      "\t}",
      "};"
    ],
    "description": "Partition each edge of bipartite graph into one of,  * \\$maxDeg\\$ parts such that no two edges in the same part share,  * a vertex., * Time: O(M\\log M), *"
  },
  "KthWalk": {
    "prefix":["benq_KthWalk"],
    "body": [
      "/** ",
      " * Description: \\$K\\$-th shortest walk from \\texttt{src} to \\texttt{des} in digraph. ",
      " \t* All edge weights must be non-negative.",
      " * Time: O((M+N)\\log N+K\\log K)",
      " * Memory: O((M+N)\\log N+K)",
      " * Source: https://judge.yosupo.jp/submission/11843",
      " * Verification: https://judge.yosupo.jp/problem/k_shortest_walk",
      " */",
      "",
      "#include \"LeftistHeap.h\"",
      "",
      "int N,M,src,des,K;",
      "",
      "ph cand[MX];",
      "vector<array<int,3>> adj[MX], radj[MX];",
      "pi pre[MX];",
      "ll dist[MX];",
      "",
      "struct state {",
      "\tint vert; ph p; ll cost;",
      "\tbool operator<(const state& s) const { return cost > s.cost; }",
      "};",
      "priority_queue<state> ans;",
      "",
      "void genHeaps() {",
      "\tF0R(i,N) dist[i] = INF, pre[i] = {-1,-1};",
      "\tpriority_queue<T,vector<T>,greater<T>> pq;",
      "\tauto ad = [&](int a, ll b, pi ind) {",
      "\t\tif (dist[a] <= b) return;",
      "\t\tpre[a] = ind; pq.push({dist[a] = b,a});",
      "\t};",
      "\tad(des,0,{-1,-1});",
      "\tvi seq; // reachable vertices in order of dist",
      "\twhile (sz(pq)) {",
      "\t\tauto a = pq.top(); pq.pop(); ",
      "\t\tif (a.f > dist[a.s]) continue;",
      "\t\tseq.pb(a.s); each(t,radj[a.s]) ad(t[0],a.f+t[1],{t[2],a.s}); // edge index, vert",
      "\t}",
      "\teach(t,seq) {",
      "\t\teach(u,adj[t]) if (u[2] != pre[t].f && dist[u[0]] != INF) {",
      "\t\t\tll cost = dist[u[0]]+u[1]-dist[t]; assert(cost >= 0);",
      "\t\t\tcand[t] = ins(cand[t],{cost,u[0]});",
      "\t\t}",
      "\t\tif (pre[t].f != -1) cand[t] = meld(cand[t],cand[pre[t].s]);",
      "\t\tif (t == src) {",
      "\t\t\tps(dist[t]); K --;",
      "\t\t\tif (cand[t]) ans.push(state{t,cand[t],dist[t]+cand[t]->v.f});",
      "\t\t}",
      "\t}",
      "}",
      "",
      "void solve() {",
      "\tre(N,M,src,des,K);",
      "\tF0R(i,M) {",
      "\t\tint u,v,w; re(u,v,w);",
      "\t\tadj[u].pb({v,w,i}); radj[v].pb({u,w,i}); // vert, weight, label",
      "\t}",
      "\tgenHeaps();",
      "\tF0R(i,K) {",
      "\t\tif (!sz(ans)) {",
      "\t\t\tps(-1);",
      "\t\t\tcontinue;",
      "\t\t}",
      "\t\tauto a = ans.top(); ans.pop();",
      "\t\tint vert = a.vert; ",
      "\t\tps(a.cost);",
      "\t\tif (a.p->l) ans.push(state{vert,a.p->l,a.cost+a.p->l->v.f-a.p->v.f});",
      "\t\tif (a.p->r) ans.push(state{vert,a.p->r,a.cost+a.p->r->v.f-a.p->v.f});",
      "\t\tint V = a.p->v.s; ",
      "\t\tif (cand[V]) ans.push(state{V,cand[V],a.cost+cand[V]->v.f});",
      "\t}",
      "}"
    ],
    "description": "\\$K\\$-th shortest walk from \\texttt{src} to \\texttt{des} in digraph. ,  * All edge weights must be non-negative., * Time: O((M+N)\\log N+K\\log K), * Memory: O((M+N)\\log N+K), *"
  },
  "LCT": {
    "prefix":["benq_LCT"],
    "body": [
      "/**",
      " * Description: Link-Cut Tree. Given a function \\$f(1\\ldots N)\\to 1\\ldots N,\\$ ",
      " \t* evaluates \\$f^b(a)\\$ for any \\$a,b.\\$ \\texttt{sz} is for path queries; ",
      " \t* \\texttt{sub}, \\texttt{vsub} are for subtree queries. \\texttt{x->access()} ",
      " \t* brings \\texttt{x} to the top and propagates it; its left subtree will be ",
      " \t* the path from \\texttt{x} to the root and its right subtree will be empty. ",
      " \t* Then \\texttt{sub} will be the number of nodes in the connected component",
      " \t* of \\texttt{x} and \\texttt{vsub} will be the number of nodes under \\texttt{x}.",
      " \t* Use \\texttt{makeRoot} for arbitrary path queries.",
      " * Time: O(\\log N)",
      " * Usage: FOR(i,1,N+1)LCT[i]=new snode(i); link(LCT[1],LCT[2],1);",
      " * Source: Dhruv Rohatgi, Eric Zhang",
      "\t* https://sites.google.com/site/kc97ble/container/splay-tree/splaytree-cpp-3",
      "\t* https://codeforces.com/blog/entry/67637",
      " * Verification: (see README for links)",
      "\t* ekzhang Balanced Tokens",
      "\t* Dynamic Tree Test (Easy)",
      "\t* https://probgate.org/viewproblem.php?pid=578 (The Applicant)",
      " */",
      "",
      "typedef struct snode* sn;",
      "struct snode { //////// VARIABLES",
      "\tsn p, c[2]; // parent, children",
      "\tsn extra; // extra cycle node for \"The Applicant\"",
      "\tbool flip = 0; // subtree flipped or not",
      "\tint val, sz; // value in node, # nodes in current splay tree",
      "\tint sub, vsub = 0; // vsub stores sum of virtual children",
      "\tsnode(int _val) : val(_val) {",
      "\t\tp = c[0] = c[1] = extra = NULL; calc(); }",
      "\tfriend int getSz(sn x) { return x?x->sz:0; }",
      "\tfriend int getSub(sn x) { return x?x->sub:0; }",
      "\tvoid prop() { // lazy prop",
      "\t\tif (!flip) return;",
      "\t\tswap(c[0],c[1]); flip = 0;",
      "\t\tF0R(i,2) if (c[i]) c[i]->flip ^= 1;",
      "\t}",
      "\tvoid calc() { // recalc vals",
      "\t\tF0R(i,2) if (c[i]) c[i]->prop();",
      "\t\tsz = 1+getSz(c[0])+getSz(c[1]);",
      "\t\tsub = 1+getSub(c[0])+getSub(c[1])+vsub;",
      "\t}",
      "\t//////// SPLAY TREE OPERATIONS",
      "\tint dir() {",
      "\t\tif (!p) return -2;",
      "\t\tF0R(i,2) if (p->c[i] == this) return i;",
      "\t\treturn -1; // p is path-parent pointer",
      "\t} // -> not in current splay tree",
      "\t// test if root of current splay tree",
      "\tbool isRoot() { return dir() < 0; } ",
      "\tfriend void setLink(sn x, sn y, int d) {",
      "\t\tif (y) y->p = x;",
      "\t\tif (d >= 0) x->c[d] = y; }",
      "\tvoid rot() { // assume p and p->p propagated",
      "\t\tassert(!isRoot()); int x = dir(); sn pa = p;",
      "\t\tsetLink(pa->p, this, pa->dir());",
      "\t\tsetLink(pa, c[x^1], x); setLink(this, pa, x^1);",
      "\t\tpa->calc();",
      "\t}",
      "\tvoid splay() {",
      "\t\twhile (!isRoot() && !p->isRoot()) {",
      "\t\t\tp->p->prop(), p->prop(), prop();",
      "\t\t\tdir() == p->dir() ? p->rot() : rot();",
      "\t\t\trot();",
      "\t\t}",
      "\t\tif (!isRoot()) p->prop(), prop(), rot();",
      "\t\tprop(); calc();",
      "\t}",
      "\tsn fbo(int b) { // find by order",
      "\t\tprop(); int z = getSz(c[0]); // of splay tree",
      "\t\tif (b == z) { splay(); return this; }",
      "\t\treturn b < z ? c[0]->fbo(b) : c[1] -> fbo(b-z-1);",
      "\t}",
      "\t//////// BASE OPERATIONS",
      "\tvoid access() { // bring this to top of tree, propagate",
      "\t\tfor (sn v = this, pre = NULL; v; v = v->p) {",
      "\t\t\tv->splay(); // now switch virtual children",
      "\t\t\tif (pre) v->vsub -= pre->sub;",
      "\t\t\tif (v->c[1]) v->vsub += v->c[1]->sub;",
      "\t\t\tv->c[1] = pre; v->calc(); pre = v;",
      "\t\t}",
      "\t\tsplay(); assert(!c[1]); // right subtree is empty",
      "\t}",
      "\tvoid makeRoot() { ",
      "\t\taccess(); flip ^= 1; access(); assert(!c[0] && !c[1]); }",
      "\t//////// QUERIES",
      "\tfriend sn lca(sn x, sn y) {",
      "\t\tif (x == y) return x;",
      "\t\tx->access(), y->access(); if (!x->p) return NULL;",
      "\t\tx->splay(); return x->p?:x; // y was below x in latter case",
      "\t} // access at y did not affect x -> not connected",
      "\tfriend bool connected(sn x, sn y) { return lca(x,y); } ",
      "\t// # nodes above",
      "\tint distRoot() { access(); return getSz(c[0]); } ",
      "\tsn getRoot() { // get root of LCT component",
      "\t\taccess(); sn a = this; ",
      "\t\twhile (a->c[0]) a = a->c[0], a->prop();",
      "\t\ta->access(); return a;",
      "\t}",
      "\tsn getPar(int b) { // get b-th parent on path to root",
      "\t\taccess(); b = getSz(c[0])-b; assert(b >= 0);",
      "\t\treturn fbo(b);",
      "\t} // can also get min, max on path to root, etc",
      "\t//////// MODIFICATIONS",
      "\tvoid set(int v) { access(); val = v; calc(); } ",
      "\tfriend void link(sn x, sn y, bool force = 0) { ",
      "\t\tassert(!connected(x,y)); ",
      "\t\tif (force) y->makeRoot(); // make x par of y",
      "\t\telse { y->access(); assert(!y->c[0]); }",
      "\t\tx->access(); setLink(y,x,0); y->calc();",
      "\t}",
      "\tfriend void cut(sn y) { // cut y from its parent",
      "\t\ty->access(); assert(y->c[0]);",
      "\t\ty->c[0]->p = NULL; y->c[0] = NULL; y->calc(); }",
      "\tfriend void cut(sn x, sn y) { // if x, y adj in tree",
      "\t\tx->makeRoot(); y->access(); ",
      "\t\tassert(y->c[0] == x && !x->c[0] && !x->c[1]); cut(y); }",
      "};",
      "sn LCT[MX];",
      "",
      "//////// THE APPLICANT SOLUTION",
      "void setNex(sn a, sn b) { // set f[a] = b",
      "\tif (connected(a,b)) a->extra = b;",
      "\telse link(b,a); }",
      "void delNex(sn a) { // set f[a] = NULL",
      "\tauto t = a->getRoot();",
      "\tif (t == a) { t->extra = NULL; return; }",
      "\tcut(a); assert(t->extra);",
      "\tif (!connected(t,t->extra)) ",
      "\t\tlink(t->extra,t), t->extra = NULL; ",
      "}",
      "sn getPar(sn a, int b) { // get f^b[a]",
      "\tint d = a->distRoot(); if (b <= d) return a->getPar(b);",
      "\tb -= d+1; auto r = a->getRoot()->extra; assert(r);",
      "\td = r->distRoot()+1; return r->getPar(b%d);",
      "}"
    ],
    "description": "Link-Cut Tree. Given a function \\$f(1\\ldots N)\\to 1\\ldots N,\\$ ,  * evaluates \\$f^b(a)\\$ for any \\$a,b.\\$ \\texttt{sz} is for path queries; ,  * \\texttt{sub}, \\texttt{vsub} are for subtree queries. \\texttt{x->access()} ,  * brings \\texttt{x} to the top and propagates it; its left subtree will be ,  * the path from \\texttt{x} to the root and its right subtree will be empty. ,  * Then \\texttt{sub} will be the number of nodes in the connected component,  * of \\texttt{x} and \\texttt{vsub} will be the number of nodes under \\texttt{x}.,  * Use \\texttt{makeRoot} for arbitrary path queries., * Time: O(\\log N), * Usage: FOR(i,1,N+1)LCT[i]=new snode(i); link(LCT[1],LCT[2],1);, *"
  },
  "MaxClique": {
    "prefix":["benq_MaxClique"],
    "body": [
      "/**",
      " * Description: Quickly finds a maximum clique of a graph (given as symmetric bitset",
      "\t* matrix; self-edges not allowed). To find maximum independent set consider complement.",
      " * Source: KACTL (added by chilli)",
      " \t* https://github.com/kth-competitive-programming/kactl/blob/master/content/graph/MaximumClique.h",
      " \t* https://en.wikipedia.org/wiki/MaxCliqueDyn_maximum_clique_algorithm",
      " * Time: Runs in about 1s for \\$n=155\\$ and worst case random graphs (\\$p=.90\\$). ",
      "\t* Faster for sparse graphs.",
      " */",
      "",
      "struct MaxClique {",
      "\tdb limit = 0.025, pk = 0; // # of steps",
      "\tstruct Vertex { int i, d=0; Vertex(int _i):i(_i){} };",
      "\ttypedef vector<Vertex> vv; vv V;",
      "\tvector<bitset<200>> e; vector<vi> C; // colors",
      "\tvi qmax,q,S,old; // max/current clique, sum # steps up to lev",
      "\tvoid init(vv& r) { // v.d -> degree",
      "\t\teach(v,r) { v.d = 0; each(j,r) v.d += e[v.i][j.i]; } ",
      "\t\tsort(all(r),[](Vertex a,Vertex b) { return a.d > b.d; });",
      "\t\tint mxD = r[0].d; F0R(i,sz(r)) r[i].d = min(i,mxD)+1;",
      "\t}",
      "\tvoid expand(vv& R, int lev = 1) {",
      "\t\tS[lev] += S[lev-1]-old[lev]; old[lev] = S[lev-1]; ",
      "\t\twhile (sz(R)) {",
      "\t\t\tif (sz(q)+R.bk.d <= sz(qmax)) return; // no larger clique",
      "\t\t\tq.pb(R.bk.i); // insert node with max col into clique",
      "\t\t\tvv T; each(v,R) if (e[R.bk.i][v.i]) T.pb({v.i});",
      "\t\t\tif (sz(T)) {",
      "\t\t\t\tif (S[lev]++/++pk < limit) init(T); // recalc degs",
      "\t\t\t\tint j = 0, mxk = 1, mnk = max(sz(qmax)-sz(q)+1,1);",
      "\t\t\t\tC[1].clear(), C[2].clear();",
      "\t\t\t\teach(v,T) {",
      "\t\t\t\t\tint k = 1; auto f = [&](int i) { return e[v.i][i]; };",
      "\t\t\t\t\twhile (any_of(all(C[k]),f)) k ++; /// while common edge ++",
      "\t\t\t\t\tif (k > mxk) mxk = k, C[mxk+1].clear(); // new set",
      "\t\t\t\t\tif (k < mnk) T[j++].i = v.i;",
      "\t\t\t\t\tC[k].pb(v.i);",
      "\t\t\t\t}",
      "\t\t\t\tif (j > 0) T[j-1].d = 0; // >=1 vert >=j part of clique",
      "\t\t\t\tFOR(k,mnk,mxk+1) each(i,C[k]) T[j].i = i, T[j++].d = k;",
      "\t\t\t\texpand(T,lev+1);",
      "\t\t\t} else if (sz(q) > sz(qmax)) qmax = q;",
      "\t\t\tq.pop_back(), R.pop_back(); // R.bk not in set",
      "\t\t}",
      "\t}",
      "\tvi solve(vector<bitset<200>> conn) { ",
      "\t\te = conn; C.rsz(sz(e)+1), S.rsz(sz(C)), old = S;",
      "\t\tF0R(i,sz(e)) V.pb({i}); ",
      "\t\tinit(V), expand(V); return qmax; ",
      "\t}",
      "};"
    ],
    "description": "Quickly finds a maximum clique of a graph (given as symmetric bitset, * matrix; self-edges not allowed). To find maximum independent set consider complement., *"
  },
  "StableRoommates": {
    "prefix":["benq_StableRoommates"],
    "body": [
      "/**",
      " * Description: Stable Roommates problem. Exits with -1 if no solution.",
      " * Time: O(N^2)",
      " * Source:",
      " \t* https://en.wikipedia.org/wiki/Stable_roommates_problem",
      " \t* probably better to check https://codeforces.com/contest/1423/submission/94783878",
      " * Verification: https://codeforces.com/contest/1423/problem/A",
      " */",
      "",
      "/**",
      " * Description: Stable Roommates problem. Exists with -1 if no solution.",
      " * Time: O(N^3) (idk if this worst case is achievable tho) Can make O(N^2) if needed ...",
      " * Source:",
      " \t* https://en.wikipedia.org/wiki/Stable_roommates_problem",
      " \t* probably better to check https://codeforces.com/contest/1423/submission/94783878",
      " * Verification: https://codeforces.com/contest/1423/problem/A",
      " */",
      "",
      "int N,A[1000][1000];",
      "bool active[1000][1000];",
      "deque<int> pref[1000];",
      "int propose[1000], proposed[1000];",
      " ",
      "void fin() { // no solution",
      "\tps(-1);",
      "\texit(0);",
      "}",
      " ",
      "void rem(int x, int y) { active[x][y] = active[y][x] = 0; }",
      " ",
      "void clip(int x) {",
      "\twhile (sz(pref[x]) && !active[x][pref[x].ft]) pref[x].pop_front();",
      "\twhile (sz(pref[x]) && !active[x][pref[x].bk]) pref[x].pop_back();",
      "\tif (!sz(pref[x])) fin();",
      "}",
      " ",
      "void ad(int x, int y) {",
      "\tassert(x != y && propose[x] == -1 && proposed[y] == -1);",
      "\tpropose[x] = y, proposed[y] = x;",
      "\twhile (1) {",
      "\t\tclip(y);",
      "\t\tif (pref[y].bk != x) rem(y,pref[y].bk);",
      "\t\telse break;",
      "\t}",
      "\tassert(pref[y].bk == x);",
      "}",
      " ",
      "int nex(int x) {",
      "\tassert(sz(pref[x]) > 1);",
      "\tclip(x); int y = pref[x].ft; pref[x].pop_front();",
      "\tclip(x); pref[x].push_front(y);",
      "\treturn proposed[pref[x][1]];",
      "}",
      " ",
      "int main() {",
      "\tsetIO(); re(N);",
      "\tif (N&1) fin();",
      "\tF0R(i,N) {",
      "\t\tF0R(j,N) if (i != j) {",
      "\t\t\tre(A[i][j]);",
      "\t\t\tpref[i].pb(j); active[i][j] = 1;",
      "\t\t}",
      "\t\tsort(all(pref[i]),[&](int x, int y) { return A[i][x] < A[i][y]; });",
      "\t}",
      "\tF0R(i,N) propose[i] = proposed[i] = -1;",
      "\tqueue<int> q; F0R(i,N) q.push(i);",
      "\twhile (sz(q)) {",
      "\t\tint x = q.ft; q.pop(); assert(propose[x] == -1);",
      "\t\twhile (1) {",
      "\t\t\tclip(x); int y = pref[x].ft, X = proposed[y];",
      "\t\t\tif (X != -1 && A[y][X] < A[y][x]) { rem(x,y); continue; }",
      "\t\t\tif (X != -1) propose[X] = -1, proposed[y] = -1, q.push(X);",
      "\t\t\tad(x,y); break;",
      "\t\t}",
      "\t}",
      "\tF0R(i,N) assert(propose[i] != -1);",
      "\tint cur = 0;",
      "\twhile (1) { // rotation elimination",
      "\t\tfor (;cur<N;++cur) {",
      "\t\t\tclip(cur); assert(proposed[cur] != -1 && pref[cur].bk == proposed[cur]);",
      "\t\t\tif (sz(pref[cur]) > 1) break;",
      "\t\t}",
      "\t\tF0R(i,N) {",
      "\t\t\tvi tmp;",
      "\t\t\teach(j,pref[i]) if (active[i][j]) tmp.pb(j);",
      "\t\t}",
      "\t\tif (cur == N) {",
      "\t\t\tF0R(i,N) {",
      "\t\t\t\tassert(proposed[propose[i]] == i);",
      "\t\t\t\tps(propose[i]+1);",
      "\t\t\t}",
      "\t\t\texit(0);",
      "\t\t}",
      "\t\tvi cyc, CYC;",
      "\t\t{",
      "\t\t\tint x = cur, y = cur;",
      "\t\t\tdo { x = nex(x), y = nex(nex(y)); } while (x != y);",
      "\t\t\tdo { cyc.pb(y); y = nex(y); } while (x != y);",
      "\t\t}",
      "\t\teach(x,cyc) { // if there exists a solution,",
      "\t\t\t// then there also exists a solution after deleting these edges",
      "\t\t\tint y = propose[x]; CYC.pb(y); assert(y != -1);",
      "\t\t\tpropose[x] = -1, proposed[y] = -1, rem(x,y);",
      "\t\t}",
      "\t\tF0R(i,sz(cyc)) ad(cyc[i],CYC[(i+1)%sz(cyc)]);",
      "\t}",
      "}"
    ],
    "description": "Stable Roommates problem. Exits with -1 if no solution., * Time: O(N^2), * Source:,  * https://en.wikipedia.org/wiki/Stable_roommates_problem,  * probably better to check https://codeforces.com/contest/1423/submission/94783878, * Verification: https://codeforces.com/contest/1423/problem/A, */,,/**, * Description: Stable Roommates problem. Exists with -1 if no solution., * Time: O(N^3) (idk if this worst case is achievable tho) Can make O(N^2) if needed ..., *"
  },
  "ThreeEdgeCC": {
    "prefix":["benq_ThreeEdgeCC"],
    "body": [
      "/**",
      " * Description: Three-Edge-Connected Components",
      " * Time: O(N+M) (+ DSU constant that can be removed)",
      " * Source: https://judge.yosupo.jp/submission/5244",
      " * Verification: https://judge.yosupo.jp/problem/three_edge_connected_components",
      " */",
      "",
      "template<int SZ> struct ThreeEdgeCC {",
      "\tvi adj[SZ]; DSU D;",
      "\tvoid ae(int a, int b) { if (a != b) adj[a].pb(b), adj[b].pb(a); } // no self-loops",
      "\tint ti,in[SZ],out[SZ],deg[SZ],low[SZ],path[SZ];",
      "\tvoid dfs(int v, int p) { // deg -> # of back-edges that cross parent edge",
      "\t\tin[v] = ++ti; ",
      "\t\tauto absorb = [&](int a, int b) { // join into same 3CC",
      "\t\t\tassert(D.unite(a,b)); deg[a] += deg[b]; };",
      "\t\teach(w,adj[v]) {",
      "\t\t\tif (w == p) { p = -1; continue; } // ignore first parent edge",
      "\t\t\tif (in[w]) { // visited",
      "\t\t\t\tif (in[w] < in[v]) deg[v] ++, ckmin(low[v],in[w]); // above v",
      "\t\t\t\telse {",
      "\t\t\t\t\tdeg[v] --; int& u = path[v];",
      "\t\t\t\t\tfor (;u!=-1&&in[u]<=in[w]&&in[w]<=out[u]; u=path[u])",
      "\t\t\t\t\t\tabsorb(v,u); // paths from v to u, u to w, edge from w to v",
      "\t\t\t\t}",
      "\t\t\t\tcontinue;",
      "\t\t\t}",
      "\t\t\tdfs(w,v);",
      "\t\t\tif (path[w] == -1 && deg[w] <= 1) { // <= 1 back-edge goes over w?",
      "\t\t\t\tdeg[v] += deg[w], ckmin(low[v],low[w]);",
      "\t\t\t\tcontinue; }",
      "\t\t\tif (!deg[w]) w = path[w];",
      "\t\t\tif (ckmin(low[v],low[w])) swap(w,path[v]);",
      "\t\t\tfor (;w != -1; w = path[w]) absorb(v,w);",
      "\t\t}",
      "\t\tout[v] = ti;",
      "\t}",
      "\tvector<vi> calc(int N) {",
      "\t\tD.init(N); ti = 0;",
      "\t\tF0R(i,N) {",
      "\t\t\tin[i] = out[i] = deg[i] = 0;",
      "\t\t\tlow[i] = MOD; path[i] = -1;",
      "\t\t}",
      "\t\tF0R(i,N) if (!in[i]) dfs(i,-1);",
      "\t\tvi res[N]; F0R(i,N) res[D.get(i)].pb(i);",
      "\t\tvector<vi> ans; F0R(i,N) if (sz(res[i])) ans.pb(res[i]);",
      "\t\treturn ans;",
      "\t}",
      "};"
    ],
    "description": "Three-Edge-Connected Components, * Time: O(N+M) (+ DSU constant that can be removed), *"
  },
  "TreeDecomp2": {
    "prefix":["benq_TreeDecomp2"],
    "body": [
      "/**",
      " * Description: Tree decomposition of width 2. Just keep removing ",
      " \t* verts with degree at most 2.",
      " * Time: O((N+M)\\log N)",
      " * Source: ",
      " \t* https://chaoxuprime.com/posts/2015-04-10-treewidth-2.html",
      " \t* https://github.com/yosupo06/library-checker-problems/blob/438f473c1a5eb22de1d595fc0486c1e3d78e3efe/graph/tree_decomposition_width_2/sol/correct.cpp",
      " * Verifcation: https://judge.yosupo.jp/problem/tree_decomposition_width_2",
      " */",
      "",
      "int N,M;",
      "str tmp;",
      "set<int> adj[MX];",
      "vector<vi> seq;",
      "bool done[MX];",
      "",
      "int main() {",
      "\tsetIO(); re(tmp,tmp,N,M);",
      "\tF0R(i,M) {",
      "\t\tint u,v; re(u,v);",
      "\t\tadj[u].insert(v), adj[v].insert(u);",
      "\t}",
      "\tqueue<int> q; FOR(i,1,N+1) q.push(i);",
      "\twhile (sz(q)) {",
      "\t\tint x = q.ft; q.pop(); ",
      "\t\tif (sz(adj[x]) > 2 || done[x]) continue;",
      "\t\tdone[x] = 1;",
      "\t\teach(t,adj[x]) adj[t].erase(x);",
      "\t\tif (sz(adj[x]) == 0) {",
      "\t\t\tseq.pb({0,x,-1,-1});",
      "\t\t} else if (sz(adj[x]) == 1) {",
      "\t\t\tint u = *begin(adj[x]);",
      "\t\t\tseq.pb({1,x,u,-1});",
      "\t\t\tq.push(u);",
      "\t\t} else if (sz(adj[x]) == 2) {",
      "\t\t\tint u = *begin(adj[x]);",
      "\t\t\tint v = *adj[x].rbegin();",
      "\t\t\tseq.pb({2,x,u,v});",
      "\t\t\tadj[u].insert(v), adj[v].insert(u);",
      "\t\t\tq.push(u), q.push(v);",
      "\t\t}",
      "\t}",
      "\tif (sz(seq) != N) { ps(-1); exit(0); }",
      "\treverse(all(seq));",
      "\tint id = -1;",
      "\tvi par(N+1), vert(N+1);",
      "\tvector<vi> bag(N);",
      "\tmap<pi,int> edge;",
      "\teach(t,seq) {",
      "\t\tint v = t[1];",
      "\t\tauto ad = [&](int a, int b, int c) {",
      "\t\t\tif (a > b) swap(a,b);",
      "\t\t\tedge[{a,b}] = c;",
      "\t\t};",
      "\t\tid ++;",
      "\t\tif (t[0] == 0) {",
      "\t\t\tbag[id] = {v};",
      "\t\t\tpar[id] = id-1;",
      "\t\t} else if (t[0] == 1) {",
      "\t\t\tbag[id] = {t[2],v};",
      "\t\t\tpar[id] = vert[t[2]];",
      "\t\t\tad(t[2],v,id);",
      "\t\t} else if (t[0] == 2) {",
      "\t\t\tpi p = {t[2],t[3]}; if (p.f > p.s) swap(p.f,p.s);",
      "\t\t\tbag[id] = {p.f,p.s,v};",
      "\t\t\tpar[id] = edge[p];",
      "\t\t\tad(p.f,p.s,id); ad(p.f,t[1],id); ad(p.s,t[1],id);",
      "\t\t}",
      "\t\tvert[t[1]] = id;",
      "\t}",
      "\tps(\"s\",\"td\",N,2,N);",
      "\tF0R(i,N) {",
      "\t\tpr(\"b \",i+1);",
      "\t\teach(t,bag[i]) pr(' ',t);",
      "\t\tps();",
      "\t}",
      "\tFOR(i,1,N) ps(par[i]+1,i+1);",
      "}"
    ],
    "description": "Tree decomposition of width 2. Just keep removing ,  * verts with degree at most 2., * Time: O((N+M)\\log N), *"
  },
  "BellmanFord": {
    "prefix":["benq_BellmanFord"],
    "body": [
      "/**",
      " * Description: Shortest Path w/ negative edge weights",
      "    * Can be useful with linear programming",
      "    * Constraints of the form x_i-x_j<k",
      " * Source: Own",
      " * Verification: ",
      "    * https://open.kattis.com/problems/shortestpath3",
      "    * https://probgate.org/viewproblem.php?pid=378",
      " */",
      "",
      "template<int SZ> struct BellmanFord {",
      "    int n;",
      "    vi adj[SZ];",
      "    vector<pair<pi,int>> ed;",
      "    void ae(int u, int v, int w) { ",
      "        adj[u].pb(v), ed.pb({{u,v},w}); }",
      "    ll dist[SZ];",
      "    void genBad(int x) { ",
      "        // if x is reachable from negative cycle",
      "        // -> update dists of all vertices which x can go to",
      "        if (dist[x] == -INF) return;",
      "        dist[x] = -INF; ",
      "        each(t,adj[x]) genBad(t);",
      "    }",
      "    void init(int _n, int s) {",
      "        n = _n; F0R(i,n) dist[i] = INF; ",
      "        dist[s] = 0;",
      "        F0R(i,n) each(a,ed) if (dist[a.f.f] < INF)",
      "            ckmin(dist[a.f.s],dist[a.f.f]+a.s);",
      "        each(a,ed) if (dist[a.f.f] < INF ",
      "                    && dist[a.f.s] > dist[a.f.f]+a.s) ",
      "            genBad(a.f.s);",
      "    }",
      "};"
    ],
    "description": "Shortest Path w/ negative edge weights,    * Can be useful with linear programming,    * Constraints of the form x_i-x_j<k, *"
  },
  "Dijkstra": {
    "prefix":["benq_Dijkstra"],
    "body": [
      "/**",
      " * Description: shortest path",
      " * Source: own",
      " * Verification: https://open.kattis.com/problems/shortestpath1",
      " */",
      "",
      "template<class C, bool directed> struct Dijkstra {",
      "\tint SZ; V<C> dist; ",
      "\tV<V<pair<int,C>>> adj;",
      "\tvoid init(int _SZ) { SZ = _SZ; adj.clear(); adj.rsz(SZ); }",
      "\tvoid ae(int u, int v, C cost) {",
      "\t\tadj[u].pb({v,cost}); if (!directed) adj[v].pb({u,cost}); }",
      "\tvoid gen(int st) {",
      "\t\tdist.assign(SZ,numeric_limits<C>::max());",
      "\t\tusing T = pair<C,int>; pqg<T> pq; ",
      "\t\tauto ad = [&](int a, C b) {",
      "\t\t\tif (dist[a] <= b) return;",
      "\t\t\tpq.push({dist[a] = b,a});",
      "\t\t}; ad(st,0);",
      "\t\twhile (sz(pq)) {",
      "\t\t\tT x = pq.top(); pq.pop(); if (dist[x.s] < x.f) continue;",
      "\t\t\teach(y,adj[x.s]) ad(y.f,x.f+y.s);",
      "\t\t}",
      "\t}",
      "};"
    ],
    "description": "shortest path, *"
  },
  "DirectedCycle": {
    "prefix":["benq_DirectedCycle"],
    "body": [
      "/**",
      " * Description: stack",
      " * Source: https://www.geeksforgeeks.org/detect-cycle-in-a-graph/",
      " * Verification: VT HSPC 2019 D",
      " */",
      "",
      "template<int SZ> struct DirCyc {",
      "\tvi adj[SZ], st, cyc; vector<bool> inSt, vis; ",
      "\tvoid dfs(int x) {",
      "\t\tst.pb(x); inSt[x] = vis[x] = 1;",
      "\t\teach(i,adj[x]) {",
      "\t\t\tif (inSt[i]) cyc = {find(all(st),i),end(st)};",
      "\t\t\telse if (!vis[i]) dfs(i); ",
      "\t\t\tif (sz(cyc)) return;",
      "\t\t}",
      "\t\tst.pop_back(); inSt[x] = 0;",
      "\t}",
      "\tvi init(int N) {",
      "\t\tinSt.rsz(N), vis.rsz(N); ",
      "\t\tF0R(i,N) if (!vis[i] && !sz(cyc)) dfs(i);",
      "\t\treturn cyc;",
      "\t}",
      "};"
    ],
    "description": "stack, *"
  },
  "FloydWarshall": {
    "prefix":["benq_FloydWarshall"],
    "body": [
      "/**",
      " * Description: All-Pairs Shortest Path",
      " * Source: KACTL",
      " * Verification: ",
      "    * https://open.kattis.com/problems/allpairspath",
      "    * https://cses.fi/problemset/task/1672/",
      " */",
      "",
      "void floydWarshall(vector<vl>& m) {",
      "    int n = sz(m);",
      "    F0R(i,n) ckmin(m[i][i], 0LL);",
      "    F0R(k,n) F0R(i,n) F0R(j,n)",
      "        if (m[i][k] != INF && m[k][j] != INF) {",
      "            auto newDist = max(m[i][k]+m[k][j],-INF);",
      "            ckmin(m[i][j],newDist);",
      "        }",
      "    F0R(k,n) if (m[k][k] < 0) F0R(i,n) F0R(j,n)",
      "        if (m[i][k] != INF && m[k][j] != INF) m[i][j] = -INF;",
      "}"
    ],
    "description": "All-Pairs Shortest Path, *"
  },
  "GridBFS": {
    "prefix":["benq_GridBFS"],
    "body": [
      "/**",
      " * Description: BFS through grid with fixed xdir and ydir arrays",
      " * Source: Own",
      " */",
      "",
      "const int xdir[4] = {0,1,0,-1}, ydir[4] = {1,0,-1,0};",
      "int dist[21][21];",
      "",
      "bool valid(pi y) {",
      "\treturn !(y.f < 0 || y.f > 20 || y.s < 0 || y.s > 20); // this point is outside of grid",
      "}",
      "",
      "void bfs() {",
      "\tF0R(i,21) F0R(j,21) dist[i][j] = MOD;",
      "\tdist[10][10] = 0; ",
      "",
      "\tqueue<pi> todo; todo.push({10,10}); // initialize queue, distances",
      "\twhile (sz(todo)) {",
      "\t\tpi x = todo.front(); todo.pop(); // pop point from queue",
      "\t\tF0R(i,4) { ",
      "\t\t\tpi y = {x.f+xdir[i],x.s+ydir[i]};",
      "\t\t\tif (!valid(y)) continue;",
      "\t\t\tif (dist[y.f][y.s] == MOD) { // test whether point has been visited or not",
      "\t\t\t    dist[y.f][y.s] = dist[x.f][x.s]+1;",
      "\t\t\t    todo.push(y); // push point to queue",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\t",
      "    assert(dist[4][5] == 11);",
      "}"
    ],
    "description": "BFS through grid with fixed xdir and ydir arrays, *"
  },
  "NegativeCycle": {
    "prefix":["benq_NegativeCycle"],
    "body": [
      "/**",
      " * Description: use Bellman-Ford (make sure no underflow)",
      " * Source: https://cp-algorithms.com/graph/finding-negative-cycle-in-graph.html",
      " * Verification: https://cses.fi/problemset/task/1197/",
      " */",
      "",
      "vi negCyc(int n, vector<pair<pi,int>> ed) {",
      "\tvl d(n); vi p(n); int x = -1;",
      "\tF0R(i,n) {",
      "\t\tx = -1; each(t,ed) if (ckmin(d[t.f.s],d[t.f.f]+t.s))",
      "\t\t\tp[t.f.s] = t.f.f, x = t.f.s;",
      "\t\tif (x == -1) return {};",
      "\t}",
      "\tF0R(i,n) x = p[x]; // enter cycle",
      "\tvi cyc = {x}; while (p[cyc.bk] != x) cyc.pb(p[cyc.bk]);",
      "\treverse(all(cyc)); return cyc;",
      "}",
      "",
      "/**",
      "Explanation:",
      "",
      "If we follow the links back from t.f.s then we must always enter a cycle. ",
      "Otherwise, this would contradict the assumption that there exists a shorter",
      "path to t.f.s when considering paths of arbitrary length than those of ",
      "length at most n-1. The sum of the edge weights along this path is",
      "non-positive, and it can't be zero because then it would have no origin ...",
      "*/"
    ],
    "description": "use Bellman-Ford (make sure no underflow), *"
  },
  "TopoSort": {
    "prefix":["benq_TopoSort"],
    "body": [
      "/**",
      " * Description: sorts vertices such that if there exists an edge x->y, then x goes before y",
      " * Source: KACTL",
      " * Verification: https://open.kattis.com/problems/quantumsuperposition",
      " */",
      "",
      "struct TopoSort {",
      "\tint N; vi in, res;",
      "\tV<vi> adj;",
      "\tvoid init(int _N) { N = _N; in.rsz(N); adj.rsz(N); }",
      "\tvoid ae(int x, int y) { adj[x].pb(y), in[y] ++; }",
      "\tbool sort() {",
      "\t\tqueue<int> todo; ",
      "\t\tF0R(i,N) if (!in[i]) todo.push(i);",
      "\t\twhile (sz(todo)) {",
      "\t\t\tint x = todo.ft; todo.pop(); res.pb(x);",
      "\t\t\teach(i,adj[x]) if (!(--in[i])) todo.push(i);",
      "\t\t}",
      "\t\treturn sz(res) == N;",
      "\t}",
      "};"
    ],
    "description": "sorts vertices such that if there exists an edge x->y, then x goes before y, *"
  },
  "TreeTour": {
    "prefix":["benq_TreeTour"],
    "body": [
      "/**",
      " * Description: Subtree corresponding to \\texttt{x} -> range \\texttt{[st[x],en[x]]}",
      " * Source: Own",
      " */",
      "",
      "template<int SZ> struct TreeTour {",
      "\tint st[SZ], en[SZ], par[SZ];",
      "\tvi adj[SZ];",
      "\tvoid ae(int a, int b) { adj[a].pb(b), adj[b].pb(a); }",
      "\tvoid dfs(int x) {",
      "\t\tstatic int t = 0; st[x] = t++;",
      "\t\teach(y,adj[x]) if (y != par[x]) {",
      "\t\t\tpar[y] = x; dfs(y); }",
      "\t\ten[x] = t-1;",
      "\t}\t",
      "\tvoid init() { par[1] = 0; dfs(1); }",
      "};",
      "",
      "void tourExample() {",
      "\tTreeTour<4> T;",
      "\tT.ae(1,2); T.ae(1,3); T.init();",
      "\tFOR(i,1,4) ps(i,T.st[i],T.en[i]); ",
      "\t// 1 0 2, 2 1 1, 3 2 2",
      "}"
    ],
    "description": "Subtree corresponding to \\texttt{x} -> range \\texttt{[st[x],en[x]]}, *"
  },
  "BCC": {
    "prefix":["benq_BCC"],
    "body": [
      "/**",
      " * Description: Biconnected components of edges. Removing any vertex in BCC",
      " \t* doesn't disconnect it. To get block-cut tree, create a bipartite graph",
      " \t* with the original vertices on the left and a vertex for each BCC on the right. ",
      " \t* Draw edge \\$u\\leftrightarrow v\\$ if \\$u\\$ is contained within the BCC for \\$v\\$.",
      " \t* Self-loops are not included in any BCC while BCCS of size 1 represent",
      " \t* bridges.",
      " * Time: O(N+M)",
      " * Source: GeeksForGeeks (corrected)",
      " * Verification: ",
      " \t* USACO December 2017, Push a Box -> https://pastebin.com/yUWuzTH8",
      " \t* https://cses.fi/problemset/task/1705/",
      " */",
      "",
      "struct BCC {",
      "\tV<vpi> adj; vpi ed; ",
      "\tV<vi> comps, vertSets; // edges for each bcc",
      "\tint N, ti = 0; vi disc, st; ",
      "\tvoid init(int _N) { N = _N; disc.rsz(N), adj.rsz(N); }",
      "\tvoid ae(int x, int y) { ",
      "\t\tadj[x].eb(y,sz(ed)), adj[y].eb(x,sz(ed)), ed.eb(x,y); }",
      "\tint dfs(int x, int p = -1) { // return lowest disc",
      "\t\tint low = disc[x] = ++ti;",
      "\t\teach(e,adj[x]) if (e.s != p) {",
      "\t\t\tif (!disc[e.f]) {",
      "\t\t\t\tst.pb(e.s); // disc[x] < LOW -> bridge",
      "\t\t\t\tint LOW = dfs(e.f,e.s); ckmin(low,LOW); ",
      "\t\t\t\tif (disc[x] <= LOW) { // get edges in bcc",
      "\t\t\t\t\tcomps.eb(); vi& tmp = comps.bk; // new bcc",
      "\t\t\t\t\tfor (int y = -1; y != e.s; )",
      "\t\t\t\t\t\ttmp.pb(y = st.bk), st.pop_back();",
      "\t\t\t\t}",
      "\t\t\t} else if (disc[e.f] < disc[x]) // back-edge",
      "\t\t\t\tckmin(low,disc[e.f]), st.pb(e.s);",
      "\t\t}",
      "\t\treturn low;",
      "\t}",
      "\tvoid gen() { ",
      "\t\tF0R(i,N) if (!disc[i]) dfs(i);  ",
      "\t\tvb in(N);",
      "\t\teach(c,comps) { // vertices contained within each BCC",
      "\t\t\tvertSets.eb(); // so you can easily create block cut tree",
      "\t\t\tauto ad = [&](int x) { if (!in[x]) in[x] = 1, vertSets.bk.pb(x); };",
      "\t\t\teach(e,c) ad(ed[e].f), ad(ed[e].s);",
      "\t\t\teach(e,c) in[ed[e].f] = in[ed[e].s] = 0;",
      "\t\t}",
      "\t}",
      "};"
    ],
    "description": "Biconnected components of edges. Removing any vertex in BCC,  * doesn't disconnect it. To get block-cut tree, create a bipartite graph,  * with the original vertices on the left and a vertex for each BCC on the right. ,  * Draw edge \\$u\\leftrightarrow v\\$ if \\$u\\$ is contained within the BCC for \\$v\\$.,  * Self-loops are not included in any BCC while BCCS of size 1 represent,  * bridges., * Time: O(N+M), *"
  },
  "EulerPath": {
    "prefix":["benq_EulerPath"],
    "body": [
      "/**",
      " * Description: Eulerian path starting at \\texttt{src} if it exists, ",
      "     * visits all edges exactly once. Works for both directed and ",
      "     * undirected. Returns vector of {vertex,label of edge to vertex}.",
      "     * The second element of the first pair is always \\$-1\\$.",
      " * Time: O(N+M)",
      " * Source: USACO Training, MIT ICPC Notebook",
      " * Verification:",
      "    * directed -> https://open.kattis.com/problems/eulerianpath",
      "    * undirected -> USACO Training 3.3, Riding the Fences",
      " */",
      "",
      "template<bool directed> struct Euler {",
      "    int N; V<vpi> adj; V<vpi::iterator> its; vb used;",
      "    void init(int _N) { N = _N; adj.rsz(N); }",
      "    void ae(int a, int b) {",
      "        int M = sz(used); used.pb(0); ",
      "        adj[a].eb(b,M); if (!directed) adj[b].eb(a,M); }",
      "    vpi solve(int src = 0) { ",
      "        its.rsz(N); F0R(i,N) its[i] = begin(adj[i]);",
      "        vpi ans, s{{src,-1}}; // {{vert, prev vert}, edge label}",
      "        int lst = -1; // ans is generated in reverse order",
      "        while (sz(s)) { ",
      "            int x = s.bk.f; auto& it = its[x], en = end(adj[x]);",
      "            while (it != en && used[it->s]) it ++;",
      "            if (it == en) { // no more edges out of vertex",
      "                if (lst != -1 && lst != x) return {}; // not a path, no tour exists",
      "                ans.pb(s.bk); s.pop_back(); if (sz(s)) lst = s.bk.f;",
      "            } else s.pb(*it), used[it->s] = 1;",
      "        }",
      "        if (sz(ans) != sz(used)+1) return {}; // not all edges used",
      "        reverse(all(ans)); return ans;",
      "    }",
      "};"
    ],
    "description": "Eulerian path starting at \\texttt{src} if it exists, ,     * visits all edges exactly once. Works for both directed and ,     * undirected. Returns vector of {vertex,label of edge to vertex}.,     * The second element of the first pair is always \\$-1\\$., * Time: O(N+M), *"
  },
  "MaximalCliques": {
    "prefix":["benq_MaximalCliques"],
    "body": [
      "/**",
      " * Description: Used only once. Finds all maximal cliques.",
      " * Time: O(3^{N/3})",
      " * Source: KACTL",
      " * Verification: BOSPRE 2016 gaudy",
      " */",
      "",
      "typedef bitset<128> B; B adj[128];",
      "int N;",
      "// possibly in clique, not in clique, in clique",
      "void cliques(B P = ~B(), B X={}, B R={}) { ",
      "\tif (!P.any()) { ",
      "\t\tif (!X.any()) // do smth with R",
      "\t\treturn; ",
      "\t}",
      "\tint q = (P|X)._Find_first();",
      "\t// clique must contain q or non-neighbor of q",
      "\tB cands = P&~adj[q]; ",
      "\tF0R(i,N) if (cands[i]) {",
      "\t\tR[i] = 1; cliques(P&adj[i],X&adj[i],R);",
      "\t\tR[i] = P[i] = 0; X[i] = 1;",
      "\t}",
      "}"
    ],
    "description": "Used only once. Finds all maximal cliques., * Time: O(3^{N/3}), *"
  },
  "SCCK": {
    "prefix":["benq_SCCK"],
    "body": [
      "/**",
      " * Description: Kosaraju's Algorithm, DFS twice to generate ",
      " \t* strongly connected components in topological order. \\$a,b\\$",
      " \t* in same component if both \\$a\\to b\\$ and \\$b\\to a\\$ exist.",
      " * Time: O(N+M)",
      " * Source: Wikipedia",
      " * Verification: POI 8 peaceful commission",
      " */",
      "",
      "struct SCC {",
      "\tint N; vector<vi> adj, radj;",
      "\tvi todo, comp, comps; vector<bool> vis;",
      "\tvoid init(int _N) { N = _N; ",
      "\t\tadj.rsz(N), radj.rsz(N), comp = vi(N,-1), vis.rsz(N); }",
      "\tvoid ae(int x, int y) { adj[x].pb(y), radj[y].pb(x); }",
      "\tvoid dfs(int x) {",
      "\t\tvis[x] = 1; each(y,adj[x]) if (!vis[y]) dfs(y);",
      "\t\ttodo.pb(x); }",
      "\tvoid dfs2(int x, int v) {",
      "\t\tcomp[x] = v; ",
      "\t\teach(y,radj[x]) if (comp[y] == -1) dfs2(y,v); }",
      "\tvoid gen() { // fills allComp",
      "\t\tF0R(i,N) if (!vis[i]) dfs(i);",
      "\t\treverse(all(todo)); ",
      "\t\teach(x,todo) if (comp[x] == -1) dfs2(x,x), comps.pb(x);",
      "\t}",
      "};"
    ],
    "description": "Kosaraju's Algorithm, DFS twice to generate ,  * strongly connected components in topological order. \\$a,b\\$,  * in same component if both \\$a\\to b\\$ and \\$b\\to a\\$ exist., * Time: O(N+M), *"
  },
  "SCCT": {
    "prefix":["benq_SCCT"],
    "body": [
      "/**",
      " * Description: Tarjan's, DFS once to generate ",
      " \t* strongly connected components in topological order. \\$a,b\\$",
      " \t* in same component if both \\$a\\to b\\$ and \\$b\\to a\\$ exist.",
      " \t* Uses less memory than Kosaraju b/c doesn't store reverse edges.",
      " * Time: O(N+M)",
      " * Source: KACTL",
      " \t* https://github.com/kth-competitive-programming/kactl/blob/master/content/graph/SCC.h",
      " * Verification: https://cses.fi/problemset/task/1686/",
      " */",
      "",
      "struct SCC {",
      "\tint N, ti = 0; vector<vi> adj;",
      "\tvi disc, comp, st, comps;",
      "\tvoid init(int _N) { N = _N; adj.rsz(N), disc.rsz(N), comp = vi(N,-1); }",
      "\tvoid ae(int x, int y) { adj[x].pb(y); }",
      "\tint dfs(int x) {",
      "\t\tint low = disc[x] = ++ti; st.pb(x); // disc[y] != 0 -> in stack",
      "\t\teach(y,adj[x]) if (comp[y] == -1) ckmin(low,disc[y]?:dfs(y)); ",
      "\t\tif (low == disc[x]) { // make new SCC, pop off stack until you find x",
      "\t\t\tcomps.pb(x); for (int y = -1; y != x;) ",
      "\t\t\t\tcomp[y = st.bk] = x, st.pop_back();",
      "\t\t}",
      "\t\treturn low;",
      "\t}",
      "\tvoid gen() {",
      "\t\tF0R(i,N) if (!disc[i]) dfs(i);",
      "\t\treverse(all(comps));",
      "\t}",
      "};"
    ],
    "description": "Tarjan's, DFS once to generate ,  * strongly connected components in topological order. \\$a,b\\$,  * in same component if both \\$a\\to b\\$ and \\$b\\to a\\$ exist.,  * Uses less memory than Kosaraju b/c doesn't store reverse edges., * Time: O(N+M), *"
  },
  "TwoSAT": {
    "prefix":["benq_TwoSAT"],
    "body": [
      "/**",
      " * Description: Calculates a valid assignment to boolean variables a, b, c,... ",
      " \t* to a 2-SAT problem, so that an expression of the type ",
      " \t* \\$(a\\|\\|b)\\&\\&(!a\\|\\|c)\\&\\&(d\\|\\|!b)\\&\\&...\\$ becomes true, ",
      " \t* or reports that it is unsatisfiable.",
      " \t* Negated variables are represented by bit-inversions (\\texttt{\\tilde{}x}).",
      " * Usage:",
      "\t* TwoSat ts;",
      "\t* ts.either(0, \\tilde3); // Var 0 is true or var 3 is false",
      "\t* ts.setVal(2); // Var 2 is true",
      "\t* ts.atMostOne({0,\\tilde1,2}); // <= 1 of vars 0, \\tilde1 and 2 are true",
      "\t* ts.solve(N); // Returns true iff it is solvable",
      "\t* ts.ans[0..N-1] holds the assigned values to the vars",
      " * Source: KACTL",
      " * Verification: https://codeforces.com/contest/1007/problem/D",
      " \t* https://cses.fi/problemset/task/1684/",
      " */",
      "",
      "#include \"SCC (12.1).h\"",
      "",
      "struct TwoSAT {",
      "\tint N; SCC S; vector<bool> ans;",
      "\tvoid init(int _N) { N = _N; S.init(2*N); ans.rsz(N); }",
      "\tint addVar() { return N++; }",
      "\tvoid either(int x, int y) { ",
      "\t\tx = max(2*x,-1-2*x), y = max(2*y,-1-2*y);",
      "\t\tS.ae(x^1,y); S.ae(y^1,x); }",
      "\tvoid implies(int x, int y) { either(~x,y); }",
      "\tvoid must(int x) { either(x,x); }",
      "\tvoid atMostOne(vi li) {",
      "\t\tif (sz(li) <= 1) return;",
      "\t\tint cur = ~li[0];",
      "\t\tFOR(i,2,sz(li)) {",
      "\t\t\tint next = addVar();",
      "\t\t\teither(cur,~li[i]); either(cur,next);",
      "\t\t\teither(~li[i],next); cur = ~next;",
      "\t\t}",
      "\t\teither(cur,~li[1]);",
      "\t}",
      "\tbool solve(int _N = -1) {",
      "\t\tif (_N != -1) N = _N, S.init(2*N);",
      "\t\tS.gen(); reverse(all(S.comps)); // reverse topological order",
      "\t\tfor (int i = 0; i < 2*N; i += 2) ",
      "\t\t\tif (S.comp[i] == S.comp[i^1]) return 0;",
      "\t\tvi tmp(2*N); each(i,S.comps) if (!tmp[i]) ",
      "\t\t\ttmp[i] = 1, tmp[S.comp[i^1]] = -1;",
      "\t\tF0R(i,N) if (tmp[S.comp[2*i]] == 1) ans[i] = 1;",
      "\t\treturn 1;",
      "\t}",
      "};"
    ],
    "description": "Calculates a valid assignment to boolean variables a, b, c,... ,  * to a 2-SAT problem, so that an expression of the type ,  * \\$(a\\|\\|b)\\&\\&(!a\\|\\|c)\\&\\&(d\\|\\|!b)\\&\\&...\\$ becomes true, ,  * or reports that it is unsatisfiable.,  * Negated variables are represented by bit-inversions (\\texttt{\\tilde{}x})., * Usage:, * TwoSat ts;, * ts.either(0, \\tilde3); // Var 0 is true or var 3 is false, * ts.setVal(2); // Var 2 is true, * ts.atMostOne({0,\\tilde1,2}); // <= 1 of vars 0, \\tilde1 and 2 are true, * ts.solve(N); // Returns true iff it is solvable, * ts.ans[0..N-1] holds the assigned values to the vars, *"
  },
  "DSU": {
    "prefix":["benq_DSU"],
    "body": [
      "/**",
      " * Description: Disjoint Set Union with path compression",
      " \t* and union by size. Add edges and test connectivity. ",
      " \t* Use for Kruskal's or Boruvka's minimum spanning tree.",
      " * Time: O(\\alpha(N))",
      " * Source: CSAcademy, KACTL",
      " * Verification: *",
      " */",
      "",
      "struct DSU {",
      "\tvi e; void init(int N) { e = vi(N,-1); }",
      "\tint get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); } ",
      "\tbool sameSet(int a, int b) { return get(a) == get(b); }",
      "\tint size(int x) { return -e[get(x)]; }",
      "\tbool unite(int x, int y) { // union by size",
      "\t\tx = get(x), y = get(y); if (x == y) return 0;",
      "\t\tif (e[x] > e[y]) swap(x,y);",
      "\t\te[x] += e[y]; e[y] = x; return 1;",
      "\t}",
      "};",
      "",
      "/**template<class T> T kruskal(int N, vector<pair<T,pi>> ed) {",
      "\tsort(all(ed));",
      "\tT ans = 0; DSU D; D.init(N); // edges that unite are in MST",
      "\teach(a,ed) if (D.unite(a.s.f,a.s.s)) ans += a.f; ",
      "\treturn ans;",
      "}*/"
    ],
    "description": "Disjoint Set Union with path compression,  * and union by size. Add edges and test connectivity. ,  * Use for Kruskal's or Boruvka's minimum spanning tree., * Time: O(\\alpha(N)), *"
  },
  "DSUrb": {
    "prefix":["benq_DSUrb"],
    "body": [
      "/**",
      " * Description: Disjoint Set Union with Rollback",
      " * Source: see DSU",
      " * Verification: *",
      " */",
      "",
      "struct DSUrb {",
      "\tvi e; void init(int n) { e = vi(n,-1); }",
      "\tint get(int x) { return e[x] < 0 ? x : get(e[x]); } ",
      "\tbool sameSet(int a, int b) { return get(a) == get(b); }",
      "\tint size(int x) { return -e[get(x)]; }",
      "\tvector<array<int,4>> mod;",
      "\tbool unite(int x, int y) { // union-by-rank",
      "\t\tx = get(x), y = get(y); ",
      "\t\tif (x == y) { mod.pb({-1,-1,-1,-1}); return 0; }",
      "\t\tif (e[x] > e[y]) swap(x,y);",
      "\t\tmod.pb({x,y,e[x],e[y]});",
      "\t\te[x] += e[y]; e[y] = x; return 1;",
      "\t}",
      "\tvoid rollback() {",
      "\t\tauto a = mod.bk; mod.pop_back();",
      "\t\tif (a[0] != -1) e[a[0]] = a[2], e[a[1]] = a[3];",
      "\t}",
      "};"
    ],
    "description": "Disjoint Set Union with Rollback, *"
  },
  "DynaCon": {
    "prefix":["benq_DynaCon"],
    "body": [
      "/**",
      " * Description: offline dynamic connectivity",
      " * Source: own",
      " * Verification: https://codeforces.com/contest/1140/problem/F",
      " */",
      "",
      "#include \"DSUrb (15.5).h\"",
      "",
      "template<int SZ> struct DynaCon { ",
      "\tDSUrb D; vpi seg[2*SZ];",
      "\tvoid upd(int l, int r, pi p) {\t// add edge p to all times in interval [l, r]",
      "\t\tfor (l += SZ, r += SZ+1; l < r; l /= 2, r /= 2) {",
      "\t\t\tif (l&1) seg[l++].pb(p);",
      "\t\t\tif (r&1) seg[--r].pb(p);",
      "\t\t}",
      "\t}",
      "\tvoid process(int ind) {",
      "\t\teach(t,seg[ind]) D.unite(t.f,t.s);",
      "\t\tif (ind >= SZ) {",
      "\t\t\t// do stuff with D at time ind-SZ",
      "\t\t} else process(2*ind), process(2*ind+1);",
      "\t\teach(t,seg[ind]) D.rollback();",
      "\t}",
      "};"
    ],
    "description": "offline dynamic connectivity, *"
  },
  "TwoEdgeCC": {
    "prefix":["benq_TwoEdgeCC"],
    "body": [
      "/** ",
      " * Description: 2-Edge-Connected Components",
      " * Time: O((M+N)\\log N)",
      " * Source: Own",
      " * Verification: https://judge.yosupo.jp/problem/two_edge_connected_components",
      " */",
      " ",
      "struct TwoEdgeCC {",
      "\tstruct {",
      "\t\tvi e; void init(int n) { e = vi(n,-1); }",
      "\t\tint get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); } ",
      "\t\tbool unite(int x, int y) { // set par[y] = x",
      "\t\t\tx = get(x), y = get(y); if (x == y) return 0;",
      "\t\t\te[x] += e[y]; e[y] = x; return 1;",
      "\t\t}",
      "\t} DSU;",
      "\tint N; vector<vi> adj; vi depth, par;",
      "\tvpi extra;",
      "\tvoid init(int _N) {",
      "\t\tN = _N; DSU.init(N);",
      "\t\tadj.rsz(N), depth.rsz(N), par = vi(N,-1);",
      "\t}",
      "\tvoid dfs(int x) {",
      "\t\teach(t,adj[x]) if (t != par[x]) ",
      "\t\t\tpar[t] = x, depth[t] = depth[x]+1, dfs(t);",
      "\t}",
      "\tvoid ae(int a, int b) {",
      "\t\tif (DSU.unite(a,b)) adj[a].pb(b), adj[b].pb(a); // tree edge",
      "\t\telse extra.pb({a,b});",
      "\t}",
      "\tvoid ad(int a, int b) { // OK",
      "\t\twhile (1) {",
      "\t\t\ta = DSU.get(a), b = DSU.get(b);",
      "\t\t\tif (a == b) return;",
      "\t\t\tif (depth[a] < depth[b]) swap(a,b);",
      "\t\t\tassert(par[a] != -1 && DSU.unite(par[a],a));",
      "\t\t}",
      "\t}",
      "\tvoid gen() {",
      "\t\tF0R(i,N) if (par[i] == -1) dfs(i);",
      "\t\tDSU.init(N); // again!",
      "\t\teach(t,extra) ad(t.f,t.s);",
      "\t}",
      "};"
    ],
    "description": "2-Edge-Connected Components, * Time: O((M+N)\\log N), *"
  },
  "Dinic": {
    "prefix":["benq_Dinic"],
    "body": [
      "/**",
      " * Description: Fast flow. After computing flow, edges \\$\\{u,v\\}\\$ such that ",
      "\t* \\$lev[u] \\neq 0,\\$ \\$lev[v] = 0\\$ are part of min cut.",
      "\t* Use \\texttt{reset} and \\texttt{rcap} for Gomory-Hu.",
      " * Time: \\$O(N^2M)\\$ flow, \\$O(M\\sqrt N)\\$ bipartite matching",
      " * Source: GeeksForGeeks, Chilli",
      " \t* https://codeforces.com/contest/1416/submission/94013395",
      " * Verification: RMI 2017 Day 1 Fashion",
      "\t* https://pastebin.com/VJxTvEg1",
      " */",
      "",
      "struct Dinic {",
      "\tusing F = ll; // flow type",
      "\tstruct Edge { int to, rev; F flo, cap; };",
      "\tint N; V<V<Edge>> adj;",
      "\tvoid init(int _N) { N = _N; adj.rsz(N); }",
      "\t/// void reset() { F0R(i,N) each(e,adj[i]) e.flo = 0; }",
      "\tvoid ae(int a, int b, F cap, F rcap = 0) { assert(min(cap,rcap) >= 0); ",
      "\t\tadj[a].pb({b,sz(adj[b]),0,cap});",
      "\t\tadj[b].pb({a,sz(adj[a])-1,0,rcap});",
      "\t}",
      "\tvi lev, ptr;",
      "\tbool bfs(int s, int t) { // level = shortest distance from source",
      "\t\tlev = ptr = vi(N);",
      "\t\tlev[s] = 1; queue<int> q({s});",
      "\t\twhile (sz(q)) { int u = q.ft; q.pop();",
      "\t\t\teach(e,adj[u]) if (e.flo < e.cap && !lev[e.to])",
      "\t\t\t\tq.push(e.to), lev[e.to] = lev[u]+1;",
      "\t\t}",
      "\t\treturn lev[t];",
      "\t}",
      "\tF dfs(int v, int t, F flo) {",
      "\t\tif (v == t) return flo;",
      "\t\tfor (int& i = ptr[v]; i < sz(adj[v]); i++) {",
      "\t\t\tEdge& e = adj[v][i]; F dif = e.cap-e.flo;",
      "\t\t\tif (lev[e.to]!=lev[v]+1||!dif) continue;",
      "\t\t\tif (F df = dfs(e.to,t,min(flo,dif))) { ",
      "\t\t\t\te.flo += df; adj[e.to][e.rev].flo -= df;",
      "\t\t\t\treturn df; } // saturated >=1 one edge",
      "\t\t}",
      "\t\treturn 0;",
      "\t}",
      "\tF maxFlow(int s, int t) {",
      "\t\tF tot = 0; while (bfs(s,t)) while (F df = ",
      "\t\t\tdfs(s,t,numeric_limits<F>::max())) tot += df;",
      "\t\treturn tot;",
      "\t}",
      "};"
    ],
    "description": "Fast flow. After computing flow, edges \\$\\{u,v\\}\\$ such that , * \\$lev[u] \\neq 0,\\$ \\$lev[v] = 0\\$ are part of min cut., * Use \\texttt{reset} and \\texttt{rcap} for Gomory-Hu., * Time: \\$O(N^2M)\\$ flow, \\$O(M\\sqrt N)\\$ bipartite matching, *"
  },
  "Dinic_2": {
    "prefix":["benq_Dinic_2"],
    "body": [
      "/**",
      " * Description: Fast flow. After computing flow, edges \\$\\{u,v\\}\\$ such that ",
      "\t* \\$lev[u] \\neq -1,\\$ \\$lev[v] = -1\\$ are part of min cut.",
      "\t* Use \\texttt{reset} and \\texttt{rcap} for Gomory-Hu.",
      " * Time: \\$O(N^2M)\\$ flow, \\$O(M\\sqrt N)\\$ bipartite matching",
      " * Source: GeeksForGeeks, Chilli",
      " * Verification: RMI 2017 Day 1 Fashion",
      "\t* https://pastebin.com/VJxTvEg1",
      " */",
      "",
      "struct Dinic {",
      "\tusing F = ll; // flow type",
      "\tstruct Edge { int to; F flo, cap; };",
      "\tint N; V<Edge> eds; V<vi> adj;",
      "\tvoid init(int _N) { N = _N; adj.rsz(N), cur.rsz(N); }",
      "\t/// void reset() { each(e,eds) e.flo = 0; }",
      "\tvoid ae(int u, int v, F cap, F rcap = 0) { assert(min(cap,rcap) >= 0); ",
      "\t\tadj[u].pb(sz(eds)); eds.pb({v,0,cap});",
      "\t\tadj[v].pb(sz(eds)); eds.pb({u,0,rcap});",
      "\t}",
      "\tvi lev; V<vi::iterator> cur;",
      "\tbool bfs(int s, int t) { // level = shortest distance from source",
      "\t\tlev = vi(N,-1); F0R(i,N) cur[i] = begin(adj[i]);",
      "\t\tqueue<int> q({s}); lev[s] = 0; ",
      "\t\twhile (sz(q)) { int u = q.ft; q.pop();",
      "\t\t\teach(e,adj[u]) { const Edge& E = eds[e];",
      "\t\t\t\tint v = E.to; if (lev[v] < 0 && E.flo < E.cap) ",
      "\t\t\t\t\tq.push(v), lev[v] = lev[u]+1;",
      "\t\t\t}",
      "\t\t}",
      "\t\treturn lev[t] >= 0;",
      "\t}",
      "\tF dfs(int v, int t, F flo) {",
      "\t\tif (v == t) return flo;",
      "\t\tfor (; cur[v] != end(adj[v]); cur[v]++) {",
      "\t\t\tEdge& E = eds[*cur[v]];",
      "\t\t\tif (lev[E.to]!=lev[v]+1||E.flo==E.cap) continue;",
      "\t\t\tF df = dfs(E.to,t,min(flo,E.cap-E.flo));",
      "\t\t\tif (df) { E.flo += df; eds[*cur[v]^1].flo -= df;",
      "\t\t\t\treturn df; } // saturated >=1 one edge",
      "\t\t}",
      "\t\treturn 0;",
      "\t}",
      "\tF maxFlow(int s, int t) {",
      "\t\tF tot = 0; while (bfs(s,t)) while (F df = ",
      "\t\t\tdfs(s,t,numeric_limits<F>::max())) tot += df;",
      "\t\treturn tot;",
      "\t}",
      "};"
    ],
    "description": "Fast flow. After computing flow, edges \\$\\{u,v\\}\\$ such that , * \\$lev[u] \\neq -1,\\$ \\$lev[v] = -1\\$ are part of min cut., * Use \\texttt{reset} and \\texttt{rcap} for Gomory-Hu., * Time: \\$O(N^2M)\\$ flow, \\$O(M\\sqrt N)\\$ bipartite matching, *"
  },
  "GlobalMinCut": {
    "prefix":["benq_GlobalMinCut"],
    "body": [
      "/**",
      " * Description: Used only once. Stoer-Wagner, find a global minimum cut in ",
      " \t* an undirected graph as represented by an adjacency matrix.",
      " * Time: O(N^3)",
      " * Source: Stanford Notebook, http://www.cs.tau.ac.il/~zwick/grad-algo-08/gmc.pdf",
      " \t* https://en.wikipedia.org/wiki/Stoer%E2%80%93Wagner_algorithm",
      " \t* Alternatively, use https://en.wikipedia.org/wiki/Karger%27s_algorithm",
      " * Verification: https://www.spoj.com/problems/ADABANKET/",
      " */",
      "",
      "pair<int, vi> GlobalMinCut(vector<vi> wei) {",
      "\tint N = sz(wei);",
      "\tvi par(N); iota(all(par),0);",
      "\tpair<int,vi> bes = {INT_MAX,{}};",
      "\tR0F(phase,N) {",
      "\t\tvi w = wei[0]; int lst = 0;",
      "\t\tvector<bool> add(N,1); FOR(i,1,N) if (par[i]==i) add[i]=0;",
      "\t\tF0R(i,phase) {",
      "\t\t\tint k = -1; ",
      "\t\t\tFOR(j,1,N) if (!add[j] && (k==-1 || w[j]>w[k])) k = j;",
      "\t\t\tif (i+1 == phase) {",
      "\t\t\t\tif (w[k] < bes.f) {",
      "\t\t\t\t\tbes = {w[k],{}};",
      "\t\t\t\t\tF0R(j,N) if (par[j] == k) bes.s.pb(j);",
      "\t\t\t\t}",
      "\t\t\t\tF0R(j,N)wei[lst][j]+=wei[k][j],wei[j][lst]=wei[lst][j];",
      "\t\t\t\tF0R(j,N) if (par[j] == k) par[j] = lst; // merge",
      "\t\t\t} else { // greedily add closest",
      "\t\t\t\tF0R(j,N) w[j] += wei[k][j];",
      "\t\t\t\tadd[lst = k] = 1;",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\treturn bes;",
      "}"
    ],
    "description": "Used only once. Stoer-Wagner, find a global minimum cut in ,  * an undirected graph as represented by an adjacency matrix., * Time: O(N^3), *"
  },
  "GomoryHu": {
    "prefix":["benq_GomoryHu"],
    "body": [
      "/**",
      " * Description: Returns edges of Gomory-Hu tree (second element is weight). ",
      " \t* Max flow between pair of vertices of undirected graph is given by min edge",
      "\t* weight along tree path. Uses the fact that for any \\$i,j,k,\\$",
      "\t* \\$\\lambda_{ik}\\ge \\min(\\lambda_{ij},\\lambda_{jk}),\\$ ",
      "\t* where \\$\\lambda_{ij}\\$ denotes the flow between \\$i\\$ and \\$j.\\$",
      " * Source: https://github.com/koosaga/DeobureoMinkyuParty/blob/master/teamnote.tex",
      " * Time: \\$O(N)\\$ calls to Dinic",
      " * Verification: https://codeforces.com/problemset/problem/343/E",
      " */",
      "",
      "#include \"Dinic.h\"",
      "",
      "template<int SZ> struct GomoryHu {",
      "\tvector<pair<pi,int>> ed; // add undirected edge",
      "\tvoid ae(int a, int b, int c) { ed.pb({{a,b},c}); }",
      "\tvector<pair<pi,int>> init(int N) { ",
      "\t\tvpi ret(N); Dinic<SZ> D; ",
      "\t\teach(t,ed) D.ae(t.f.f,t.f.s,t.s,t.s);",
      "\t\tFOR(i,1,N) {",
      "\t\t\tD.reset(); ret[i].s = D.maxFlow(N,i,ret[i].f);",
      "\t\t\tFOR(j,i+1,N+1) if (ret[j].f == ret[i].f ",
      "\t\t\t\t&& D.lev[j] != -1) ret[j].f = i;",
      "\t\t}",
      "\t\tvector<pair<pi,int>> res;",
      "\t\tFOR(i,1,N) res.pb({{i,ret[i].f},ret[i].s});",
      "\t\treturn res;",
      "\t}",
      "};"
    ],
    "description": "Returns edges of Gomory-Hu tree (second element is weight). ,  * Max flow between pair of vertices of undirected graph is given by min edge, * weight along tree path. Uses the fact that for any \\$i,j,k,\\$, * \\$\\lambda_{ik}\\ge \\min(\\lambda_{ij},\\lambda_{jk}),\\$ , * where \\$\\lambda_{ij}\\$ denotes the flow between \\$i\\$ and \\$j.\\$, *"
  },
  "HLPP": {
    "prefix":["benq_HLPP"],
    "body": [
      "/**",
      " * Description: Quickly calculate max flow",
      " * Source: https://gist.github.com/Chillee/ad2110fc17af453fb6fc3357a78cfd28#file-hlpp-cpp",
      " * Verification: https://www.spoj.com/problems/FASTFLOW/",
      " */",
      "",
      "template <int SZ> struct HLPP {",
      "\ttypedef ll F; // flow type",
      "\tstruct Edge { int to, rev; F f; };",
      "\tconst F INF = numeric_limits<F>::max();",
      "\t",
      "\tint N,s,t;",
      "\tvector<Edge> adj[SZ];",
      "\tvoid ae(int u, int v, F cap) {",
      "\t\tassert(cap >= 0); // don't try smth dumb",
      "\t\tEdge a{v, sz(adj[v]), cap}, b{u, sz(adj[u]), 0};",
      "\t\tadj[u].pb(a), adj[v].pb(b);",
      "\t}",
      "",
      "\tvi lst[SZ], gap[SZ];",
      "\tF excess[SZ];",
      "\tint highest, height[SZ], cnt[SZ], work;",
      "\tvoid updHeight(int v, int nh) {",
      "\t\twork++;",
      "\t\tif (height[v] != N) cnt[height[v]]--;",
      "\t\theight[v] = nh;",
      "\t\tif (nh == N) return;",
      "\t\tcnt[nh]++, highest = nh;",
      "\t\tgap[nh].pb(v);",
      "\t\tif (excess[v] > 0) lst[nh].pb(v);",
      "\t}",
      "\tvoid globalRelabel() {",
      "\t\twork = 0;",
      "\t\tF0R(i,N) height[i] = N, cnt[i] = 0;",
      "\t\tF0R(i,highest) lst[i].clear(), gap[i].clear();",
      "\t\theight[t] = 0;",
      "\t\tqueue<int> q({t});",
      "\t\twhile (sz(q)) {",
      "\t\t\tint v = q.ft; q.pop();",
      "\t\t\teach(e,adj[v])",
      "\t\t\t\tif (height[e.to] == N && adj[e.to][e.rev].f > 0)",
      "\t\t\t\t\tq.push(e.to), updHeight(e.to, height[v] + 1);",
      "\t\t\thighest = height[v];",
      "\t\t}",
      "\t}",
      "\tvoid push(int v, Edge& e) {",
      "\t\tif (excess[e.to] == 0) lst[height[e.to]].pb(e.to);",
      "\t\tF df = min(excess[v], e.f);",
      "\t\te.f -= df, adj[e.to][e.rev].f += df;",
      "\t\texcess[v] -= df, excess[e.to] += df;",
      "\t}",
      "\tvoid discharge(int v) {",
      "\t\tint nh = N;",
      "\t\teach(e,adj[v]) {",
      "\t\t\tif (e.f > 0) {",
      "\t\t\t\tif (height[v] == height[e.to] + 1) {",
      "\t\t\t\t\tpush(v, e);",
      "\t\t\t\t\tif (excess[v] <= 0) return;",
      "\t\t\t\t} else ckmin(nh,height[e.to]+1);",
      "\t\t\t}",
      "\t\t}",
      "\t\tif (cnt[height[v]] > 1) updHeight(v, nh);",
      "\t\telse {",
      "\t\t\tFOR(i,height[v],highest+1) {",
      "\t\t\t\teach(j,gap[i]) updHeight(j, N);",
      "\t\t\t\tgap[i].clear();",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\tF maxFlow(int _N, int _s, int _t) {",
      "\t\tN = _N, s = _s, t = _t; if (s == t) return -1;",
      "\t\tF0R(i,N) excess[i] = 0;",
      "\t\texcess[s] = INF, excess[t] = -INF;",
      "\t\tglobalRelabel();",
      "\t\teach(e,adj[s]) push(s,e);",
      "\t\tfor (; highest >= 0; highest--) ",
      "\t\t\twhile (sz(lst[highest])) {",
      "\t\t\t\tint v = lst[highest].bk;",
      "\t\t\t\tlst[highest].pop_back();",
      "\t\t\t\tdischarge(v);",
      "\t\t\t\tif (work > 4*N) globalRelabel();",
      "\t\t\t}",
      "\t\treturn excess[t]+INF;",
      "\t}",
      "};"
    ],
    "description": "Quickly calculate max flow, *"
  },
  "MCMF": {
    "prefix":["benq_MCMF"],
    "body": [
      "/**",
      " * Description: Minimum-cost maximum flow, assumes no negative cycles. ",
      " \t* It is possible to choose negative edge costs such that the first ",
      " \t* run of Dijkstra is slow, but this hasn't been an issue in the past. ",
      " \t* Edge weights \\$\\ge 0\\$ for every subsequent run. To get flow through ",
      " \t* original edges, assign ID's during \\texttt{ae}.",
      " * Time: Ignoring first run of Dijkstra, \\$O(FM\\log M)\\$ ",
      " \t* if caps are integers and \\$F\\$ is max flow.",
      " * Source: GeeksForGeeks",
      " \t* https://courses.csail.mit.edu/6.854/06/scribe/s12-minCostFlowAlg.pdf",
      " \t* running time is only pseudo-polynomial; see https://codeforces.com/blog/entry/70740",
      " \t* https://en.wikipedia.org/wiki/Johnson%27s_algorithm (to get non-negative weights)",
      " \t* https://codeforces.com/contest/1316/submission/72472865 ",
      " \t\t* mango_lassi, min cost circulation w/ capacity scaling",
      " * Verification: https://codeforces.com/contest/164/problem/C",
      " \t* https://codeforces.com/contest/316/problem/C2",
      " \t\t* TLEs, don't use priority queue",
      " */",
      "",
      "struct MCMF { ",
      "\tusing F = ll; using C = ll; // flow type, cost type",
      "\tstruct Edge { int to, rev; F flo, cap; C cost; };",
      "\tint N; V<C> p, dist; vpi pre; V<V<Edge>> adj;",
      "\tvoid init(int _N) { N = _N;",
      "\t\tp.rsz(N), adj.rsz(N), dist.rsz(N), pre.rsz(N); }",
      "\tvoid ae(int u, int v, F cap, C cost) { assert(cap >= 0); ",
      "\t\tadj[u].pb({v,sz(adj[v]),0,cap,cost}); ",
      "\t\tadj[v].pb({u,sz(adj[u])-1,0,0,-cost});",
      "\t} // use asserts, don't try smth dumb",
      "\tbool path(int s, int t) { // find lowest cost path to send flow through",
      "\t\tconst C inf = numeric_limits<C>::max(); dist.assign(N,inf);",
      "\t\tusing T = pair<C,int>; priority_queue<T,vector<T>,greater<T>> todo; ",
      "\t\ttodo.push({dist[s] = 0,s}); ",
      "\t\twhile (sz(todo)) { // Dijkstra",
      "\t\t\tT x = todo.top(); todo.pop(); if (x.f > dist[x.s]) continue;",
      "\t\t\teach(e,adj[x.s]) { // all weights should be non-negative",
      "\t\t\t\tif (e.flo < e.cap && ckmin(dist[e.to],x.f+e.cost+p[x.s]-p[e.to]))",
      "\t\t\t\t\tpre[e.to] = {x.s,e.rev}, todo.push({dist[e.to],e.to});",
      "\t\t\t}",
      "\t\t} // if costs are doubles, add some EPS so you ",
      "\t\t// don't traverse ~0-weight cycle repeatedly",
      "\t\treturn dist[t] != inf; // return flow",
      "\t}",
      "\tpair<F,C> calc(int s, int t) { assert(s != t);",
      "\t\tF0R(_,N) F0R(i,N) each(e,adj[i]) // Bellman-Ford",
      "\t\t\tif (e.cap) ckmin(p[e.to],p[i]+e.cost);",
      "\t\tF totFlow = 0; C totCost = 0;",
      "\t\twhile (path(s,t)) { // p -> potentials for Dijkstra",
      "\t\t\tF0R(i,N) p[i] += dist[i]; // don't matter for unreachable nodes",
      "\t\t\tF df = numeric_limits<F>::max();",
      "\t\t\tfor (int x = t; x != s; x = pre[x].f) {",
      "\t\t\t\tEdge& e = adj[pre[x].f][adj[x][pre[x].s].rev]; ",
      "\t\t\t\tckmin(df,e.cap-e.flo); }",
      "\t\t\ttotFlow += df; totCost += (p[t]-p[s])*df;",
      "\t\t\tfor (int x = t; x != s; x = pre[x].f) {",
      "\t\t\t\tEdge& e = adj[x][pre[x].s]; e.flo -= df;",
      "\t\t\t\tadj[pre[x].f][e.rev].flo += df;",
      "\t\t\t}",
      "\t\t} // get max flow you can send along path",
      "\t\treturn {totFlow,totCost};",
      "\t}",
      "};"
    ],
    "description": "Minimum-cost maximum flow, assumes no negative cycles. ,  * It is possible to choose negative edge costs such that the first ,  * run of Dijkstra is slow, but this hasn't been an issue in the past. ,  * Edge weights \\$\\ge 0\\$ for every subsequent run. To get flow through ,  * original edges, assign ID's during \\texttt{ae}., * Time: Ignoring first run of Dijkstra, \\$O(FM\\log M)\\$ ,  * if caps are integers and \\$F\\$ is max flow., *"
  },
  "MCMF_2": {
    "prefix":["benq_MCMF_2"],
    "body": [
      "/**",
      " * Description: Minimum-cost maximum flow, assumes no negative cycles. ",
      " \t* It is possible to choose negative edge costs such that the first ",
      " \t* run of Dijkstra is slow, but this hasn't been an issue in the past. ",
      " \t* Edge weights \\$\\ge 0\\$ for every subsequent run. To get flow through ",
      " \t* original edges, assign ID's during \\texttt{ae}.",
      " * Time: Ignoring first run of Dijkstra, \\$O(FM\\log M)\\$ ",
      " \t* if caps are integers and \\$F\\$ is max flow.",
      " * Source: GeeksForGeeks",
      " \t* https://courses.csail.mit.edu/6.854/06/scribe/s12-minCostFlowAlg.pdf",
      " \t* running time is only pseudo-polynomial; see https://codeforces.com/blog/entry/70740",
      " \t* https://en.wikipedia.org/wiki/Johnson%27s_algorithm (to get non-negative weights)",
      " \t* https://codeforces.com/contest/1316/submission/72472865 ",
      " \t\t* mango_lassi, min cost circulation w/ capacity scaling",
      " * Verification: https://codeforces.com/contest/164/problem/C",
      " \t* https://codeforces.com/contest/316/problem/C2",
      " \t\t* TLEs, don't use priority queue",
      " */",
      "",
      "struct MCMF { ",
      "\tusing F = ll; using C = ll; // flow type, cost type",
      "\tstruct Edge { int to; F flo, cap; C cost; };",
      "\tint N; V<C> p, dist; vi pre; V<Edge> eds; V<vi> adj;",
      "\tvoid init(int _N) { N = _N;",
      "\t\tp.rsz(N), dist.rsz(N), pre.rsz(N), adj.rsz(N); }",
      "\tvoid ae(int u, int v, F cap, C cost) { assert(cap >= 0); ",
      "\t\tadj[u].pb(sz(eds)); eds.pb({v,0,cap,cost}); ",
      "\t\tadj[v].pb(sz(eds)); eds.pb({u,0,0,-cost});",
      "\t} // use asserts, don't try smth dumb",
      "\tbool path(int s, int t) { // find lowest cost path to send flow through",
      "\t\tconst C inf = numeric_limits<C>::max(); F0R(i,N) dist[i] = inf;",
      "\t\tusing T = pair<C,int>; priority_queue<T,vector<T>,greater<T>> todo; ",
      "\t\ttodo.push({dist[s] = 0,s}); ",
      "\t\twhile (sz(todo)) { // Dijkstra",
      "\t\t\tT x = todo.top(); todo.pop(); if (x.f > dist[x.s]) continue;",
      "\t\t\teach(e,adj[x.s]) { const Edge& E = eds[e]; // all weights should be non-negative",
      "\t\t\t\tif (E.flo < E.cap && ckmin(dist[E.to],x.f+E.cost+p[x.s]-p[E.to]))",
      "\t\t\t\t\tpre[E.to] = e, todo.push({dist[E.to],E.to});",
      "\t\t\t}",
      "\t\t} // if costs are doubles, add some EPS so you ",
      "\t\t// don't traverse ~0-weight cycle repeatedly",
      "\t\treturn dist[t] != inf; // return flow",
      "\t}",
      "\tpair<F,C> calc(int s, int t) { assert(s != t);",
      "\t\tF0R(_,N) F0R(e,sz(eds)) { const Edge& E = eds[e]; // Bellman-Ford",
      "\t\t\tif (E.cap) ckmin(p[E.to],p[eds[e^1].to]+E.cost); }",
      "\t\tF totFlow = 0; C totCost = 0;",
      "\t\twhile (path(s,t)) { // p -> potentials for Dijkstra",
      "\t\t\tF0R(i,N) p[i] += dist[i]; // don't matter for unreachable nodes",
      "\t\t\tF df = numeric_limits<F>::max();",
      "\t\t\tfor (int x = t; x != s; x = eds[pre[x]^1].to) {",
      "\t\t\t\tconst Edge& E = eds[pre[x]]; ckmin(df,E.cap-E.flo); }",
      "\t\t\ttotFlow += df; totCost += (p[t]-p[s])*df;",
      "\t\t\tfor (int x = t; x != s; x = eds[pre[x]^1].to)",
      "\t\t\t\teds[pre[x]].flo += df, eds[pre[x]^1].flo -= df;",
      "\t\t} // get max flow you can send along path",
      "\t\treturn {totFlow,totCost};",
      "\t}",
      "};"
    ],
    "description": "Minimum-cost maximum flow, assumes no negative cycles. ,  * It is possible to choose negative edge costs such that the first ,  * run of Dijkstra is slow, but this hasn't been an issue in the past. ,  * Edge weights \\$\\ge 0\\$ for every subsequent run. To get flow through ,  * original edges, assign ID's during \\texttt{ae}., * Time: Ignoring first run of Dijkstra, \\$O(FM\\log M)\\$ ,  * if caps are integers and \\$F\\$ is max flow., *"
  },
  "DFSmatch": {
    "prefix":["benq_DFSmatch"],
    "body": [
      "/**",
      " * Description: naive bipartite matching",
      " * Time: O(NM)",
      " * Source: own",
      " * Verification: USACO Training unmatch",
      " */",
      "",
      "template<int SZ> struct MaxMatch {",
      "\tint N, match[SZ], rmatch[SZ];",
      "\tbitset<SZ> vis; vi adj[SZ];",
      "\t/**void connect(int a, int b, bool c = 1) {",
      "\t\tif (c) match[a] = b, rmatch[b] = a;",
      "\t\telse match[a] = rmatch[b] = 0; }*/",
      "\tbool dfs(int x) {",
      "\t\tif (!x) return 1;",
      "\t\tif (vis[x]) return 0;",
      "\t\tvis[x] = 1;",
      "\t\teach(t,adj[x]) if (t != match[x] && dfs(rmatch[t])) {",
      "\t\t\tmatch[x] = t, rmatch[t] = x; return 1; }",
      "\t\treturn 0;",
      "\t}",
      "\tbool tri(int x) { vis.reset(); return dfs(x); }",
      "\tint init(int _N) { ",
      "\t\tN = _N; FOR(i,1,N+1) match[i] = rmatch[i] = 0;",
      "\t\tint res = 0; FOR(i,1,N+1) if (!match[i]) res += tri(i); ",
      "\t\treturn res;",
      "\t}",
      "};"
    ],
    "description": "naive bipartite matching, * Time: O(NM), *"
  },
  "FakeMatch": {
    "prefix":["benq_FakeMatch"],
    "body": [
      "/**",
      " * Description: General matching with capacity scaling. ",
      " \t* Assign an integer \\$0\\le cur[i,j]\\le cap[i,j]\\$ ",
      " \t* to every edge such that \\$\\sum_{j\\in N(i)}cur[i,j]=f_i\\$,",
      " \t* assuming that a solution exists. Correctness is questionable.",
      " * Time: ?",
      " * Source: 300iq",
      " * Verification: https://www.acmicpc.net/problem/18509",
      " */",
      "",
      "template<int SZ> struct FakeMatch {",
      "\tint N,f[SZ],cur[SZ][SZ],cap[SZ][SZ],vis[SZ];",
      "\tvoid x(int a, int b, int c) {",
      "\t\tcur[a][b] += c, cur[b][a] += c; }",
      "\tint s,tt;",
      "\tbool dfs(int v, int sz) { // find alternating path",
      "\t\tvis[v] = tt;",
      "\t\tFOR(a,1,N+1) if (cap[v][a]-cur[v][a] >= sz) ",
      "\t\t\tif (f[a] >= 2*sz || (f[a] >= sz && a != s)) {",
      "\t\t\t\tx(v,a,sz); f[s] -= sz; f[a] -= sz; return 1; }",
      "\t\tFOR(a,1,N+1) FOR(b,1,N+1) {",
      "\t\t\tif (cap[v][a]-cur[v][a] < sz) break;",
      "\t\t\tif (cur[a][b] >= sz && vis[b] < tt) {",
      "\t\t\t\tx(v,a,sz); x(a,b,-sz);",
      "\t\t\t\tif (dfs(b,sz)) return 1;",
      "\t\t\t\tx(v,a,-sz); x(a,b,sz);",
      "\t\t\t}",
      "\t\t}",
      "\t\treturn 0;",
      "\t}",
      "\tvoid solve(int _N) {",
      "\t\tN = _N; vpi ed; ",
      "\t\tFOR(i,1,N+1) FOR(j,i+1,N+1) ed.pb({i,j});",
      "\t\trandom_shuffle(all(ed));",
      "\t\teach(c,ed) {",
      "\t\t\tint a = c.f, b = c.s, w = min(min(f[a],f[b]),cap[a][b]);",
      "\t\t\tx(a,b,w); f[a] -= w, f[b] -= w; }",
      "\t\twhile (1) {",
      "\t\t\tvi lef; FOR(i,1,N+1) if (f[i]) lef.pb(i);",
      "\t\t\tif (!sz(lef)) break;",
      "\t\t\tshuffle(all(lef),rng);",
      "\t\t\teach(_s,lef) {",
      "\t\t\t\ts = _s; tt ++;",
      "\t\t\t\tfor (int sz = 1<<13; sz; sz /= 2) while (f[s] >= sz) ",
      "\t\t\t\t\t{ tt ++; if (!dfs(s,sz)) break; }",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "};"
    ],
    "description": "General matching with capacity scaling. ,  * Assign an integer \\$0\\le cur[i,j]\\le cap[i,j]\\$ ,  * to every edge such that \\$\\sum_{j\\in N(i)}cur[i,j]=f_i\\$,,  * assuming that a solution exists. Correctness is questionable., * Time: ?, *"
  },
  "Hungarian": {
    "prefix":["benq_Hungarian"],
    "body": [
      "/**",
      " * Description: Given array of (possibly negative) costs to complete ",
      "\t* each of \\$N\\$ (1-indexed) jobs w/ each of \\$M\\$ workers \\$(N\\le M)\\$, ",
      "\t* finds min cost to complete all jobs such that each worker is ",
      "\t* assigned to at most one job. Dijkstra with potentials works",
      "\t* in almost the same way as MCMF.",
      " * Time: O(N^2M)",
      " * Source: https://github.com/mpfeifer1/Kattis/blob/master/cordonbleu.cpp, tourist?",
      "\t* http://www.hungarianalgorithm.com/examplehungarianalgorithm.php",
      "\t* https://en.wikipedia.org/wiki/Hungarian_algorithm",
      "\t* https://www.geeksforgeeks.org/hungarian-algorithm-assignment-problem-set-1-introduction/",
      "\t* https://brilliant.org/wiki/hungarian-matching/",
      "\t* https://www.topcoder.com/community/competitive-programming/tutorials/assignment-problem-and-hungarian-algorithm/",
      " * Verification: https://www.spoj.com/problems/BABY/",
      " \t* https://open.kattis.com/problems/cordonbleu",
      "\t* also see https://codeforces.com/blog/entry/63701",
      " */",
      "",
      "using C = ll;",
      "C hungarian(const V<V<C>>& a) { ",
      "\tint N = sz(a)-1, M = sz(a[0])-1; assert(N <= M);",
      "\tV<C> u(N+1), v(M+1); // potentials to make edge weights >= 0",
      "\tvi job(M+1);",
      "\tFOR(i,1,N+1) { // find alternating path with job i",
      "\t\tconst C inf = numeric_limits<C>::max();",
      "\t\tint w = 0; job[w] = i; // add \"dummy\" 0, find path to real worker",
      "\t\tV<C> dist(M+1,inf); vi pre(M+1,-1); vb done(M+1);",
      "\t\twhile (job[w]) { // dijkstra",
      "\t\t\tdone[w] = 1; int j = job[w], nexW; C delta = inf; ",
      "\t\t\t// fix dist[j], update dists from j",
      "\t\t\tF0R(W,M+1) if (!done[W]) { // try all workers",
      "\t\t\t\tif (ckmin(dist[W],a[j][W]-u[j]-v[W])) pre[W] = w;",
      "\t\t\t\tif (ckmin(delta,dist[W])) nexW = W;",
      "\t\t\t}",
      "\t\t\tF0R(W,M+1) { // subtract constant from all edges going ",
      "\t\t\t\t// from done -> not done vertices, lowers all ",
      "\t\t\t\t// remaining dists by constant",
      "\t\t\t\tif (done[W]) u[job[W]] += delta, v[W] -= delta; ",
      "\t\t\t\telse dist[W] -= delta; ",
      "\t\t\t}",
      "\t\t\tw = nexW;",
      "\t\t} // potentials adjusted so all edge weights >= 0",
      "\t\tfor (int W; w; w = W) job[w] = job[W = pre[w]];",
      "\t} // job[w] = 0, found alternating path ",
      "\treturn -v[0]; // min cost",
      "}"
    ],
    "description": "Given array of (possibly negative) costs to complete , * each of \\$N\\$ (1-indexed) jobs w/ each of \\$M\\$ workers \\$(N\\le M)\\$, , * finds min cost to complete all jobs such that each worker is , * assigned to at most one job. Dijkstra with potentials works, * in almost the same way as MCMF., * Time: O(N^2M), *"
  },
  "MaxMatchLexMin": {
    "prefix":["benq_MaxMatchLexMin"],
    "body": [
      "/**",
      " * Description: lexiographically least matching wrt left vertices",
      " * Time: \\$\\log |L|\\$ times sum of complexities of \\texttt{gen}, \\texttt{maxMatch}",
      " * Source: https://codeforces.com/blog/entry/76187?#comment-611056",
      " * Usage: solve(L,R,sz(L))",
      " * Verification: GP of Moscow 2020 I",
      " */",
      "",
      "vpi maxMatch(vi L, vi R); // return pairs in max matching",
      "pair<vi,vi> gen(vi L, vi R); // return {Lp,Rp}, vertices on ",
      "// left/right that can be reached by alternating path from ",
      "// unmatched node on left after finding max matching",
      "",
      "vpi res; // stores answer",
      "void solve(vi L, vi R, int x) { // first |L|-x elements of L",
      "\tif (x <= 1) { // are in matching, easy if x <= 1",
      "\t\tvpi v = maxMatch(L,R);",
      "\t\tif (sz(v) != sz(L)) L.pop_back(), v = maxMatch(L,R);",
      "\t\tassert(sz(v) == sz(L)); ",
      "\t\tres.insert(end(res),all(v)); return;",
      "\t}",
      "\tvi Lp,Rp; tie(Lp,Rp)=gen(L,R); vi Lm=sub(L,Lp),Rm=sub(R,Rp);",
      "\t// Lp U Rm is max indep set, Lm U Rp is min vertex cover",
      "\t// Lp and Rm independent, edges from Lm to Rp can be ignored",
      "\tvpi v = maxMatch(Lm,Rm); assert(sz(v) == sz(Lm)); ",
      "\tres.insert(end(res),all(v));",
      "\tvi L2(all(L)-x/2); vi Lp2,Rp2; tie(Lp2,Rp2) = gen(L2,R);",
      "\tint cnt = 0; each(t,Lp2) cnt += t >= L[sz(L)-x];",
      "\tsolve(Lp2,Rp2,cnt); // Rp2 covered by best matching",
      "\tvi LL = sub(Lp,Lp2), RR = sub(Rp,Rp2); // those in Lp but not ",
      "\t// Lp2 that are < L[sz(L)-x/2] must be in answer, not cnt",
      "\tcnt = 0; each(t,LL) cnt += t >= L[sz(L)-x/2];",
      "\tsolve(LL,RR,cnt); // do rest",
      "} // x reduced by factor of at least two"
    ],
    "description": "lexiographically least matching wrt left vertices, * Time: \\$\\log |L|\\$ times sum of complexities of \\texttt{gen}, \\texttt{maxMatch}, *"
  },
  "UnweightedMatch": {
    "prefix":["benq_UnweightedMatch"],
    "body": [
      "/**",
      " * Description: Edmond's Blossom Algorithm. General unweighted ",
      " \t* matching with 1-based indexing. If \\texttt{vis[v]=0}",
      " \t* when \\texttt{bfs} returns 0, \\texttt{v} is not part of every ",
      " \t* max matching.",
      " * Time: O(N^3), faster in practice",
      " * Source: ",
      "\t* https://github.com/koosaga/DeobureoMinkyuParty",
      "\t* https://www-m9.ma.tum.de/graph-algorithms/matchings-blossom-algorithm/index_en.html",
      "\t* https://codeforces.com/blog/entry/63630",
      " * Verification: ",
      " \t* https://codeforces.com/contest/1089 B",
      " \t* https://www.codechef.com/problems/HAMILG",
      " */",
      "",
      "template<int SZ> struct UnweightedMatch {",
      "\tint match[SZ], N; vi adj[SZ];",
      "\tvoid ae(int u, int v) { adj[u].pb(v), adj[v].pb(u); }",
      "\tqueue<int> q;",
      "\tint par[SZ], vis[SZ], orig[SZ], aux[SZ];",
      "\tvoid augment(int u, int v) { // toggle edges on u-v path",
      "\t\twhile (1) { // one more matched pair",
      "\t\t\tint pv = par[v], nv = match[pv];",
      "\t\t\tmatch[v] = pv; match[pv] = v;",
      "\t\t\tv = nv; if (u == pv) return;",
      "\t\t}",
      "\t}",
      "\tint lca(int u, int v) { // find LCA of supernodes in O(dist)",
      "\t\tstatic int t = 0;",
      "\t\tfor (++t;;swap(u,v)) {",
      "\t\t\tif (!u) continue;",
      "\t\t\tif (aux[u] == t) return u; // found LCA",
      "\t\t\taux[u] = t; u = orig[par[match[u]]];",
      "\t\t}",
      "\t}",
      "\tvoid blossom(int u, int v, int a) { // go other way",
      "\t\tfor (; orig[u] != a; u = par[v]) { // around cycle",
      "\t\t\tpar[u] = v; v = match[u]; // treat u as if vis[u] = 1",
      "\t\t\tif (vis[v] == 1) vis[v] = 0, q.push(v);",
      "\t\t\torig[u] = orig[v] = a; // merge into supernode",
      "\t\t}",
      "\t}",
      "\tbool bfs(int u) { // u is initially unmatched",
      "\t\tF0R(i,N+1) par[i] = 0, vis[i] = -1, orig[i] = i;",
      "\t\tq = queue<int>(); vis[u] = 0, q.push(u);",
      "\t\twhile (sz(q)) { // each node is pushed to q at most once",
      "\t\t\tint v = q.ft; q.pop(); // 0 -> unmatched vertex",
      "\t\t\teach(x,adj[v]) {",
      "\t\t\t\tif (vis[x] == -1) { // neither of x, match[x] visited",
      "\t\t\t\t\tvis[x] = 1; par[x] = v;",
      "\t\t\t\t\tif (!match[x]) return augment(u,x),1;",
      "\t\t\t\t\tvis[match[x]] = 0, q.push(match[x]);",
      "\t\t\t\t} else if (vis[x] == 0 && orig[v] != orig[x]) {",
      "\t\t\t\t\tint a = lca(orig[v],orig[x]); // odd cycle",
      "\t\t\t\t\tblossom(x,v,a), blossom(v,x,a); ",
      "\t\t\t\t} // contract O(n) times",
      "\t\t\t}",
      "\t\t}",
      "\t\treturn 0;",
      "\t}",
      "\tint calc(int _N) { // rand matching -> constant improvement",
      "\t\tN = _N; F0R(i,N+1) match[i] = aux[i] = 0; ",
      "\t\tint ans = 0; vi V(N); iota(all(V),1); shuffle(all(V),rng); // find rand matching",
      "\t\teach(x,V) if (!match[x]) each(y,adj[x]) if (!match[y]) { ",
      "\t\t\tmatch[x] = y, match[y] = x; ++ans; break; }",
      "\t\tFOR(i,1,N+1) if (!match[i] && bfs(i)) ++ans;",
      "\t\treturn ans;",
      "\t}",
      "};"
    ],
    "description": "Edmond's Blossom Algorithm. General unweighted ,  * matching with 1-based indexing. If \\texttt{vis[v]=0},  * when \\texttt{bfs} returns 0, \\texttt{v} is not part of every ,  * max matching., * Time: O(N^3), faster in practice, *"
  },
  "UnweightedMatch2": {
    "prefix":["benq_UnweightedMatch2"],
    "body": [
      "/**",
      " * Description: Matching for general graphs. Fails with probability \\$N/MOD\\$.",
      " * Time: O(N^3)",
      " * Source: Simon Lindholm, KACTL",
      " \t* http://www.mimuw.edu.pl/~mucha/pub/mucha_sankowski_focs04.pdf",
      " * Verification: https://codeforces.com/contest/1089/problem/B",
      " */",
      "",
      "#include \"MatrixInv.h\"",
      "",
      "vpi match(int N, vpi& ed) {",
      "\tMat<mi> mat(N,N); // skew symmetric adj matrix",
      "\teach(pa, ed) {",
      "\t\tint a = pa.f, b = pa.s, r = rand() % MOD;",
      "\t\tmat.d[a][b] = r, mat.d[b][a] = (MOD-r) % MOD;",
      "\t}",
      "\tauto MAT = mat; int r = gauss(MAT).s, M = 2*N-r;",
      "\tassert(r%2 == 0); // rank <= 2*(size of matching)",
      "\tmat.r = mat.c = M; mat.d.rsz(M,vmi(M));",
      "\tF0R(i,N) mat.d[i].rsz(M);",
      "\tMat<mi> A(0,0);",
      "\twhile (A.r == 0) { // extend to make perfect matching",
      "\t\tF0R(i,N) FOR(j,N,M) {",
      "\t\t\tint r = rand() % MOD;",
      "\t\t\tmat.d[i][j] = r, mat.d[j][i] = -r;",
      "\t\t}",
      "\t\tA = inv(mat);",
      "\t}",
      "\tvi has(M,1); vpi ret;",
      "\tF0R(it,M/2) {",
      "\t\tint fi, fj;",
      "\t\tF0R(i,M) if (has[i])",
      "\t\t\tFOR(j,i+1,M) if (A.d[i][j] != 0 && mat.d[i][j] != 0) {",
      "\t\t\t\tfi = i; fj = j; goto done; // added edge",
      "\t\t} assert(0); done: // now remove corresponding rows / cols",
      "\t\thas[fi] = has[fj] = 0; if (fj < N) ret.eb(fi, fj);",
      "\t\tF0R(sw,2) { // calculate inverse for reduced adj matrix",
      "\t\t\tmi a = 1/A.d[fi][fj]; ",
      "\t\t\tF0R(i,M) if (has[i] && A.d[i][fj] != 0) {",
      "\t\t\t\tmi b = A.d[i][fj]*a;",
      "\t\t\t\tF0R(j,M) A.d[i][j] -= A.d[fi][j]*b;",
      "\t\t\t}",
      "\t\t\tswap(fi,fj);",
      "\t\t}",
      "\t}",
      "\treturn ret;",
      "}"
    ],
    "description": "Matching for general graphs. Fails with probability \\$N/MOD\\$., * Time: O(N^3), *"
  },
  "WeightedMatch": {
    "prefix":["benq_WeightedMatch"],
    "body": [
      "/**",
      " * Description: General max weight max matching with 1-based indexing.",
      " \t* Edge weights must be positive, combo of UnweightedMatch and",
      " \t* Hungarian.",
      " * Time: O(N^3)?",
      " * Source: ",
      "\t* https://github.com/koosaga/DeobureoMinkyuParty",
      "\t* https://codeforces.com/blog/entry/63630 (MiFaFaOvO)",
      "\t* see https://theory.stanford.edu/~jvondrak/CS369P/lec6.pdf ",
      "\t\t* but I still don't understand :|",
      "\t* Combinatorial Optimization Ch 11",
      "\t\t* http://www.mathematik.uni-muenchen.de/~kpanagio/KombOpt/book.pdf",
      " * Verification: ",
      " \t* https://codeforces.com/gym/102156/problem/F",
      " */",
      "",
      "template<int SZ> struct WeightedMatch { ",
      "\tstruct edge { int u,v,w; }; edge g[SZ*2][SZ*2];",
      "\tvoid ae(int u, int v, int w) { g[u][v].w = g[v][u].w = w; }",
      "\tint N,NX,lab[SZ*2],match[SZ*2],slack[SZ*2],st[SZ*2];",
      "\tint par[SZ*2],floFrom[SZ*2][SZ],S[SZ*2],aux[SZ*2]; ",
      "\tvi flo[SZ*2]; queue<int> q;",
      "\tvoid init(int _N) { N = _N; // init all edges",
      "\t\tFOR(u,1,N+1) FOR(v,1,N+1) g[u][v] = {u,v,0}; }",
      "\tint eDelta(edge e) { // >= 0 at all times",
      "\t\treturn lab[e.u]+lab[e.v]-g[e.u][e.v].w*2; } ",
      "\tvoid updSlack(int u, int x) { // smallest edge -> blossom x",
      "\t\tif (!slack[x] || eDelta(g[u][x]) < eDelta(g[slack[x]][x])) ",
      "\t\t\tslack[x] = u; }",
      "\tvoid setSlack(int x) {",
      "\t\tslack[x] = 0; FOR(u,1,N+1) if (g[u][x].w > 0",
      "\t\t && st[u] != x && S[st[u]] == 0) updSlack(u,x); }",
      "\tvoid qPush(int x) {",
      "\t\tif (x <= N) q.push(x);",
      "\t\telse each(t,flo[x]) qPush(t); }",
      "\tvoid setSt(int x, int b) {",
      "\t\tst[x] = b; if (x > N) each(t,flo[x]) setSt(t,b); }",
      "\tint getPr(int b, int xr) { // get even position of xr",
      "\t\tint pr = find(all(flo[b]),xr)-begin(flo[b]);",
      "\t\tif (pr&1) { reverse(1+all(flo[b])); return sz(flo[b])-pr; } ",
      "\t\treturn pr; }",
      "\tvoid setMatch(int u, int v) { // rearrange flo[u], matches",
      "\t\tedge e = g[u][v]; match[u] = e.v; if (u <= N) return;",
      "\t\tint xr = floFrom[u][e.u], pr = getPr(u,xr);",
      "\t\tF0R(i,pr) setMatch(flo[u][i],flo[u][i^1]);",
      "\t\tsetMatch(xr,v); rotate(begin(flo[u]),pr+all(flo[u])); }",
      "\tvoid augment(int u, int v) { // set matches including u->v",
      "\t\twhile (1) { // and previous ones",
      "\t\t\tint xnv = st[match[u]]; setMatch(u,v); ",
      "\t\t\tif (!xnv) return; ",
      "\t\t\tsetMatch(xnv,st[par[xnv]]); ",
      "\t\t\tu = st[par[xnv]], v = xnv; ",
      "\t\t}",
      "\t}",
      "\tint lca(int u, int v) { // same as in unweighted",
      "\t\tstatic int t = 0; // except maybe return 0",
      "\t\tfor (++t;u||v;swap(u,v)) {",
      "\t\t\tif (!u) continue;",
      "\t\t\tif (aux[u] == t) return u;",
      "\t\t\taux[u] = t; u = st[match[u]];",
      "\t\t\tif (u) u = st[par[u]];",
      "\t\t}",
      "\t\treturn 0;",
      "\t}",
      "\tvoid addBlossom(int u, int anc, int v) { ",
      "\t\tint b = N+1; while (b <= NX && st[b]) ++b;",
      "\t\tif (b > NX) ++NX; // new blossom",
      "\t\tlab[b] = S[b] = 0; match[b] = match[anc]; flo[b] = {anc};",
      "\t\tauto blossom = [&](int x) {",
      "\t\t\tfor (int y; x != anc; x = st[par[y]]) ",
      "\t\t\t\tflo[b].pb(x), flo[b].pb(y = st[match[x]]), qPush(y);",
      "\t\t};",
      "\t\tblossom(u); reverse(1+all(flo[b])); blossom(v); setSt(b,b); ",
      "\t\t// identify all nodes in current blossom",
      "\t\tFOR(x,1,NX+1) g[b][x].w = g[x][b].w = 0;",
      "\t\tFOR(x,1,N+1) floFrom[b][x] = 0;",
      "\t\teach(xs,flo[b]) { // find tightest constraints",
      "\t\t\tFOR(x,1,NX+1) if (g[b][x].w == 0 || eDelta(g[xs][x]) < ",
      "\t\t\t\teDelta(g[b][x])) g[b][x]=g[xs][x], g[x][b]=g[x][xs]; ",
      "\t\t\tFOR(x,1,N+1) if (floFrom[xs][x]) floFrom[b][x] = xs; ",
      "\t\t} // floFrom to deconstruct blossom",
      "\t\tsetSlack(b); // since didn't qPush everything",
      "\t}",
      "\tvoid expandBlossom(int b) {",
      "\t\teach(t,flo[b]) setSt(t,t); // undo setSt(b,b)",
      "\t\tint xr = floFrom[b][g[b][par[b]].u], pr = getPr(b,xr);",
      "\t\tfor(int i = 0; i < pr; i += 2) {",
      "\t\t\tint xs = flo[b][i], xns = flo[b][i+1];",
      "\t\t\tpar[xs] = g[xns][xs].u; S[xs] = 1; // no setSlack(xns)?",
      "\t\t\tS[xns] = slack[xs] = slack[xns] = 0; qPush(xns);",
      "\t\t}",
      "\t\tS[xr] = 1, par[xr] = par[b];",
      "\t\tFOR(i,pr+1,sz(flo[b])) { // matches don't change",
      "\t\t\tint xs = flo[b][i]; S[xs] = -1, setSlack(xs); }",
      "\t\tst[b] = 0; // blossom killed",
      "\t}",
      "\tbool onFoundEdge(edge e) {",
      "\t\tint u = st[e.u], v = st[e.v];",
      "\t\tif (S[v] == -1) { // v unvisited, matched with smth else",
      "\t\t\tpar[v] = e.u, S[v] = 1; slack[v] = 0;",
      "\t\t\tint nu = st[match[v]]; S[nu] = slack[nu] = 0; qPush(nu);",
      "\t\t} else if (S[v] == 0) {",
      "\t\t\tint anc = lca(u,v); // if 0 then match found!",
      "\t\t\tif (!anc) return augment(u,v),augment(v,u),1;",
      "\t\t\taddBlossom(u,anc,v);",
      "\t\t}",
      "\t\treturn 0;",
      "\t}",
      "\tbool matching() {",
      "\t\tq = queue<int>(); ",
      "\t\tFOR(x,1,NX+1) {",
      "\t\t\tS[x] = -1, slack[x] = 0; // all initially unvisited",
      "\t\t\tif (st[x] == x && !match[x]) par[x] = S[x] = 0, qPush(x); ",
      "\t\t} ",
      "\t\tif (!sz(q)) return 0;",
      "\t\twhile (1) {",
      "\t\t\twhile (sz(q)) { // unweighted matching with tight edges",
      "\t\t\t\tint u = q.ft; q.pop(); if (S[st[u]] == 1) continue;",
      "\t\t\t\tFOR(v,1,N+1) if (g[u][v].w > 0 && st[u] != st[v]) { ",
      "\t\t\t\t\tif (eDelta(g[u][v]) == 0) { // condition is strict",
      "\t\t\t\t\t\tif (onFoundEdge(g[u][v])) return 1;",
      "\t\t\t\t\t} else updSlack(u,st[v]);",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t\tint d = INT_MAX; ",
      "\t\t\tFOR(b,N+1,NX+1) if (st[b] == b && S[b] == 1) ",
      "\t\t\t\tckmin(d,lab[b]/2); // decrease lab[b]",
      "\t\t\tFOR(x,1,NX+1) if (st[x] == x && slack[x]) {",
      "\t\t\t\tif (S[x] == -1) ckmin(d,eDelta(g[slack[x]][x]));",
      "\t\t\t\telse if (S[x] == 0) ckmin(d,eDelta(g[slack[x]][x])/2);",
      "\t\t\t} // edge weights shouldn't go below 0",
      "\t\t\tFOR(u,1,N+1) {",
      "\t\t\t\tif (S[st[u]] == 0) {",
      "\t\t\t\t\tif (lab[u] <= d) return 0; // why?",
      "\t\t\t\t\tlab[u] -= d;",
      "\t\t\t\t} else if (S[st[u]] == 1) lab[u] += d;",
      "\t\t\t} // lab has opposite meaning for verts and blossoms",
      "\t\t\tFOR(b,N+1,NX+1) if (st[b] == b && S[b] != -1) ",
      "\t\t\t\tlab[b] += (S[b] == 0 ? 1 : -1)*d*2;",
      "\t\t\tq = queue<int>();",
      "\t\t\tFOR(x,1,NX+1) if (st[x]==x && slack[x] // new tight edge",
      "\t\t\t\t&& st[slack[x]] != x && eDelta(g[slack[x]][x]) == 0)",
      "\t\t\t\t\tif (onFoundEdge(g[slack[x]][x])) return 1;",
      "\t\t\tFOR(b,N+1,NX+1) if (st[b]==b && S[b]==1 && lab[b]==0) ",
      "\t\t\t\texpandBlossom(b); // odd dist blossom taken apart",
      "\t\t}",
      "\t\treturn 0;",
      "\t}",
      "\tpair<ll,int> calc() {",
      "\t\tNX = N; st[0] = 0; FOR(i,1,2*N+1) aux[i] = 0;",
      "\t\tFOR(i,1,N+1) match[i] = 0, st[i] = i, flo[i].clear();",
      "\t\tint wMax = 0;",
      "\t\tFOR(u,1,N+1) FOR(v,1,N+1)",
      "\t\t\tfloFrom[u][v] = (u == v ? u : 0), ckmax(wMax,g[u][v].w);",
      "\t\tFOR(u,1,N+1) lab[u] = wMax; // start high and decrease",
      "\t\tint num = 0; ll wei = 0; while (matching()) ++num;",
      "\t\tFOR(u,1,N+1) if (match[u] && match[u] < u) ",
      "\t\t\twei += g[u][match[u]].w; // edges in matching",
      "\t\treturn {wei,num};",
      "\t}",
      "};"
    ],
    "description": "General max weight max matching with 1-based indexing.,  * Edge weights must be positive, combo of UnweightedMatch and,  * Hungarian., * Time: O(N^3)?, *"
  },
  "Centroid": {
    "prefix":["benq_Centroid"],
    "body": [
      "/**",
      " * Description: The centroid of a tree of size \\$N\\$ is a vertex such that ",
      " \t* after removing it, all resulting subtrees have size at most \\$\\frac{N}{2}.\\$ ",
      " \t* Supports updates in the form ``add 1 to all verts \\$v\\$ such that \\$dist(x,v)\\le y\\$.\"",
      " * Time: O(N\\log N) build, O(\\log N) update and query",
      " * Memory: O(N\\log N)",
      " * Source: own",
      " * Verification: ",
      "\t* solves https://dmoj.ca/problem/dmopc19c7p6",
      "\t* https://codeforces.com/contest/342/problem/E",
      "\t* Triway Cup 2019 G",
      " */",
      "",
      "void ad(vi& a, int b) { ckmin(b,sz(a)-1); if (b>=0) a[b]++; }",
      "void prop(vi& a) { R0F(i,sz(a)-1) a[i] += a[i+1]; }",
      "template<int SZ> struct Centroid {",
      "\tvi adj[SZ]; void ae(int a,int b){adj[a].pb(b),adj[b].pb(a);}",
      "\tbool done[SZ]; // processed as centroid yet",
      "\tint N,sub[SZ],cen[SZ],lev[SZ]; // subtree size, centroid anc",
      "\tint dist[32-__builtin_clz(SZ)][SZ]; // dists to all ancs",
      "\tvi stor[SZ], STOR[SZ];",
      "\tvoid dfs(int x, int p) { sub[x] = 1; ",
      "\t\teach(y,adj[x]) if (!done[y] && y != p) ",
      "\t\t\tdfs(y,x), sub[x] += sub[y]; ",
      "\t}",
      "\tint centroid(int x) {",
      "\t\tdfs(x,-1); ",
      "\t\tfor (int sz = sub[x];;) {",
      "\t\t\tpi mx = {0,0};",
      "\t\t\teach(y,adj[x]) if (!done[y] && sub[y] < sub[x]) ",
      "\t\t\t\tckmax(mx,{sub[y],y});",
      "\t\t\tif (mx.f*2 <= sz) return x; ",
      "\t\t\tx = mx.s;",
      "\t\t}",
      "\t}",
      "\tvoid genDist(int x, int p, int lev) {",
      "\t\tdist[lev][x] = dist[lev][p]+1;",
      "\t\teach(y,adj[x]) if (!done[y] && y != p) genDist(y,x,lev); }",
      "\tvoid gen(int CEN, int _x) { // CEN = centroid above x",
      "\t\tint x = centroid(_x); done[x] = 1; cen[x] = CEN; ",
      "\t\tsub[x] = sub[_x]; lev[x] = (CEN == -1 ? 0 : lev[CEN]+1);",
      "\t\tdist[lev[x]][x] = 0; ",
      "\t\tstor[x].rsz(sub[x]),STOR[x].rsz(sub[x]+1); ",
      "\t\teach(y,adj[x]) if (!done[y]) genDist(y,x,lev[x]);",
      "\t\teach(y,adj[x]) if (!done[y]) gen(x,y);",
      "\t}",
      "\tvoid init(int _N) { N = _N; FOR(i,1,N+1) done[i] = 0;",
      "\t\tgen(-1,1); } // start at vert 1",
      "\tvoid upd(int x, int y) { ",
      "\t\tint cur = x, pre = -1;",
      "\t\tR0F(i,lev[x]+1) {",
      "\t\t\tad(stor[cur],y-dist[i][x]); ",
      "\t\t\tif (pre != -1) ad(STOR[pre],y-dist[i][x]);",
      "\t\t\tif (i > 0) pre = cur, cur = cen[cur];",
      "\t\t}",
      "\t} // call propAll() after all updates",
      "\tvoid propAll() { FOR(i,1,N+1) prop(stor[i]), prop(STOR[i]); }",
      "\tint query(int x) { // get value at vertex x",
      "\t\tint cur = x, pre = -1, ans = 0;",
      "\t\tR0F(i,lev[x]+1) { // if pre != -1, subtract those from",
      "\t\t\tans += stor[cur][dist[i][x]]; // same subtree",
      "\t\t\tif (pre != -1) ans -= STOR[pre][dist[i][x]];",
      "\t\t\tif (i > 0) pre = cur, cur = cen[cur];",
      "\t\t}",
      "\t\treturn ans;",
      "\t}",
      "};"
    ],
    "description": "The centroid of a tree of size \\$N\\$ is a vertex such that ,  * after removing it, all resulting subtrees have size at most \\$\\frac{N}{2}.\\$ ,  * Supports updates in the form ``add 1 to all verts \\$v\\$ such that \\$dist(x,v)\\le y\\$.\", * Time: O(N\\log N) build, O(\\log N) update and query, * Memory: O(N\\log N), *"
  },
  "HLD": {
    "prefix":["benq_HLD"],
    "body": [
      "/**",
      " * Description: Heavy-Light Decomposition, add val to verts ",
      " \t* and query sum in path/subtree.",
      " * Time: any tree path is split into \\$O(\\log N)\\$ parts",
      " * Source: http://codeforces.com/blog/entry/22072, https://codeforces.com/blog/entry/53170",
      " * Verification: *",
      " */",
      "",
      "#include \"../../data-structures/1D Range Queries (9.2)/LazySeg (15.2).h\"",
      "",
      "template<int SZ, bool VALS_IN_EDGES> struct HLD { ",
      "\tint N; vi adj[SZ];",
      "\tint par[SZ], root[SZ], depth[SZ], sz[SZ], ti;",
      "\tint pos[SZ]; vi rpos; // rpos not used, but could be useful",
      "\tvoid ae(int x, int y) { adj[x].pb(y), adj[y].pb(x); }",
      "\tvoid dfsSz(int x) { ",
      "\t\tsz[x] = 1; ",
      "\t\teach(y,adj[x]) {",
      "\t\t\tpar[y] = x; depth[y] = depth[x]+1;",
      "\t\t\tadj[y].erase(find(all(adj[y]),x)); // remove parent from adj list",
      "\t\t\tdfsSz(y); sz[x] += sz[y];",
      "\t\t\tif (sz[y] > sz[adj[x][0]]) swap(y,adj[x][0]);",
      "\t\t}",
      "\t}",
      "\tvoid dfsHld(int x) {",
      "\t\tpos[x] = ti++; rpos.pb(x);",
      "\t\teach(y,adj[x]) {",
      "\t\t\troot[y] = (y == adj[x][0] ? root[x] : y);",
      "\t\t\tdfsHld(y); }",
      "\t}",
      "\tvoid init(int _N, int R = 0) { N = _N; ",
      "\t\tpar[R] = depth[R] = ti = 0; dfsSz(R); ",
      "\t\troot[R] = R; dfsHld(R); ",
      "\t}",
      "\tint lca(int x, int y) {",
      "\t\tfor (; root[x] != root[y]; y = par[root[y]])",
      "\t\t\tif (depth[root[x]] > depth[root[y]]) swap(x,y);",
      "\t\treturn depth[x] < depth[y] ? x : y;",
      "\t}",
      "\t/// int dist(int x, int y) { // # edges on path",
      "\t/// \treturn depth[x]+depth[y]-2*depth[lca(x,y)]; }",
      "\tLazySeg<ll,SZ> tree; // segtree for sum",
      "\ttemplate <class BinaryOp>",
      "\tvoid processPath(int x, int y, BinaryOp op) {",
      "\t\tfor (; root[x] != root[y]; y = par[root[y]]) {",
      "\t\t\tif (depth[root[x]] > depth[root[y]]) swap(x,y);",
      "\t\t\top(pos[root[y]],pos[y]); }",
      "\t\tif (depth[x] > depth[y]) swap(x,y);",
      "\t\top(pos[x]+VALS_IN_EDGES,pos[y]); ",
      "\t}",
      "\tvoid modifyPath(int x, int y, int v) { ",
      "\t\tprocessPath(x,y,[this,&v](int l, int r) { ",
      "\t\t\ttree.upd(l,r,v); }); }",
      "\tll queryPath(int x, int y) { ",
      "\t\tll res = 0; processPath(x,y,[this,&res](int l, int r) { ",
      "\t\t\tres += tree.query(l,r); });",
      "\t\treturn res; }",
      "\tvoid modifySubtree(int x, int v) { ",
      "\t\ttree.upd(pos[x]+VALS_IN_EDGES,pos[x]+sz[x]-1,v); }",
      "};"
    ],
    "description": "Heavy-Light Decomposition, add val to verts ,  * and query sum in path/subtree., * Time: any tree path is split into \\$O(\\log N)\\$ parts, *"
  },
  "LCAjump": {
    "prefix":["benq_LCAjump"],
    "body": [
      "/**",
      " * Description: Calculates least common ancestor in tree with verts ",
      " \t* \\$0\\ldots N-1\\$ and root \\$R\\$ using binary jumping. ",
      " * Time: O(N\\log N) build, O(\\log N) query",
      " * Memory: O(N\\log N)",
      " * Source: USACO Camp, KACTL",
      " * Verification: *",
      " */",
      "",
      "struct LCA {",
      "\tint N; vector<vi> par, adj; vi depth;",
      "\tvoid init(int _N) {  N = _N;",
      "\t\tint d = 1; while ((1<<d) < N) d ++;",
      "\t\tpar.assign(d,vi(N)); adj.rsz(N); depth.rsz(N);",
      "\t}",
      "\tvoid ae(int x, int y) { adj[x].pb(y), adj[y].pb(x); }",
      "\tvoid gen(int R = 0) { par[0][R] = R; dfs(R); }",
      "\tvoid dfs(int x = 0) {",
      "\t\tFOR(i,1,sz(par)) par[i][x] = par[i-1][par[i-1][x]];",
      "\t\teach(y,adj[x]) if (y != par[0][x]) ",
      "\t\t\tdepth[y] = depth[par[0][y]=x]+1, dfs(y);",
      "\t}",
      "\tint jmp(int x, int d) {",
      "\t\tF0R(i,sz(par)) if ((d>>i)&1) x = par[i][x];",
      "\t\treturn x; }",
      "\tint lca(int x, int y) {",
      "\t\tif (depth[x] < depth[y]) swap(x,y);",
      "\t\tx = jmp(x,depth[x]-depth[y]); if (x == y) return x;",
      "\t\tR0F(i,sz(par)) {",
      "\t\t\tint X = par[i][x], Y = par[i][y];",
      "\t\t\tif (X != Y) x = X, y = Y;",
      "\t\t}",
      "\t\treturn par[0][x];",
      "\t}",
      "\tint dist(int x, int y) { // # edges on path",
      "\t\treturn depth[x]+depth[y]-2*depth[lca(x,y)]; }",
      "};"
    ],
    "description": "Calculates least common ancestor in tree with verts ,  * \\$0\\ldots N-1\\$ and root \\$R\\$ using binary jumping. , * Time: O(N\\log N) build, O(\\log N) query, * Memory: O(N\\log N), *"
  },
  "LCArmq": {
    "prefix":["benq_LCArmq"],
    "body": [
      "/**",
      " * Description: Euler Tour LCA. Compress takes a subset \\$S\\$ of nodes ",
      " \t* and computes the minimal subtree that contains all the nodes ",
      "\t* pairwise LCAs and compressing edges. Returns a list of",
      "\t* \\texttt{(par, orig\\_index)} representing a tree rooted at 0. ",
      "\t* The root points to itself.",
      " * Time: O(N\\log N) build, O(1) LCA, O(|S|\\log |S|) compress",
      " * Source: USACO, Simon Lindholm (KACTL)",
      " * Verification: USACO Debug the Bugs",
      " \t* https://codeforces.com/contest/1320/problem/E",
      " */",
      "",
      "#include \"../../data-structures/Static Range Queries (9.1)/RMQ (9.1).h\"",
      "",
      "struct LCA {",
      "\tint N; vector<vi> adj;",
      "\tvi depth, pos, par, rev; // rev is for compress",
      "\tvpi tmp; RMQ<pi> r;",
      "\tvoid init(int _N) { N = _N; adj.rsz(N); ",
      "\t\tdepth = pos = par = rev = vi(N); }",
      "\tvoid ae(int x, int y) { adj[x].pb(y), adj[y].pb(x); }",
      "\tvoid dfs(int x) {",
      "\t\tpos[x] = sz(tmp); tmp.eb(depth[x],x); ",
      "\t\teach(y,adj[x]) if (y != par[x]) {",
      "\t\t\tdepth[y] = depth[par[y]=x]+1, dfs(y);",
      "\t\t\ttmp.eb(depth[x],x); }",
      "\t}",
      "\tvoid gen(int R = 0) { par[R] = R; dfs(R); r.init(tmp); }",
      "\tint lca(int u, int v){",
      "\t\tu = pos[u], v = pos[v]; if (u > v) swap(u,v);",
      "\t\treturn r.query(u,v).s; }",
      "\tint dist(int u, int v) {",
      "\t\treturn depth[u]+depth[v]-2*depth[lca(u,v)]; }",
      "\tvpi compress(vi S) {",
      "\t\tauto cmp = [&](int a, int b) { return pos[a] < pos[b]; };",
      "\t\tsort(all(S),cmp); R0F(i,sz(S)-1) S.pb(lca(S[i],S[i+1]));",
      "\t\tsort(all(S),cmp); S.erase(unique(all(S)),end(S));",
      "\t\tvpi ret{{0,S[0]}}; F0R(i,sz(S)) rev[S[i]] = i;",
      "\t\tFOR(i,1,sz(S)) ret.eb(rev[lca(S[i-1],S[i])],S[i]);",
      "\t\treturn ret;",
      "\t}",
      "};"
    ],
    "description": "Euler Tour LCA. Compress takes a subset \\$S\\$ of nodes ,  * and computes the minimal subtree that contains all the nodes , * pairwise LCAs and compressing edges. Returns a list of, * \\texttt{(par, orig\\_index)} representing a tree rooted at 0. , * The root points to itself., * Time: O(N\\log N) build, O(1) LCA, O(|S|\\log |S|) compress, *"
  },
  "SmallToLarge": {
    "prefix":["benq_SmallToLarge"],
    "body": [
      "/**",
      " * Description: offline subtree queries in \\$O(N\\log^2N)\\$",
      " * Source: own",
      " * Verification: January Easy 2018 - Shubham & Tree 1",
      " */",
      "",
      "struct SmallToLarge {",
      "\tint val[MX];",
      "\tvi child[MX];",
      "\tmap<int,int> dat[MX];",
      "\tvoid comb(int a, int b) {",
      "\t\tbool swa = 0;",
      "\t\tif (sz(dat[a]) < sz(dat[b])) swap(a,b), swa = 1; ",
      "\t\t// note: swapping doesn't seem to work for indexed set",
      "\t\teach(x,dat[b]) dat[a][x.f] += x.s;",
      "\t\tdat[b].clear();",
      "\t\tif (swa) swap(dat[a],dat[b]);",
      "\t}",
      "\tvoid process(int ind) {",
      "\t\tdat[ind][val[ind]] ++;",
      "\t\teach(i,child[ind]) {",
      "\t\t\tprocess(i); ",
      "\t\t\tcomb(ind,i);",
      "\t\t}",
      "\t\t// now do stuff with values",
      "\t}",
      "};"
    ],
    "description": "offline subtree queries in \\$O(N\\log^2N)\\$, *"
  },
  "TreeDiameter": {
    "prefix":["benq_TreeDiameter"],
    "body": [
      "/**",
      " * Description: Calculates longest path in tree. The vertex furthest",
      " \t* from 0 must be an endpoint of the diameter.",
      " * Source: own",
      " * Verification: ",
      "   * http://www.spoj.com/problems/PT07Z/",
      "   * https://codeforces.com/contest/1182/problem/D",
      " */",
      "",
      "template<int SZ> struct TreeDiameter {",
      "\tint N, par[SZ], dist[SZ], diaLen;  ",
      "\tvi adj[SZ], dia, center;",
      "\tvoid ae(int a, int b) { adj[a].pb(b), adj[b].pb(a); }",
      "\tvoid dfs(int x) {",
      "\t\teach(y,adj[x]) if (y != par[x]) {",
      "\t\t\tpar[y] = x; dist[y] = dist[x]+1; ",
      "\t\t\tdfs(y); }",
      "\t}",
      "\tvoid genDist(int x) { par[x] = -1; dist[x] = 0; dfs(x); }",
      "\tvoid init(int _N) {",
      "\t\tN = _N; dia = {0,0}; ",
      "\t\tgenDist(0); F0R(i,N) if (dist[i]>dist[dia[0]]) dia[0] = i; ",
      "\t\tgenDist(dia[0]); F0R(i,N) if (dist[i]>dist[dia[1]]) dia[1] = i;",
      "\t\tdiaLen = dist[dia[1]];",
      "\t\tint cen = dia[1]; F0R(i,diaLen/2) cen = par[cen];",
      "\t\tcenter = {cen}; if (diaLen&1) center.pb(par[cen]);",
      "\t}",
      "};"
    ],
    "description": "Calculates longest path in tree. The vertex furthest,  * from 0 must be an endpoint of the diameter., *"
  },
  "CRT": {
    "prefix":["benq_CRT"],
    "body": [
      "/**",
      " * Description: Chinese Remainder Theorem. ",
      " \t* \\$a.f\\pmod{a.s},b.f\\pmod{b.s}\\$ \\$\\implies ? \\pmod{\\text{lcm}(a.s,b.s)}\\$. ",
      " \t* Should work for \\$ab<2^{62}\\$.",
      " * Source: KACTL",
      " * Verification: Kattis generalchineseremainder",
      " */",
      "",
      "#include \"Euclid.h\"",
      "",
      "pl CRT(pl a, pl b) {",
      "\tif (a.s < b.s) swap(a,b);",
      "\tll x,y; tie(x,y) = euclid(a.s,b.s); ",
      "\tll g = a.s*x+b.s*y, l = a.s/g*b.s;",
      "\tif ((b.f-a.f)%g) return {-1,-1}; // no solution",
      "\t// ?*a.s+a.f \\equiv b.f \\pmod{b.s}",
      "\t// ?=(b.f-a.f)/g*(a.s/g)^{-1} \\pmod{b.s/g}",
      "\tx = (b.f-a.f)%b.s*x%b.s/g*a.s+a.f; ",
      "\treturn {x+(x<0)*l,l};",
      "}"
    ],
    "description": "Chinese Remainder Theorem. ,  * \\$a.f\\pmod{a.s},b.f\\pmod{b.s}\\$ \\$\\implies ? \\pmod{\\text{lcm}(a.s,b.s)}\\$. ,  * Should work for \\$ab<2^{62}\\$., *"
  },
  "Euclid": {
    "prefix":["benq_Euclid"],
    "body": [
      "/**",
      " * Description: Generalized Euclidean algorithm. \\texttt{euclid} and ",
      " \t* \\texttt{invGen} work for \\$A,B<2^{62}\\$. \\texttt{bet} assumes ",
      " \t* that \\$0\\le L\\le R<B\\$, works for \\$AB<2^{62}\\$.",
      " * Source: KACTL",
      " \t* https://codeforces.com/gym/102411/submission/64315879",
      " * Time: O(\\log AB)",
      " * Verification: https://codeforces.com/gym/102411/problem/G",
      " */",
      "",
      "pl euclid(ll A, ll B) { // find (x,y) such that \\$Ax+By=\\gcd(A,B)\\$, \\$|Ax|,|By|\\le \\frac{AB}{\\gcd(A,B)}\\$",
      "\tif (!B) return {1,0};",
      "\tpl p = euclid(B,A%B); return {p.s,p.f-A/B*p.s}; }",
      "ll invGen(ll A, ll B) { // find x in [0,B) such that Ax = 1 mod B",
      "\tpl p = euclid(A,B); assert(p.f*A+p.s*B == 1); // gcd must be 1",
      "\treturn p.f+(p.f<0)*B; }",
      "ll bet(ll A, ll B, ll L, ll R) { // min x s.t. exists y s.t. L <= A*x-B*y <= R",
      "\tA %= B; if (A == 0) return L == 0 ? 0 : -1; // try y = 0",
      "\tll k = cdiv(L,A); if (A*k <= R) return k;",
      "\tll x = bet(B,A,A-R%A,A-L%A); // find min x s.t. exists y s.t. -R <= Bx-Ay <= -L",
      "\treturn x == -1 ? x : cdiv(B*x+L,A); // solve for y",
      "}",
      "",
      "/**",
      "ll BET(ll A, ll B, ll L, ll R) {",
      "\tF0R(i,B) {",
      "\t\tll prod = A*i%B;",
      "\t\tif (L <= prod && prod <= R) return i;",
      "\t}",
      "\treturn -1;",
      "}",
      "",
      "int main() {",
      "\tsetIO();",
      "\tFOR(i,1,101) FOR(j,1,101) F0R(L,j) FOR(R,L,j) {",
      "\t\tll a = bet(i,j,L,R);",
      "\t\tll b = BET(i,j,L,R);",
      "\t\tif (a != b) {",
      "\t\t\tdbg(i,j,L,R);",
      "\t\t\tdbg(a);",
      "\t\t\tdbg(b);",
      "\t\t\texit(0);",
      "\t\t}",
      "\t}",
      "\tdbg(\"OK\");",
      "}",
      "*/"
    ],
    "description": "Generalized Euclidean algorithm. \\texttt{euclid} and ,  * \\texttt{invGen} work for \\$A,B<2^{62}\\$. \\texttt{bet} assumes ,  * that \\$0\\le L\\le R<B\\$, works for \\$AB<2^{62}\\$., *"
  },
  "FracInterval": {
    "prefix":["benq_FracInterval"],
    "body": [
      "/**",
      " * Description: Given fractions \\$a<b\\$ with non-negative numerators and denominators, ",
      " \t* finds fraction \\$f\\$ with lowest denominator such that \\$a<f<b.\\$ Should work with ",
      "\t* all numbers less than \\$2^{62}.\\$",
      " * Source: ?",
      " * Verification: http://acm.hdu.edu.cn/showproblem.php?pid=6624",
      " */",
      "",
      "pl bet(pl a, pl b) {",
      "\tll num = a.f/a.s; a.f -= num*a.s, b.f -= num*b.s;",
      "\tif (b.f > b.s) return {1+num,1};",
      "\tauto x = bet({b.s,b.f},{a.s,a.f});",
      "\treturn {x.s+num*x.f,x.f};",
      "}"
    ],
    "description": "Given fractions \\$a<b\\$ with non-negative numerators and denominators, ,  * finds fraction \\$f\\$ with lowest denominator such that \\$a<f<b.\\$ Should work with , * all numbers less than \\$2^{62}.\\$, *"
  },
  "DiscreteLog": {
    "prefix":["benq_DiscreteLog"],
    "body": [
      "/**",
      " * Description: find least integer p such that r^p=x(mod MOD)",
      "\t* meet in the middle: O(sqrt(mod)) per query",
      " * Source: Own",
      " * Verification: https://www.hackerrank.com/contests/infinitum11/challenges/discrete-logarithm/problem",
      " */",
      "",
      "#include \"ModInt.h\"",
      "",
      "struct DiscreteLog {",
      "\tint root, block;",
      "\tunordered_map<int,int> u;",
      "\tmi cur;",
      "\tint query(mi x) { ",
      "\t\tF0R(i,block) {",
      "\t\t\tif (u.count((int)x)) return i*block+u[(int)x];",
      "\t\t\tx *= cur;",
      "\t\t}",
      "\t\treturn -1;",
      "\t}",
      "\tvoid init(int r) { // gcd(m,r) = 1",
      "\t\troot = r; block = sqrt(MOD)+1;",
      "\t\tu.clear(); cur = mi(1);",
      "\t\tF0R(i,block) {",
      "\t\t\tif (!u.count((int)cur)) u[(int)cur] = i;",
      "\t\t\tcur *= root;",
      "\t\t}",
      "\t\tcur = 1/cur;",
      "\t} ",
      "};"
    ],
    "description": "find least integer p such that r^p=x(mod MOD), * meet in the middle: O(sqrt(mod)) per query, *"
  },
  "FastMod": {
    "prefix":["benq_FastMod"],
    "body": [
      "/**",
      " * Description: Barrett reduction computes \\$a \\% b\\$ about 4 times faster than usual ",
      " \t* where \\$b>1\\$ is constant but not known at compile time. Division by \\$b\\$ is replaced",
      " \t* by multiplication by m and shifting right 64 bits.",
      " * Source: KACTL",
      " \t* https://github.com/kth-competitive-programming/kactl/blob/master/content/various/FastMod.h",
      " \t* https://en.wikipedia.org/wiki/Barrett_reduction",
      " * Verification: http://www.usaco.org/index.php?page=viewproblem2&cpid=1045",
      " */",
      "",
      "using ul = uint64_t; using L = __uint128_t;",
      "struct FastMod {",
      "\tul b,m; FastMod(ul _b) : b(_b), m(ul((L(1)<<64)/_b)) {}",
      "\tul reduce(ul a) {",
      "\t\tul q = (ul)((L(m)*a)>>64), r = a-q*b;",
      "\t\treturn r>=b?r-b:r; }",
      "};"
    ],
    "description": "Barrett reduction computes \\$a \\% b\\$ about 4 times faster than usual ,  * where \\$b>1\\$ is constant but not known at compile time. Division by \\$b\\$ is replaced,  * by multiplication by m and shifting right 64 bits., *"
  },
  "ModFact": {
    "prefix":["benq_ModFact"],
    "body": [
      "/**",
      " * Description: pre-compute factorial mod inverses,",
      " \t* assumes \\$MOD\\$ is prime and \\$SZ < MOD\\$.",
      " * Time: O(SZ)",
      " * Source: KACTL",
      " * Verification: https://dmoj.ca/problem/tle17c4p5",
      " */",
      "",
      "vmi invs, fac, ifac; // make sure to convert to LL before doing any multiplications ...",
      "void genFac(int SZ) {",
      "\tinvs.rsz(SZ), fac.rsz(SZ), ifac.rsz(SZ); ",
      "\tinvs[1] = fac[0] = ifac[0] = 1; ",
      "\tFOR(i,2,SZ) invs[i] = mi(-(ll)MOD/i*(int)invs[MOD%i]);",
      "\tFOR(i,1,SZ) {",
      "\t\tfac[i] = fac[i-1]*i;",
      "\t\tifac[i] = ifac[i-1]*invs[i];",
      "\t}",
      "}",
      "mi comb(int a, int b) {",
      "\tif (a < b || b < 0) return 0;",
      "\treturn fac[a]*ifac[b]*ifac[a-b];",
      "}"
    ],
    "description": "pre-compute factorial mod inverses,,  * assumes \\$MOD\\$ is prime and \\$SZ < MOD\\$., * Time: O(SZ), *"
  },
  "ModFactInt": {
    "prefix":["benq_ModFactInt"],
    "body": [
      "/**",
      " * Description: pre-compute factorial mod inverses,",
      " \t* assumes \\$MOD\\$ is prime and \\$SZ < MOD\\$.",
      " * Time: O(SZ)",
      " * Source: KACTL",
      " * Verification: https://dmoj.ca/problem/tle17c4p5",
      " */",
      "",
      "vi invs, fac, ifac; // make sure to convert to LL before doing any multiplications ...",
      "void genFac(int SZ) {",
      "\tinvs.rsz(SZ), fac.rsz(SZ), ifac.rsz(SZ); ",
      "\tinvs[1] = fac[0] = ifac[0] = 1; ",
      "\tFOR(i,2,SZ) invs[i] = int(MOD-(ll)MOD/i*invs[MOD%i]%MOD);",
      "\tFOR(i,1,SZ) {",
      "\t\tfac[i] = int((ll)fac[i-1]*i%MOD);",
      "\t\tifac[i] = int((ll)ifac[i-1]*invs[i]%MOD);",
      "\t}",
      "}",
      "/**",
      "ll comb(int a, int b) {",
      "\tif (a < b || b < 0) return 0;",
      "\treturn (ll)fac[a]*ifac[b]%MOD*ifac[a-b]%MOD;",
      "}",
      "*/"
    ],
    "description": "pre-compute factorial mod inverses,,  * assumes \\$MOD\\$ is prime and \\$SZ < MOD\\$., * Time: O(SZ), *"
  },
  "ModInt": {
    "prefix":["benq_ModInt"],
    "body": [
      "/**",
      " * Description: modular arithmetic operations ",
      " * Source: ",
      "\t* KACTL",
      "\t* https://codeforces.com/blog/entry/63903",
      "\t* https://codeforces.com/contest/1261/submission/65632855 (tourist)",
      "\t* https://codeforces.com/contest/1264/submission/66344993 (ksun)",
      "\t* also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp (ecnerwal)",
      " * Verification: ",
      "\t* https://open.kattis.com/problems/modulararithmetic",
      " */",
      "",
      "template<int MOD, int RT> struct mint {",
      "\tstatic const int mod = MOD;",
      "\tstatic constexpr mint rt() { return RT; } // primitive root for FFT",
      "\tint v; explicit operator int() const { return v; } // explicit -> don't silently convert to int",
      "\tmint() { v = 0; }",
      "\tmint(ll _v) { v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);",
      "\t\tif (v < 0) v += MOD; }",
      "\tfriend bool operator==(const mint& a, const mint& b) { ",
      "\t\treturn a.v == b.v; }",
      "\tfriend bool operator!=(const mint& a, const mint& b) { ",
      "\t\treturn !(a == b); }",
      "\tfriend bool operator<(const mint& a, const mint& b) { ",
      "\t\treturn a.v < b.v; }",
      "\tfriend void re(mint& a) { ll x; re(x); a = mint(x); }",
      "\tfriend str ts(mint a) { return ts(a.v); }",
      "   ",
      "\tmint& operator+=(const mint& m) { ",
      "\t\tif ((v += m.v) >= MOD) v -= MOD; ",
      "\t\treturn *this; }",
      "\tmint& operator-=(const mint& m) { ",
      "\t\tif ((v -= m.v) < 0) v += MOD; ",
      "\t\treturn *this; }",
      "\tmint& operator*=(const mint& m) { ",
      "\t\tv = int((ll)v*m.v%MOD); return *this; }",
      "\tmint& operator/=(const mint& m) { return (*this) *= inv(m); }",
      "\tfriend mint pow(mint a, ll p) {",
      "\t\tmint ans = 1; assert(p >= 0);",
      "\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;",
      "\t\treturn ans; }",
      "\tfriend mint inv(const mint& a) { assert(a.v != 0); ",
      "\t\treturn pow(a,MOD-2); }",
      "\t\t",
      "\tmint operator-() const { return mint(-v); }",
      "\tmint& operator++() { return *this += 1; }",
      "\tmint& operator--() { return *this -= 1; }",
      "\tfriend mint operator+(mint a, const mint& b) { return a += b; }",
      "\tfriend mint operator-(mint a, const mint& b) { return a -= b; }",
      "\tfriend mint operator*(mint a, const mint& b) { return a *= b; }",
      "\tfriend mint operator/(mint a, const mint& b) { return a /= b; }",
      "};",
      "",
      "typedef mint<MOD,5> mi; // 5 is primitive root for both common mods",
      "typedef vector<mi> vmi;",
      "typedef pair<mi,mi> pmi;",
      "typedef vector<pmi> vpmi;",
      "",
      "vector<vmi> scmb; // small combinations",
      "void genComb(int SZ) {",
      "\tscmb.assign(SZ,vmi(SZ)); scmb[0][0] = 1;",
      "\tFOR(i,1,SZ) F0R(j,i+1) ",
      "\t\tscmb[i][j] = scmb[i-1][j]+(j?scmb[i-1][j-1]:0);",
      "}"
    ],
    "description": "modular arithmetic operations , *"
  },
  "ModIntDynamic": {
    "prefix":["benq_ModIntDynamic"],
    "body": [
      "/**",
      " * Description: modular arithmetic operations ",
      " * Source: ",
      "\t* KACTL",
      "\t* https://codeforces.com/blog/entry/63903",
      "\t* https://codeforces.com/contest/1261/submission/65632855 (tourist)",
      "\t* https://codeforces.com/contest/1264/submission/66344993 (ksun)",
      "\t* also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp (ecnerwal)",
      "\t* https://github.com/atcoder/ac-library/blob/master/atcoder/modint.hpp",
      " * Verification: ",
      "\t* https://open.kattis.com/problems/modulararithmetic",
      " */",
      "",
      "template<int id> struct mint {",
      "\tstatic FastMod MF;",
      "\tstatic int mod() { return (int)MF.b; }",
      "\tstatic void set_mod(int m) { assert(1 <= m); MF = FastMod(m); }",
      "\tint v; explicit operator int() const { return v; } // explicit -> don't silently convert to int",
      "\tmint() { v = 0; }",
      "\tmint(ll _v) { v = int((-mod() < _v && _v < mod()) ? _v : _v % mod());",
      "\t\tif (v < 0) v += mod(); }",
      "\tfriend bool operator==(const mint& a, const mint& b) { ",
      "\t\treturn a.v == b.v; }",
      "\tfriend bool operator!=(const mint& a, const mint& b) { ",
      "\t\treturn !(a == b); }",
      "\tfriend bool operator<(const mint& a, const mint& b) { ",
      "\t\treturn a.v < b.v; }",
      "\tfriend void re(mint& a) { ll x; re(x); a = mint(x); }",
      "\tfriend str ts(mint a) { return ts(a.v); }",
      "   ",
      "\tmint& operator+=(const mint& m) { ",
      "\t\tif ((v += m.v) >= mod()) v -= mod(); ",
      "\t\treturn *this; }",
      "\tmint& operator-=(const mint& m) { ",
      "\t\tif ((v -= m.v) < 0) v += mod(); ",
      "\t\treturn *this; }",
      "\tmint& operator*=(const mint& m) { ",
      "\t\tv = (int)MF.reduce((ll)v*m.v); return *this; }",
      "\tmint& operator/=(const mint& m) { return (*this) *= inv(m); }",
      "\tfriend mint pow(mint a, ll p) {",
      "\t\tmint ans = 1; assert(p >= 0);",
      "\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;",
      "\t\treturn ans; }",
      "\tfriend mint inv(const mint& a) { assert(a.v != 0); ",
      "\t\treturn pow(a,mod()-2); }",
      "\t\t",
      "\tmint operator-() const { return mint(-v); }",
      "\tmint& operator++() { return *this += 1; }",
      "\tmint& operator--() { return *this -= 1; }",
      "\tfriend mint operator+(mint a, const mint& b) { return a += b; }",
      "\tfriend mint operator-(mint a, const mint& b) { return a -= b; }",
      "\tfriend mint operator*(mint a, const mint& b) { return a *= b; }",
      "\tfriend mint operator/(mint a, const mint& b) { return a /= b; }",
      "};",
      "template<int id> FastMod mint<id>::MF = FastMod(1);",
      "",
      "typedef mint<0> mi; // 5 is primitive root for both common mods",
      "typedef vector<mi> vmi;",
      "typedef pair<mi,mi> pmi;",
      "typedef vector<pmi> vpmi;",
      "",
      "vector<vmi> scmb; // small combinations",
      "void genComb(int SZ) {",
      "\tscmb.assign(SZ,vmi(SZ)); scmb[0][0] = 1;",
      "\tFOR(i,1,SZ) F0R(j,i+1) ",
      "\t\tscmb[i][j] = scmb[i-1][j]+(j?scmb[i-1][j-1]:0);",
      "}"
    ],
    "description": "modular arithmetic operations , *"
  },
  "ModIntShort": {
    "prefix":["benq_ModIntShort"],
    "body": [
      "/**",
      " * Description: Modular arithmetic.",
      " * Source: KACTL",
      " * Verification: https://open.kattis.com/problems/modulararithmetic",
      " */",
      "",
      "struct mi {",
      " \tint v; explicit operator int() const { return v; } ",
      "\tmi() { v = 0; }",
      "\tmi(ll _v):v(_v%MOD) { v += (v<0)*MOD; }",
      "};",
      "mi& operator+=(mi& a, mi b) { ",
      "\tif ((a.v += b.v) >= MOD) a.v -= MOD; ",
      "\treturn a; }",
      "mi& operator-=(mi& a, mi b) { ",
      "\tif ((a.v -= b.v) < 0) a.v += MOD; ",
      "\treturn a; }",
      "mi operator+(mi a, mi b) { return a += b; }",
      "mi operator-(mi a, mi b) { return a -= b; }",
      "mi operator*(mi a, mi b) { return mi((ll)a.v*b.v); }",
      "mi& operator*=(mi& a, mi b) { return a = a*b; }",
      "mi pow(mi a, ll p) { assert(p >= 0); // asserts are important! ",
      "\treturn p==0?1:pow(a*a,p/2)*(p&1?a:1); }",
      "mi inv(mi a) { assert(a.v != 0); return pow(a,MOD-2); }",
      "mi operator/(mi a, mi b) { return a*inv(b); }",
      "/// mi a = MOD+5; ps((int)inv(a));"
    ],
    "description": "Modular arithmetic., *"
  },
  "ModMulLL": {
    "prefix":["benq_ModMulLL"],
    "body": [
      "/**",
      " * Description: Multiply two 64-bit integers mod another if 128-bit is not available.",
      "\t* modMul is equivalent to \\texttt{(ul)(\\_\\_int128(a)*b\\%mod)}. ",
      "\t* Works for \\$0\\le a,b<mod<2^{63}.\\$",
      " * Source: KACTL",
      " * Verification: see \"Faster Factoring\"",
      " */",
      "",
      "using ul = unsigned long long;",
      "ul modMul(ul a, ul b, const ul mod) {",
      "\tll ret = a*b-mod*(ul)((ld)a*b/mod);",
      "\treturn ret+((ret<0)-(ret>=(ll)mod))*mod; }",
      "ul modPow(ul a, ul b, const ul mod) {",
      "\tif (b == 0) return 1;",
      "\tul res = modPow(a,b/2,mod); res = modMul(res,res,mod);",
      "\treturn b&1 ? modMul(res,a,mod) : res;",
      "}"
    ],
    "description": "Multiply two 64-bit integers mod another if 128-bit is not available., * modMul is equivalent to \\texttt{(ul)(\\_\\_int128(a)*b\\%mod)}. , * Works for \\$0\\le a,b<mod<2^{63}.\\$, *"
  },
  "ModSqrt": {
    "prefix":["benq_ModSqrt"],
    "body": [
      "/**",
      " * Description: square root of integer mod a prime",
      " * Time: O(\\log^2(MOD))",
      " * Source: http://www.math.vt.edu/people/brown/class_homepages/shanks_tonelli.pdf",
      " * Verification: https://www.spoj.com/problems/CRYPTO1",
      " */",
      "",
      "#include \"ModInt.h\"",
      "",
      "T sqrt(mi a) { ",
      "\tmi p = pow(a,(MOD-1)/2); if (p != 1) return p == 0 ? 0 : -1;",
      "\t/// check if 0 or no sqrt",
      "\tT s = MOD-1; int e = 0; while (s % 2 == 0) s /= 2, e ++;",
      "\t// find non-square ",
      "\tmi n = 1; while (pow(n,(MOD-1)/2) == 1) n = T(n)+1; ",
      "\tmi x = pow(a,(s+1)/2), b = pow(a,s), g = pow(n,s);",
      "\tint r = e;",
      "\twhile (1) {",
      "\t\tmi B = b; int m = 0; while (B != 1) B *= B, m ++;",
      "\t\tif (m == 0) return min((T)x,MOD-(T)x);",
      "\t\tF0R(i,r-m-1) g *= g;",
      "\t\tx *= g; g *= g; b *= g; r = m;",
      "\t}",
      "}"
    ],
    "description": "square root of integer mod a prime, * Time: O(\\log^2(MOD)), *"
  },
  "ModSum": {
    "prefix":["benq_ModSum"],
    "body": [
      "/**",
      " * Description: divsum computes \\$\\sum_{i=0}^{to-1}\\left\\lfloor\\frac{ki+c}{m}\\right\\rfloor,\\$ ",
      " \t* modsum defined similarly",
      " * Time: O(\\log m)",
      " * Source: KACTL",
      " \t* https://codeforces.com/gym/102135/problem/G",
      " * Verification: https://open.kattis.com/problems/aladin",
      " */",
      "",
      "using ul = unsigned long long;",
      "ul sumsq(ul to) { return (to-1)*to/2; } // sum of 0..to-1",
      "ul divsum(ul to, ul c, ul k, ul m) { // k >= 0, m > 0",
      "\tul res = k/m*sumsq(to)+c/m*to;",
      "\tk %= m; c %= m; if (!k) return res;",
      "\tul to2 = (to*k+c)/m;",
      "\treturn res+(to-1)*to2-divsum(to2,m-1-c,m,k); ",
      "}",
      "ll modsum(ul to, ll c, ll k, ll m) {",
      "\tc = (c%m+m)%m, k = (k%m+m)%m;",
      "\treturn to*c+k*sumsq(to)-m*divsum(to,c,k,m); }"
    ],
    "description": "divsum computes \\$\\sum_{i=0}^{to-1}\\left\\lfloor\\frac{ki+c}{m}\\right\\rfloor,\\$ ,  * modsum defined similarly, * Time: O(\\log m), *"
  },
  "Order": {
    "prefix":["benq_Order"],
    "body": [
      "/**",
      " * Description: Calculates smallest P such that x^P equiv 1 (mod p)",
      " * Source: Own",
      " * Verification: https://atcoder.jp/contests/jag2015summer-day4/tasks/icpc2015summer_day4_d",
      " */",
      "",
      "#include \"ModMulLL.h\"",
      "#include \"../Primality/FactorBasic.h\"",
      "",
      "ll order(ll x, ll p) {",
      "\tif (__gcd(x,p) != 1) return 0;",
      "\tll P = phi(p); auto a = factor(P);",
      "\teach(t,a) while (P % t.f == 0 ",
      "\t\t&& modPow(x,P/t.f,p) == 1) P /= t.f;",
      "\treturn P;",
      "}"
    ],
    "description": "Calculates smallest P such that x^P equiv 1 (mod p), *"
  },
  "FactorBasic": {
    "prefix":["benq_FactorBasic"],
    "body": [
      "/**",
      " * Description: Factors integers.",
      " * Time: O(\\sqrt N)",
      " * Source: Own",
      " * Verification: https://csacademy.com/contest/ceoi-2018-day-2/task/toys-big/",
      " */",
      "",
      "namespace factorBasic {",
      "\ttemplate<class T> vector<pair<T,int>> factor(T x) { ",
      "\t\tvector<pair<T,int>> pri;",
      "\t\tfor (T i = 2; i*i <= x; ++i) if (x % i == 0) {",
      "\t\t\tint t = 0;",
      "\t\t\twhile (x % i == 0) x /= i, t ++;",
      "\t\t\tpri.pb({i,t});",
      "\t\t}",
      "\t\tif (x > 1) pri.pb({x,1});",
      "\t\treturn pri;",
      "\t}",
      "\t/* Note:",
      "\t * number of operations needed s.t.",
      "\t *\t\t\t\t  phi(phi(...phi(n)...))=1",
      "\t * is O(log n).",
      "\t * Euler's theorem: a^{\\phi(p)}\\equiv 1 (mod p), gcd(a,p)=1",
      "\t */",
      "\tll phi(ll x) {",
      "\t\teach(a,factor(x)) x -= x/a.f;",
      "\t\treturn x;",
      "\t}",
      "\ttemplate<class T> void tour(vector<pair<T,int>>& v, ",
      "\t\tvector<T>& V, int ind, T cur) {",
      "\t\t\tif (ind == sz(v)) V.pb(cur);",
      "\t\t\telse {",
      "\t\t\t\tT mul = 1;",
      "\t\t\t\tF0R(i,v[ind].s+1) {",
      "\t\t\t\t\ttour(v,V,ind+1,cur*mul);",
      "\t\t\t\t\tmul *= v[ind].f;",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t}",
      "\ttemplate<class T> vector<T> getDivi(T x) {",
      "\t\tauto v = factor(x);",
      "\t\tvector<T> V; tour(v,V,0,(T)1); sort(all(V));",
      "\t\treturn V;",
      "\t}",
      "}",
      "",
      "using namespace factorBasic;"
    ],
    "description": "Factors integers., * Time: O(\\sqrt N), *"
  },
  "FactorFast": {
    "prefix":["benq_FactorFast"],
    "body": [
      "/**",
      " * Description: Pollard's rho factors integers up to \\$2^{60}\\$. ",
      " \t* Returns primes in sorted order.",
      " * Time: \\$O(N^{1/4})\\$ gcd calls, less for numbers with small factors",
      " * Source: KACTL",
      "\t* https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm",
      "\t* https://codeforces.com/contest/1033/submission/44009089 is faster",
      " * Verification: https://www.spoj.com/problems/FACT0/",
      " */",
      "",
      "#include \"PrimeSieve.h\"",
      "#include \"MillerRabin.h\"",
      "#include \"../Modular Arithmetic/ModMulLL.h\"",
      "",
      "Sieve<1<<20> S; // primes up to N^{1/3}",
      "ul pollard(ul n) {",
      "\tauto f = [n](ul x) { return (modMul(x,x,n)+1)%n; };",
      "\tif (!(n&1)) return 2;",
      "\tfor (ul i = 2;;++i) {",
      "\t\tul x = i, y = f(x), p;",
      "\t\twhile ((p = __gcd(n+y-x,n)) == 1) x = f(x), y = f(f(y));",
      "\t\tif (p != n) return p;",
      "\t}",
      "}",
      "vpl factor(ll d) {",
      "\tvpl res; ",
      "\teach(t,S.pr) {",
      "\t\tif ((ul)t*t > d) break;",
      "\t\tif (d%t == 0) {",
      "\t\t\tres.pb({t,0}); ",
      "\t\t\twhile (d%t == 0) d /= t, res.bk.s ++;",
      "\t\t}",
      "\t}",
      "\tif (prime(d)) res.pb({d,1}), d = 1;",
      "\tif (d == 1) return res; // now a product of at most 2 primes",
      "\tll c = pollard(d); d /= c; if (d > c) swap(d,c);",
      "\tif (c == d) res.pb({c,2});",
      "\telse res.pb({c,1}), res.pb({d,1});",
      "\treturn res;",
      "}"
    ],
    "description": "Pollard's rho factors integers up to \\$2^{60}\\$. ,  * Returns primes in sorted order., * Time: \\$O(N^{1/4})\\$ gcd calls, less for numbers with small factors, *"
  },
  "MillerRabin": {
    "prefix":["benq_MillerRabin"],
    "body": [
      "/**",
      " * Description: Deterministic primality test, works up to \\$2^{64}\\$.",
      " \t* For larger numbers, extend \\$A\\$ randomly.",
      " * Source: KACTL",
      "\t* https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test",
      " * Verification: https://www.spoj.com/problems/FACT0/",
      " */",
      "",
      "#include \"ModMulLL.h\"",
      "",
      "bool prime(ul n) { // not ll!",
      "\tif (n < 2 || n % 6 % 4 != 1) return n-2 < 2;",
      "\tul A[] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022},",
      "\t    s = __builtin_ctzll(n-1), d = n>>s;",
      "\teach(a,A) {   // ^ count trailing zeroes",
      "\t\tul p = modPow(a,d,n), i = s;",
      "\t\twhile (p != 1 && p != n-1 && a%n && i--) p = modMul(p,p,n);",
      "\t\tif (p != n-1 && i != s) return 0;",
      "\t}",
      "\treturn 1;",
      "}"
    ],
    "description": "Deterministic primality test, works up to \\$2^{64}\\$.,  * For larger numbers, extend \\$A\\$ randomly., *"
  },
  "MultiplicativePrefix": {
    "prefix":["benq_MultiplicativePrefix"],
    "body": [
      "/**",
      " * Description: Prefix sums of some multiplicative functions.",
      " \t* Solve for all square-free numbers in range, then fix.",
      " * Time: faster than \\$O(N^{2/3})\\$?",
      " * Source: Project Euler, https://oeis.org/A085731",
      " */",
      "",
      "#include \"Sieve.h\"",
      "",
      "ll pre0(ll n, int i) { // prod(primes) in factorization of x",
      "\tll res = n*(n+1)/2; // assume all square-free",
      "\tfor (;;++i) {",
      "\t\tll p = S.pr[i], nn = n/p/p; if (!nn) break;",
      "\t\tfor(ll coef=p*(p-1);nn;nn/=p)res-=coef*pre0(nn,i+1);",
      "\t}",
      "\treturn res;",
      "}",
      "ll pre1(ll n, int i) { // gcd of x and arithmetic derivative ",
      "\t// p^e contributes p^e if e%p == 0 and p^{e-1} otherwise",
      "\tll res = n; // assume all square-free",
      "\tfor (;;++i) {",
      "\t\tll p = S.pr[i], nn = n/p/p; if (!nn) break;",
      "\t\tll lst = 1, mul = p*p;",
      "\t\tfor (int e = 2; nn; mul *= p, nn /= p, ++e) {",
      "\t\t\tll nex = mul; if (e%p) nex /= p;",
      "\t\t\tif (lst != nex) res += (nex-lst)*pre1(nn,i+1); ",
      "\t\t\tlst = nex;",
      "\t\t}",
      "\t}",
      "\treturn res;",
      "}"
    ],
    "description": "Prefix sums of some multiplicative functions.,  * Solve for all square-free numbers in range, then fix., * Time: faster than \\$O(N^{2/3})\\$?, *"
  },
  "PrimeCnt": {
    "prefix":["benq_PrimeCnt"],
    "body": [
      "/**",
      " * Description: Counts number of primes up to \\$N\\$. Can also count ",
      " \t* sum of primes. For faster performance, only consider odd values",
      " \t* of \\texttt{i} in the loops involving \\texttt{B[i]}.",
      " * Time: \\$O(N^{3/4}/\\log N)\\$, works for \\$N=10^{11}\\$.",
      " * Source: https://www.topcoder.com/single-round-match-741-editorials/",
      " \t* also see faster https://codeforces.com/group/ZFgXbZSjvp/contest/274852/submission/76443529",
      " \t* https://blog.csdn.net/bestFy/article/details/80100244",
      " * Verification: ",
      " \t* https://codeforces.com/group/ZFgXbZSjvp/contest/274852/problem/A",
      " \t* https://www.spoj.com/problems/DIVCNT3/",
      " */",
      "",
      "#include \"Sieve.h\"",
      "",
      "ll N; vl A, B; // sieve should store primes up to sqrt(N) and one more",
      "ll primeCnt() { // A[i] stores # primes <= i",
      "\tint SN = sqrt(N);  A = B = vl(SN+1);",
      "\tFOR(i,1,SN+1) A[i] = i-1, B[i] = N/i-1;",
      "\tvd in(SN+1); FOR(i,1,SN+1) in[i] = 1.0/i;",
      "\teach(p,S.pr) { if (p > N/p) break;",
      "\t\tint np=A[p-1],mx=SN/p+1,r=min(N/p/p,(ll)SN);db tmp=N/p;",
      "\t\tFOR(i,1,mx) B[i]-=B[i*p]-np;",
      "\t\tFOR(i,mx,r+1) B[i]-=A[tmp*in[i]+1e-9]-np;",
      "\t\tROF(i,p,mx) for(;r>=i*p;--r) A[r]-=A[i]-np;",
      "\t} // B[i] stores # primes <= N/i",
      "\treturn B[1]; ",
      "}",
      "ll priNum(ll x) { return x < sz(A) ? A[x] : B[N/x]; }",
      "ll pre(ll n, int ind) { // sum_{i=1}^n(# divisors of i^3)",
      "\t// only consider #s with prime divisors >= p",
      "\tll p = S.pr[ind]; if (n < p) return 1;",
      "\tif (p*p > n) return 1+4*(priNum(n)-ind);",
      "\tll res = pre(n,ind+1);",
      "\tfor (int j=1;;++j) {",
      "\t\tn /= p; if (!n) break;",
      "\t\tres += (3*j+1)*pre(n,ind+1);",
      "\t}",
      "\treturn res;",
      "}"
    ],
    "description": "Counts number of primes up to \\$N\\$. Can also count ,  * sum of primes. For faster performance, only consider odd values,  * of \\texttt{i} in the loops involving \\texttt{B[i]}., * Time: \\$O(N^{3/4}/\\log N)\\$, works for \\$N=10^{11}\\$., *"
  },
  "PrimeCntNeal": {
    "prefix":["benq_PrimeCntNeal"],
    "body": [
      "/**",
      " * Description: Counts number of primes up to \\$n\\$. Can also count sum of primes.",
      " * Time: \\$O(n^{3/4}/\\log n)\\$",
      " * Source: neal",
      " * Verification: https://codeforces.com/group/ZFgXbZSjvp/contest/274852/problem/A",
      " */",
      "",
      "template<int SZ> struct Sieve { ",
      "\tbitset<SZ> pri; vi pr, cum; ",
      "\tSieve() { // cum[i] = # of primes up to i",
      "\t\tpri.set(); pri[0] = pri[1] = 0;",
      "\t\tfor (int i = 4; i < SZ; i += 2) pri[i] = 0;",
      "\t\tfor (int i = 3; i*i < SZ; i += 2) if (pri[i])",
      "\t\t\tfor (int j = i*i; j < SZ; j += i*2) pri[j] = 0;",
      "\t\tF0R(i,SZ) {",
      "\t\t\tcum.pb(i?cum.bk:0);",
      "\t\t\tif (pri[i]) pr.pb(i), cum.bk ++;",
      "\t\t}",
      "\t}",
      "\t/*int sp[SZ]; // smallest prime that divides",
      "\tSieve() { // above is faster",
      "\t\tmemset(sp,0,sizeof sp);",
      "\t\tFOR(i,2,SZ) { ",
      "\t\t\tif (sp[i] == 0) sp[i] = i, pr.pb(i); ",
      "\t\t\teach(p,pr) {",
      "\t\t\t\tif (p > sp[i] || i*p >= SZ) break;",
      "\t\t\t\tsp[i*p] = p;",
      "\t\t\t}",
      "\t\t}",
      "\t}*/",
      "};",
      "",
      "template<int SZ> struct PrimeCnt { ",
      "\tSieve<SZ> S; // SZ=1e7 is fine for N<=10^{11}",
      "\tstatic const int N = 1e5, K = 50; ",
      "\tuint16_t memo[N][K]; // use 32-bit if N >= 2^17",
      "\tPrimeCnt() { memset(memo,0,sizeof memo); }",
      "\tll countNo(ll n, int k) { // # of #s in [1,n] not divisible",
      "\t\tif (k == 0) return n; // by any of first k primes",
      "\t\tll p = S.pr[k]; if (n < p) return 1;",
      "\t\tif (n < min((ll)SZ,p*p)) return S.cum[n]-k+1;",
      "\t\tbool save = n < N && k < K;",
      "\t\tif (save && memo[n][k]) return memo[n][k];",
      "\t\tp = S.pr[k-1]; ll ret = countNo(n,k-1)-countNo(n/p,k-1);",
      "\t\tif (save) memo[n][k] = ret;",
      "\t\treturn ret;",
      "\t} // for k<X^{1/4}: <= X^{1/2} values of n",
      "\t// for X^{1/4}<k<=X^{1/2}: <= X^{1/2}/k values of n>X^{1/2}",
      "\tll get(ll X) { // k ~ sqrt(n)/logn",
      "\t\tif (X < SZ) return S.cum[X];",
      "\t\tint k = S.cum[sqrt(X)]; return countNo(X,k)+k-1;",
      "\t}",
      "};"
    ],
    "description": "Counts number of primes up to \\$n\\$. Can also count sum of primes., * Time: \\$O(n^{3/4}/\\log n)\\$, *"
  },
  "Sieve": {
    "prefix":["benq_Sieve"],
    "body": [
      "/**",
      " * Description: Tests primality up to \\$SZ\\$. Runs faster if only",
      " \t* odd indices are stored.",
      " * Time: O(SZ\\log\\log SZ) or O(SZ)",
      " * Source: KACTL ",
      " * Verification: https://open.kattis.com/problems/primesieve",
      " */",
      "",
      "template<int SZ> struct Sieve { ",
      "\tbitset<SZ> pri; vi pr;",
      "\tSieve() { // cum[i] = # of primes up to i",
      "\t\tpri.set(); pri[0] = pri[1] = 0;",
      "\t\tfor (int i = 4; i < SZ; i += 2) pri[i] = 0;",
      "\t\tfor (int i = 3; i*i < SZ; i += 2) if (pri[i])",
      "\t\t\tfor (int j = i*i; j < SZ; j += i*2) pri[j] = 0;",
      "\t\tF0R(i,SZ) if (pri[i]) pr.pb(i);",
      "\t}",
      "\t/*int sp[SZ]; // smallest prime that divides",
      "\tSieve() { // above is faster",
      "\t\tmemset(sp,0,sizeof sp);",
      "\t\tFOR(i,2,SZ) { ",
      "\t\t\tif (sp[i] == 0) sp[i] = i, pr.pb(i); ",
      "\t\t\teach(p,pr) {",
      "\t\t\t\tif (p > sp[i] || i*p >= SZ) break;",
      "\t\t\t\tsp[i*p] = p;",
      "\t\t\t}",
      "\t\t}",
      "\t}*/",
      "};",
      "Sieve<320000> S;"
    ],
    "description": "Tests primality up to \\$SZ\\$. Runs faster if only,  * odd indices are stored., * Time: O(SZ\\log\\log SZ) or O(SZ), *"
  },
  "BigInt": {
    "prefix":["benq_BigInt"],
    "body": [
      "/**",
      " * Description: Big Integer",
      " * Source: https://github.com/indy256/codelibrary/blob/master/cpp/numeric/bigint.cpp",
      "\t* oops that one uses FFT instead of Karatsuba now ....",
      " * Verification: https://oj.uz/problem/view/IOI11_parrots",
      " */",
      "",
      "// base and base_digits must be consistent",
      "const int base = 1e9, base_digits = 9;",
      "struct bigint { // value == 0 is represented by empty z",
      "\tvi z; // digits",
      "\tint sign; // sign == 1 <==> value >= 0",
      "\tbigint() : sign(1) {} // sign == -1 <==> value < 0",
      "\tbigint(ll v) { *this = v; }",
      "\tbigint &operator=(ll v) {",
      "\t\tsign = v < 0 ? -1 : 1; v *= sign; // make v positive",
      "\t\tz.clear(); for (;v;v/=base) z.pb(v%base);",
      "\t\treturn *this;",
      "\t}",
      "\tbigint(const str &s) { read(s); } // add char by char",
      "",
      "\tbigint &operator+=(const bigint &other) {",
      "\t\t//dbg(\"ADDING\",*this,other,sign,other.sign);",
      "\t\tif (sign == other.sign) {",
      "\t\t\tfor (int i = 0, carry = 0; i < sz(other.z) || carry; ++i) {",
      "\t\t\t\tif (i == sz(z)) z.pb(0);",
      "\t\t\t\tz[i] += carry+(i<sz(other.z)?other.z[i]:0);",
      "\t\t\t\tcarry = z[i] >= base; if (carry) z[i] -= base;",
      "\t\t\t}",
      "\t\t} else if (other != 0 /* prevent infinite loop */) *this -= -other;",
      "\t\treturn *this;",
      "\t}",
      "\tfriend bigint operator+(bigint a, const bigint &b) { return a += b; }",
      "\tbigint &operator-=(const bigint &other) {",
      "\t\tif (sign == other.sign) {",
      "\t\t\tif ((sign == 1 && *this >= other) || (sign == -1 && *this <= other)) {",
      "\t\t\t\tfor (int i = 0, carry = 0; i < sz(other.z) || carry; ++i) {",
      "\t\t\t\t\tz[i] -= carry+(i<sz(other.z)?other.z[i]:0);",
      "\t\t\t\t\tcarry = z[i]<0; if (carry) z[i] += base;",
      "\t\t\t\t}",
      "\t\t\t\ttrim();",
      "\t\t\t} else { // result will change sign",
      "\t\t\t\t*this = other-*this;",
      "\t\t\t\tthis->sign = -this->sign;",
      "\t\t\t}",
      "\t\t} else *this += -other;",
      "\t\treturn *this;",
      "\t}",
      "\tfriend bigint operator-(bigint a, const bigint &b) { return a -= b; }",
      "",
      "\tbigint &operator*=(int v) { // oops make sure not to multiply by ll ...",
      "\t\tif (v < 0) sign = -sign, v = -v;",
      "\t\tfor (int i = 0, carry = 0; i < sz(z) || carry; ++i) {",
      "\t\t\tif (i == sz(z)) z.pb(0);",
      "\t\t\tll cur = (ll)z[i]*v+carry;",
      "\t\t\tcarry = cur/base; z[i] = cur%base;",
      "\t\t}",
      "\t\ttrim(); return *this;",
      "\t}",
      "\tbigint operator*(int v) const { return bigint(*this) *= v; }",
      "\tfriend pair<bigint, bigint> divmod(const bigint &a1, const bigint &b1) {",
      "\t\tint norm = base/(b1.z.bk+1);",
      "\t\tbigint a = a1.abs()*norm, b = b1.abs()*norm, q, r; // make last element of b big",
      "\t\tq.z.rsz(sz(a.z));",
      "\t\tR0F(i,sz(a.z)) {",
      "\t\t\tr *= base; r += a.z[i];",
      "\t\t\tint s1 = sz(b.z) < sz(r.z) ? r.z[sz(b.z)] : 0;",
      "\t\t\tint s2 = sz(b.z)-1 < sz(r.z) ? r.z[sz(b.z)-1] : 0;",
      "\t\t\tint d = ((ll)s1*base+s2)/b.z.bk; // best approximation",
      "\t\t\tr -= b*d; while (r < 0) r += b, --d;",
      "\t\t\tq.z[i] = d;",
      "\t\t}",
      "\t\tq.sign = a1.sign*b1.sign; r.sign = a1.sign;",
      "\t\tq.trim(); r.trim(); return {q,r/norm};",
      "\t}",
      "\tfriend bigint sqrt(const bigint &a1) {",
      "\t\tbigint a = a1; while (!sz(a.z) || sz(a.z)&1) a.z.pb(0);",
      "\t\tint n = sz(a.z), firstDigit = ::sqrt((db)a.z[n-1]*base+a.z[n-2]);",
      "\t\tint norm = base/(firstDigit+1); a *= norm; a *= norm;",
      "\t\twhile (!sz(a.z) || sz(a.z)&1) a.z.pb(0);",
      "\t\tbigint r = (ll)a.z[n-1]*base+a.z[n-2];",
      "\t\tfirstDigit = (int)::sqrt((db)a.z[n-1]*base+a.z[n-2]);",
      "\t\tint q = firstDigit; bigint res;",
      "\t\tR0F(j,n/2) {",
      "\t\t\tfor (;; --q) {",
      "\t\t\t\tbigint r1 = (r-(res*2*base+q)*q)*base*base +",
      "\t\t\t\t\t\t\t(j>0?(ll)a.z[2*j-1]*base+a.z[2*j-2]:0);",
      "\t\t\t\tif (r1 >= 0) { r = r1; break; }",
      "\t\t\t}",
      "\t\t\tres *= base; res += q; // add a bit to sqrt",
      "\t\t\tif (j > 0) {",
      "\t\t\t\tint d1 = sz(res.z)+2 < sz(r.z) ? r.z[sz(res.z)+2] : 0; // always 0/1?",
      "\t\t\t\tint d2 = sz(res.z)+1 < sz(r.z) ? r.z[sz(res.z)+1] : 0;",
      "\t\t\t\tint d3 = sz(res.z) < sz(r.z) ? r.z[sz(res.z)] : 0;",
      "\t\t\t\tq = ((ll) d1*base*base+(ll)d2*base+d3)/(firstDigit*2);",
      "\t\t\t}",
      "\t\t}",
      "\t\tres.trim(); return res/norm;",
      "\t}",
      "\tbigint operator/(const bigint &v) const { return divmod(*this, v).f; }",
      "\tbigint operator%(const bigint &v) const { return divmod(*this, v).s; }",
      "\tbigint &operator/=(int v) {",
      "\t\tif (v < 0) sign = -sign, v = -v;",
      "\t\tfor (int i = sz(z)-1, rem = 0; i >= 0; --i) {",
      "\t\t\tll cur = z[i]+rem*(ll)base;",
      "\t\t\tz[i] = cur/v; rem = cur%v;",
      "\t\t}",
      "\t\ttrim(); return *this;",
      "\t}",
      "\tbigint operator/(int v) const { return bigint(*this) /= v; }",
      "\tint operator%(int v) const {",
      "\t\tif (v < 0) v = -v;",
      "\t\tint m = 0; R0F(i,sz(z)) m = (z[i]+m*(ll)base)%v;",
      "\t\treturn m*sign; }",
      "\tbigint &operator*=(const bigint &v) { return *this = *this*v; }",
      "\tbigint &operator/=(const bigint &v) { return *this = *this/v; }",
      "",
      "\tbool operator<(const bigint &v) const {",
      "\t\tif (sign != v.sign) return sign < v.sign;",
      "\t\tif (sz(z) != sz(v.z)) return sz(z)*sign < sz(v.z) * v.sign;",
      "\t\tR0F(i,sz(z)) if (z[i] != v.z[i]) return z[i]*sign < v.z[i]*sign;",
      "\t\treturn 0; // equal",
      "\t}",
      "\tbool operator>(const bigint &v) const { return v < *this; }",
      "\tbool operator<=(const bigint &v) const { return !(v < *this); }",
      "\tbool operator>=(const bigint &v) const { return !(*this < v); }",
      "\tbool operator==(const bigint &v) const { return !(*this < v) && !(v < *this); }",
      "\tbool operator!=(const bigint &v) const { return *this < v || v < *this; }",
      "\tvoid trim() {",
      "\t\twhile (sz(z) && z.bk == 0) z.pop_back();",
      "\t\tif (!sz(z)) sign = 1; // don't output -0",
      "\t}",
      "\tbool isZero() const { return !sz(z); }",
      "\tfriend bigint operator-(bigint v) {",
      "\t\tif (sz(v.z)) v.sign = -v.sign;",
      "\t\treturn v; }",
      "\tbigint abs() const { return sign == 1 ? *this : -*this; }",
      "\tll longValue() const {",
      "\t\tll res = 0; R0F(i,sz(z)) res = res*base+z[i];",
      "\t\treturn res*sign; }",
      "\tfriend bigint gcd(const bigint &a, const bigint &b) {",
      "\t\treturn b.isZero() ? a : gcd(b, a % b); } // euclidean algo",
      "\tfriend bigint lcm(const bigint &a, const bigint &b) {",
      "\t\treturn a/gcd(a, b) * b; }",
      "",
      "\tvoid read(const str &s) {",
      "\t\tsign = 1; z.clear(); int pos = 0;",
      "\t\twhile (pos < sz(s) && (s[pos] == '-' || s[pos] == '+')) {",
      "\t\t\tif (s[pos] == '-') sign = -sign;",
      "\t\t\t++pos; } // account for sign",
      "\t\tfor (int i = sz(s)-1; i >= pos; i -= base_digits) {",
      "\t\t\tint x = 0;",
      "\t\t\tfor (int j = max(pos, i-base_digits+1); j <= i; j++)",
      "\t\t\t\tx = x*10+s[j]-'0';",
      "\t\t\tz.pb(x);",
      "\t\t}",
      "\t\ttrim();",
      "\t}",
      "\tfriend istream &operator>>(istream &is, bigint &v) {",
      "\t\tstr s; is >> s; v.read(s); return is; }",
      "\tfriend ostream &operator<<(ostream &os, const bigint &v) {",
      "\t\tif (v.sign == -1) os << '-';",
      "\t\tos << (!sz(v.z) ? 0 : v.z.bk);",
      "\t\tR0F(i,sz(v.z)-1) os << setw(base_digits) << setfill('0') << v.z[i];",
      "\t\treturn os; // pad with zeroes",
      "\t}",
      "\tstatic vi convert_base(const vi &a, int old_digits, int new_digits) {",
      "\t\tvl p(max(old_digits, new_digits) + 1); // blocks of 10^{old} -> 10^{new}",
      "\t\tp[0] = 1; FOR(i,1,sz(p)) p[i] = p[i-1]*10;",
      "\t\tvi res; ll cur = 0; int cur_digits = 0;",
      "\t\tfor (int v:a) {",
      "\t\t\tcur += v*p[cur_digits]; cur_digits += old_digits;",
      "\t\t\twhile (cur_digits >= new_digits) {",
      "\t\t\t\tres.pb(cur%p[new_digits]);",
      "\t\t\t\tcur /= p[new_digits]; cur_digits -= new_digits;",
      "\t\t\t}",
      "\t\t}",
      "\t\tres.pb(cur); while (sz(res) && res.bk == 0) res.pop_back();",
      "\t\treturn res;",
      "\t}",
      "\tstatic vl karatMul(const vl &a, const vl &b) { // karatsuba",
      "\t\tint n = sz(a); vl res(2*n);",
      "\t\tif (n <= 32) { // naive multiply",
      "\t\t\tF0R(i,n) F0R(j,n) res[i+j] += a[i]*b[j];",
      "\t\t\treturn res; }",
      "\t\tint k = n/2;",
      "\t\tvl a1(begin(a),begin(a)+k), a2(k+all(a));",
      "\t\tvl b1(begin(b),begin(b)+k), b2(k+all(b));",
      "\t\tvl a1b1 = karatMul(a1, b1), a2b2 = karatMul(a2, b2);",
      "\t\tF0R(i,k) a2[i] += a1[i], b2[i] += b1[i];",
      "\t\tvl r = karatMul(a2, b2); // three instead of four products",
      "\t\tF0R(i,sz(a1b1)) r[i] -= a1b1[i];",
      "\t\tF0R(i,sz(a2b2)) r[i] -= a2b2[i];",
      "\t\tF0R(i,sz(r)) res[i+k] += r[i];",
      "\t\tF0R(i,sz(a1b1)) res[i] += a1b1[i];",
      "\t\tF0R(i,sz(a2b2)) res[i+n] += a2b2[i];",
      "\t\treturn res;",
      "\t}",
      "\tbigint operator*(const bigint &v) const {",
      "\t\tif (min(sz(z),sz(v.z)) < 150) return mul_simple(v);",
      "\t\tbigint res; res.sign = sign*v.sign; // should work as long as # of digits isn't too large (> LLONG_MAX/10^{12})",
      "\t\tvi a6 = convert_base(this->z, base_digits, 6); // blocks of 10^6 instead of 10^9",
      "\t\tvi b6 = convert_base(v.z, base_digits, 6);",
      "\t\tvl a(all(a6)), b(all(b6));",
      "\t\twhile (sz(a) < sz(b)) a.pb(0);",
      "\t\twhile (sz(b) < sz(a)) b.pb(0);",
      "\t\twhile (sz(a)&(sz(a)-1)) a.pb(0), b.pb(0); // make size power of 2",
      "\t\tvl c = karatMul(a, b);",
      "\t\tll cur = 0; F0R(i,sz(c)) { // process carries",
      "\t\t\tcur += c[i]; res.z.pb(cur%1000000); cur /= 1000000; } ",
      "\t\tres.z = convert_base(res.z,6,base_digits); ",
      "\t\tres.trim(); return res;",
      "\t}",
      "\tbigint mul_simple(const bigint &v) const {",
      "\t\tbigint res; res.sign = sign*v.sign;",
      "\t\tres.z.rsz(sz(z)+sz(v.z));",
      "\t\tF0R(i,sz(z)) if (z[i]) {",
      "\t\t\tll cur = 0; for (int j = 0; j < sz(v.z) || cur; ++j) {",
      "\t\t\t\tcur += res.z[i+j]+(ll)z[i]*(j<sz(v.z)?v.z[j]:0);",
      "\t\t\t\tres.z[i+j] = cur%base; cur /= base;",
      "\t\t\t}",
      "\t\t}",
      "\t\tres.trim(); return res;",
      "\t}",
      "\tfriend str ts(const bigint& v) {",
      "\t\tstringstream ss; ss << v;",
      "\t\tstr s; ss >> s; return s; }",
      "};",
      "",
      "bigint random_bigint(int n) {",
      "\tstr s; F0R(i,n) s += rand() % 10 + '0';",
      "\treturn bigint(s); }",
      "",
      "// random tests",
      "void bigintTest() {",
      "\tbigint x = bigint(\"120\");",
      "\tbigint y = bigint(\"5\");",
      "\tcout << x / y << endl;",
      "\tF0R(i,1000) {",
      "\t\tint n = rand() % 100 + 1;",
      "\t\tbigint a = random_bigint(n), res = sqrt(a);",
      "\t\tbigint xx = res * res, yy = (res + 1) * (res + 1);",
      "\t\tif (xx > a || yy <= a) {",
      "\t\t\tdbg(\"SQRT FAILED\",i);",
      "\t\t\tdbg(a,res);",
      "\t\t\tbreak;",
      "\t\t}",
      "\t\tint m = rand() % n + 1;",
      "\t\tbigint b = random_bigint(m)+1;",
      "\t\tres = a/b; xx = res*b, yy = b*(res+1);",
      "\t\tif (xx > a || yy <= a) {",
      "\t\t\tdbg(\"DIVISION FAILED\",i);",
      "\t\t\tdbg(a,b,res);",
      "\t\t\tbreak;",
      "\t\t}",
      "\t}",
      "\t{",
      "\t\tbigint a = random_bigint(10000);",
      "\t\tbigint b = random_bigint(2000);",
      "\t\tauto t1 = chrono::high_resolution_clock::now();",
      "\t\tbigint c = a / b;",
      "\t\tauto t2 = chrono::high_resolution_clock::now();",
      "\t\tchrono::duration<double, milli> duration = t2 - t1;",
      "\t\tdbg(duration.count(),\"ms\");",
      "\t}",
      "\tbigint a = random_bigint(500000);",
      "\tbigint b = random_bigint(500000);",
      "\tbigint c1, c2;",
      "\t{",
      "\t\tauto t1 = chrono::high_resolution_clock::now();",
      "\t\tc1 = a * b;",
      "\t\tauto t2 = chrono::high_resolution_clock::now();",
      "\t\tchrono::duration<double, milli> duration = t2 - t1;",
      "\t\tdbg(duration.count(),\"ms\");",
      "\t}",
      "\t{",
      "\t\tauto t1 = chrono::high_resolution_clock::now();",
      "\t\tc2 = a.mul_simple(b);",
      "\t\tauto t2 = chrono::high_resolution_clock::now();",
      "\t\tchrono::duration<double, milli> duration = t2 - t1;",
      "\t\tdbg(duration.count(),\"ms\");",
      "\t}",
      "\tdbg(c1 == c2);",
      "\t{",
      "",
      "\t\tauto t1 = chrono::high_resolution_clock::now();",
      "\t\tF0R(i,1000000) {",
      "\t\t\ta = random_bigint(30);",
      "\t\t\tb = random_bigint(30);",
      "\t\t\tc2 = a.mul_simple(b);",
      "\t\t}",
      "\t\tauto t2 = chrono::high_resolution_clock::now();",
      "\t\tchrono::duration<double, milli> duration = t2 - t1;",
      "\t\tdbg(duration.count(),\"ms\");",
      "\t}",
      "}"
    ],
    "description": "Big Integer, *"
  },
  "ExprParse": {
    "prefix":["benq_ExprParse"],
    "body": [
      "/**",
      " * Description: Evaluates mod expression with parentheses, or returns -1 if it is invalid",
      " * Source: Own",
      " * Verification: IPSC 2018 I1 ",
      " */",
      "",
      "namespace ExprParse {",
      "\tstring expr;",
      "\tint ind; // reset to 0 every time",
      "",
      "\tint eval(char c, int x, int y) {",
      "\t\tswitch(c) {",
      "\t\t\tcase '+': return (x+y)%MOD;",
      "\t\t\tcase '-': return (x-y+MOD)%MOD;",
      "\t\t\tcase '*': return (ll)x*y%MOD;",
      "\t\t\tdefault: exit(5);",
      "\t\t}",
      "\t}",
      "",
      "\tint pri(char c) {",
      "\t\tswitch (c) {",
      "\t\t\tcase '+': return 0;",
      "\t\t\tcase '-': return 0;",
      "\t\t\tcase '*': return 1;",
      "\t\t\tdefault: exit(5);",
      "\t\t}",
      "\t}",
      "",
      "\tint process(vi& num, vector<char>& op) {",
      "\t\tif (sz(num) < 2 || sz(op) < 1) return -1;",
      "\t\tint y = num.bk; num.pop_back();",
      "\t\tint x = num.bk; num.pop_back();",
      "\t\tchar c = op.bk; op.pop_back();",
      "\t\tnum.pb(eval(c,x,y));",
      "\t\treturn 0;",
      "\t}",
      "",
      "\tint finish(int& state, vi& num, vector<char>& op) {",
      "\t\tif (state != 0) return -1;",
      "\t\twhile (sz(op)) {",
      "\t\t\tint t = process(num,op);",
      "\t\t\tif (t == -1) return -1;",
      "\t\t}",
      "\t\tif (sz(num) != 1) return -1;",
      "\t\treturn num[0];",
      "\t}",
      "",
      "\tint eval(int cur = 0) {",
      "\t\tvi num;",
      "\t\tvector<char> op;",
      "\t\t",
      "\t\tint state = -1;",
      "\t\twhile (ind < sz(expr)) {",
      "\t\t\tif (expr[ind] == ')') {",
      "\t\t\t\tind ++;",
      "\t\t\t\tif (cur == 0) return -1;",
      "\t\t\t\treturn finish(state,num,op);",
      "\t\t\t} else if (expr[ind] == '(') {",
      "\t\t\t\tind ++;",
      "\t\t\t\tnum.pb(eval(1)); if (num.bk == -1) return -1;",
      "\t\t\t\tif (state == 0) return -1;",
      "\t\t\t\tstate = 0;",
      "\t\t\t} else if (isdigit(expr[ind])) {",
      "\t\t\t\tint val = 0;",
      "\t\t\t\twhile (ind < sz(expr) && isdigit(expr[ind])) {",
      "\t\t\t\t\tval = (10LL*val+(expr[ind]-'0')) % MOD;",
      "\t\t\t\t\tind ++;",
      "\t\t\t\t}",
      "\t\t\t\tnum.pb(val);",
      "\t\t\t\tif (state == 0) return -1;",
      "\t\t\t\tstate = 0;",
      "\t\t\t} else {",
      "\t\t\t\twhile (sz(op) && pri(op.bk) >= pri(expr[ind])) {",
      "\t\t\t\t\tint t = process(num,op);",
      "\t\t\t\t\tif (t == -1) return -1;",
      "\t\t\t\t}",
      "\t\t\t\top.pb(expr[ind]);",
      "\t\t\t\tif (state != 0) return -1;",
      "\t\t\t\tstate = 1;",
      "\t\t\t\tind ++;",
      "\t\t\t}",
      "\t\t}",
      "\t\t",
      "\t\tif (cur == 1) return -1; // parentheses don't match up",
      "\t\tif (ind != sz(expr)) return -1;",
      "\t\treturn finish(state,num,op);",
      "\t}",
      "}",
      "",
      "using namespace ExprParse;"
    ],
    "description": "Evaluates mod expression with parentheses, or returns -1 if it is invalid, *"
  },
  "Frac": {
    "prefix":["benq_Frac"],
    "body": [
      "/**",
      " * Description: Operations with fractions",
      " * Source: https://martin-thoma.com/fractions-in-cpp/",
      " * Verification: TopCoder MinimizeAbsoluteDifferenceDiv1",
      " */",
      "",
      "struct frac {",
      "\tll n,d;",
      "\tfrac(ll _n, ll _d) {",
      "\t\tn = _n, d = _d;",
      "\t\tll g = __gcd(n,d); n /= g, d /= g;",
      "\t\tif (d < 0) n *= -1, d *= -1;",
      "\t}",
      "\tfrac(ll _n) : frac(_n,1) {}",
      "\tfrac() : frac(0) {}",
      "\tfriend frac abs(frac F) { return frac(abs(F.n),F.d); }",
      "\tfriend str ts(const frac& a) { return ts(a.n)+\"/\"+ts(a.d); }",
      " ",
      "\tfriend bool operator<(const frac& l, const frac& r) { return l.n*r.d < r.n*l.d; }",
      "\tfriend bool operator==(const frac& l, const frac& r) { return l.n == r.n && l.d == r.d; }",
      "\tfriend bool operator!=(const frac& l, const frac& r) { return !(l == r); }",
      " ",
      "\tfrac operator-() const { return frac(-n,d); }",
      "\tfriend frac operator+(const frac& l, const frac& r) { return frac(l.n*r.d+r.n*l.d,l.d*r.d); }",
      "\tfriend frac operator-(const frac& l, const frac& r) { return frac(l.n*r.d-r.n*l.d,l.d*r.d); }",
      "\tfriend frac operator*(const frac& l, const frac& r) { return frac(l.n*r.n,l.d*r.d); }",
      "\tfriend frac operator*(const frac& l, int r) { return l*frac(r,1); }",
      "\tfriend frac operator*(int r, const frac& l) { return l*r; }",
      "\tfriend frac operator/(const frac& l, const frac& r) { return l*frac(r.d,r.n); }",
      "\tfriend frac operator/(const frac& l, const int& r) { return l/frac(r,1); }",
      "\tfriend frac operator/(const int& l, const frac& r) { return frac(l,1)/r; }",
      " ",
      "\tfriend frac& operator+=(frac& l, const frac& r) { return l = l+r; }",
      "\tfriend frac& operator-=(frac& l, const frac& r) { return l = l-r; }",
      "\ttemplate<class T> friend frac& operator*=(frac& l, const T& r) { return l = l*r; }",
      "\ttemplate<class T> friend frac& operator/=(frac& l, const T& r) { return l = l/r; }",
      "};"
    ],
    "description": "Operations with fractions, *"
  },
  "CharPoly": {
    "prefix":["benq_CharPoly"],
    "body": [
      "/**",
      " * Description: Characteristic polynomial of matrix.",
      " * Time: O(N^4), O(N^3)",
      " * Verification: K from https://official.contest.yandex.ru/opencupXX/contest/17333/enter/",
      " \t* relevant paper: https://www.hindawi.com/journals/mpe/2014/750618/",
      " * Source:",
      " \t* https://www.sciencedirect.com/science/article/pii/0895717793902662 (n^4)",
      " \t\t* https://artofproblemsolving.com/wiki/index.php/Newton%27s_Sums",
      " \t* http://www.cecm.sfu.ca/CAG/papers/CPpaper.pdf (n^3)",
      " */",
      "",
      "#include \"Matrix.h\"",
      "#include \"Poly.h\"",
      "",
      "T tr(const Mat& m) { // trace",
      "\tint n = sz(m); assert(n == sz(m[0]));",
      "\tT ans = 0; F0R(i,n) ans += m[i][i];",
      "\treturn ans; } // essentially newton sums",
      "poly charPolySlow(Mat A) {",
      "\tpoly c{1}; ",
      "\tint n = sz(A); Mat B = makeMat(n,n);",
      "\tFOR(i,1,n+1) B = A*B+A*c.bk, c.pb(-tr(B)/i);",
      "\treverse(all(c)); return c;",
      "}",
      "",
      "Mat upperHB(Mat M) { // when k >= j+2, M[k][j] = 0",
      "\tint n = sz(M); // characteristic poly remains the same",
      "\tF0R(j,n-2) FOR(i,j+2,n) if (M[i][j] != 0) {",
      "\t\tif (M[j+1][j] == 0) {",
      "\t\t\tswap(M[i],M[j+1]);",
      "\t\t\tF0R(I,n) swap(M[I][i],M[I][j+1]);",
      "\t\t}",
      "\t\tmi in = 1/M[j+1][j];",
      "\t\tFOR(k,j+2,n) {",
      "\t\t\tmi u = M[k][j]*in;",
      "\t\t\tM[k] -= u*M[j+1]; // subtract multiple of j+1'th row from k-th",
      "\t\t\tF0R(I,n) M[I][j+1] += u*M[I][k]; // add multiple of k'th column to j+1-th",
      "\t\t}",
      "\t\tbreak;",
      "\t}",
      "\treturn M;",
      "}",
      "poly charUpperHB(Mat M) {",
      "\tint n = sz(M);",
      "\tvector<poly> p(n+1); p[0] = {1};",
      "\tF0R(k,n) { // casework based on which entry you choose in column k",
      "\t\tp[k+1] = poly{-M[k][k],1}*p[k]; mi t = 1; // char poly for first (k+1) rows * (k+1) cols",
      "\t\tF0R(i,k) {",
      "\t\t\tt *= M[k-i][k-i-1];",
      "\t\t\tp[k+1] -= t*M[k-i-1][k]*p[k-i-1];",
      "\t\t}",
      "\t}",
      "\treturn p[n];",
      "}",
      "poly charPoly(Mat M) { return charUpperHB(upperHB(M)); }"
    ],
    "description": "Characteristic polynomial of matrix., * Time: O(N^4), O(N^3), * Verification: K from https://official.contest.yandex.ru/opencupXX/contest/17333/enter/,  * relevant paper: https://www.hindawi.com/journals/mpe/2014/750618/, *"
  },
  "Hafnian": {
    "prefix":["benq_Hafnian"],
    "body": [
      "/**",
      " * Description: Counts number of perfect matchings given adjacency matrix,",
      " \t* which is symmetric and whose main diagonal contains only 0s. Must",
      " \t* have an even # of vertices. Uses PIE.",
      " * Time: O(N^42^{N/2}), <2s for \\$N=38\\$.",
      " * Source: ",
      " \t* https://dl.acm.org/doi/pdf/10.5555/2095116.2095189",
      " \t* https://judge.yosupo.jp/submission/9282",
      " */",
      "",
      "#include \"../../number-theory (11.1)/Modular Arithmetic/ModInt.h\"",
      "",
      "struct Haf {",
      "\tint h; // = n/2+1",
      "\tvoid ad(vmi& x, const vmi& a, const vmi& b) { // all have size h",
      "\t\tF0R(i,h) F0R(j,h-1-i) x[i+j+1] += a[i]*b[j]; }",
      "\tvmi solve(const vector<vector<vmi>>& v) { // keep removing last two verts",
      "\t\tvmi ans(h); if (!sz(v)) { ans[0] = 1; return ans; }",
      "\t\tint m = sz(v)-2; auto V = v; V.rsz(m); vmi zero = solve(V);",
      "\t\tF0R(i,m) F0R(j,i) {",
      "\t\t\tad(V[i][j],v[m][i],v[m+1][j]);",
      "\t\t\tad(V[i][j],v[m+1][i],v[m][j]);",
      "\t\t} // do inclusion-exclusion",
      "\t\tvmi one = solve(V); F0R(i,h) ans[i] += one[i]-zero[i]; ",
      "\t\tad(ans,one,v[m+1][m]); return ans;",
      "\t} // include edge connecting m w/ m+1",
      "\tmi calc(vector<vmi> m) { // m is adj matrix",
      "\t\tint n = sz(m); assert(n%2 == 0); h = n/2+1; ",
      "\t\tvector<vector<vmi>> v(n);",
      "\t\tF0R(i,n) { // only keep track of lower triangle",
      "\t\t\tv[i].rsz(i);",
      "\t\t\tF0R(j,i) v[i][j] = vmi(h), v[i][j][0] = m[i][j];",
      "\t\t}",
      "\t\treturn solve(v).bk; // take term with degree n/2",
      "\t}",
      "};"
    ],
    "description": "Counts number of perfect matchings given adjacency matrix,,  * which is symmetric and whose main diagonal contains only 0s. Must,  * have an even # of vertices. Uses PIE., * Time: O(N^42^{N/2}), <2s for \\$N=38\\$., *"
  },
  "Matrix": {
    "prefix":["benq_Matrix"],
    "body": [
      "/**",
      " * Description: 2D matrix operations. Use array instead of ",
      " \t* vector when possible.",
      " * Source: KACTL",
      " * Verification: https://dmoj.ca/problem/si17c1p5, SPOJ MIFF",
      " */",
      "",
      "#include \"../../number-theory (11.1)/Modular Arithmetic/ModInt.h\"",
      "",
      "using T = mi;",
      "using Mat = V<V<T>>;",
      "",
      "Mat makeMat(int r, int c) { return Mat(r,vector<T>(c)); }",
      "Mat makeId(int n) { ",
      "\tMat m = makeMat(n,n);",
      "\tF0R(i,n) m[i][i] = 1;",
      "\treturn m;",
      "}",
      "Mat& operator+=(Mat& a, const Mat& b) {",
      "\tassert(sz(a) == sz(b) && sz(a[0]) == sz(b[0]));",
      "\tF0R(i,sz(a)) F0R(j,sz(a[0])) a[i][j] += b[i][j];",
      "\treturn a;",
      "}",
      "Mat& operator-=(Mat& a, const Mat& b) {",
      "\tassert(sz(a) == sz(b) && sz(a[0]) == sz(b[0]));",
      "\tF0R(i,sz(a)) F0R(j,sz(a[0])) a[i][j] -= b[i][j];",
      "\treturn a;",
      "}",
      "Mat operator*(const Mat& a, const Mat& b) {",
      "\tint x = sz(a), y = sz(a[0]), z = sz(b[0]); ",
      "\tassert(y == sz(b)); Mat c = makeMat(x,z);",
      "\tF0R(i,x) F0R(j,y) F0R(k,z) c[i][k] += a[i][j]*b[j][k];",
      "\treturn c;",
      "}",
      "Mat operator+(Mat a, const Mat& b) { return a += b; }",
      "Mat operator-(Mat a, const Mat& b) { return a -= b; }",
      "Mat& operator*=(Mat& a, const Mat& b) { return a = a*b; }",
      "Mat pow(Mat m, ll p) {",
      "\tint n = sz(m); assert(n == sz(m[0]) && p >= 0);",
      "\tMat res = makeId(n);",
      "\tfor (; p; p /= 2, m *= m) if (p&1) res *= m;",
      "\treturn res;",
      "}"
    ],
    "description": "2D matrix operations. Use array instead of ,  * vector when possible., *"
  },
  "MatrixInv": {
    "prefix":["benq_MatrixInv"],
    "body": [
      "/**",
      " * Description: Uses gaussian elimination to convert into reduced row echelon form",
      "\t* and calculates determinant. For determinant via arbitrary modulos, ",
      "\t* use a modified form of the Euclidean algorithm because modular inverse ",
      "\t* may not exist. If you have computed \\$A^{-1}\\pmod{p^k},\\$ then the inverse ",
      "\t* \\$\\pmod{p^{2k}}\\$ is \\$A^{-1}(2I-AA^{-1}).\\$",
      " * Time: O(N^3), determinant of \\$1000\\times 1000\\$ matrix of modints in ",
      "\t* 1 second if you reduce \\# of operations by half",
      " * Source: various",
      " * Verification: ",
      "\t* SPOJ MIFF (matrix inverse modulo prime)",
      "\t* https://open.kattis.com/problems/equationsolver",
      " */",
      "",
      "#include \"Matrix.h\"",
      "",
      "const ld EPS = 1e-12;",
      "int getRow(vector<vector<ld>>& m, int R, int i, int nex) {",
      "    pair<ld,int> bes = {0,-1}; // find row with max absolute value",
      "    FOR(j,nex,R) ckmax(bes,{abs(m[j][i]),j}); ",
      "    return bes.f < EPS ? -1 : bes.s; }",
      "int getRow(vector<vector<mi>>& m, int R, int i, int nex) {",
      "    FOR(j,nex,R) if (m[j][i] != 0) return j;",
      "    return -1; }",
      "pair<T,int> gauss(Mat& m) { ",
      "    int R = sz(m), C = sz(m[0]), rank = 0, nex = 0;",
      "    T prod = 1; // determinant",
      "    F0R(i,R) {",
      "        int row = getRow(m,R,i,nex);",
      "        if (row == -1) { prod = 0; continue; }",
      "        if (row != nex) prod *= -1, swap(m[row],m[nex]);",
      "        prod *= m[nex][i]; rank ++;",
      "        T x = 1/m[nex][i]; FOR(k,i,C) m[nex][k] *= x;",
      "        F0R(j,R) if (j != nex) {",
      "            T v = m[j][i]; if (v == 0) continue;",
      "            FOR(k,i,C) m[j][k] -= v*m[nex][k];",
      "        }",
      "        nex ++;",
      "    }",
      "    return {prod,rank};",
      "}",
      "Mat inv(Mat m) {",
      "    int R = sz(m); assert(R == sz(m[0]));",
      "    Mat x = makeMat(R,2*R);",
      "    F0R(i,R) {",
      "        x[i][i+R] = 1;",
      "        F0R(j,R) x[i][j] = m[i][j];",
      "    }",
      "    if (gauss(x).s != R) return Mat();",
      "    Mat res = makeMat(R,R);",
      "    F0R(i,R) F0R(j,R) res[i][j] = x[i][j+R];",
      "    return res;",
      "}"
    ],
    "description": "Uses gaussian elimination to convert into reduced row echelon form, * and calculates determinant. For determinant via arbitrary modulos, , * use a modified form of the Euclidean algorithm because modular inverse , * may not exist. If you have computed \\$A^{-1}\\pmod{p^k},\\$ then the inverse , * \\$\\pmod{p^{2k}}\\$ is \\$A^{-1}(2I-AA^{-1}).\\$, * Time: O(N^3), determinant of \\$1000\\times 1000\\$ matrix of modints in , * 1 second if you reduce \\# of operations by half, *"
  },
  "MatrixTree": {
    "prefix":["benq_MatrixTree"],
    "body": [
      "/**",
      " * Description: Kirchhoff's Matrix Tree Theorem.",
      "\t* Given adjacency matrix, calculates \\# of spanning trees.",
      " * Source: various",
      " * Verification: SPOJ MIFF (matrix inverse modulo prime)",
      " */",
      "",
      "#include \"MatrixInv.h\"",
      "",
      "T numSpan(Mat m) { ",
      "\tint n = sz(m); Mat res(n-1,n-1);",
      "\tF0R(i,n) FOR(j,i+1,n) {",
      "\t\tmi ed = m[i][j]; res[i][i] += ed;",
      "\t\tif (j != n-1) {",
      "\t\t\tres[j][j] += ed;",
      "\t\t\tres[i][j] -= ed, res[j][i] -= ed;",
      "\t\t}",
      "\t}",
      "\treturn gauss(res).f;",
      "}"
    ],
    "description": "Kirchhoff's Matrix Tree Theorem., * Given adjacency matrix, calculates \\# of spanning trees., *"
  },
  "ShermanMorrison": {
    "prefix":["benq_ShermanMorrison"],
    "body": [
      "/**",
      " * Description: Calculates \\$(A+uv^T)^{-1}\\$ given \\$A^{-1}\\$. ",
      " \t* Not invertible if \\texttt{sum=0}.",
      " * Source: https://en.wikipedia.org/wiki/Sherman%E2%80%93Morrison_formula",
      " * Verification: F from https://codeforces.com/gym/101981",
      " */",
      "",
      "#include \"MatrixInv.h\"",
      "",
      "void ad(Mat& A, vector<T> u, vector<T> v) {",
      "\tint n = sz(A); vector<T> x(n), y(n); ",
      "\tF0R(i,n) F0R(j,n)",
      "\t\tx[i] += A[i][j]*u[j], y[j] += v[i]*A[i][j];",
      "\tT sum = 1; F0R(i,n) F0R(j,n) sum += v[i]*A[i][j]*u[j];",
      "\tF0R(i,n) F0R(j,n) A[i][j] -= x[i]*y[j]/sum;",
      "}"
    ],
    "description": "Calculates \\$(A+uv^T)^{-1}\\$ given \\$A^{-1}\\$. ,  * Not invertible if \\texttt{sum=0}., *"
  },
  "SparseDet": {
    "prefix":["benq_SparseDet"],
    "body": [
      "/**",
      " * Description: Tries to find characteristic equation of matrix -> determinant.",
      " * Source: ",
      " \t* https://github.com/yosupo06/library-checker-problems/blob/a14bd2360b01cac091efa8cc62cee0a9b65ae775/math/sparse_matrix_det/sol/correct.cpp",
      " \t* https://mathworld.wolfram.com/CharacteristicEquation.html",
      " \t* https://codeforces.com/blog/entry/76945?#comment-638126",
      " * Verification: https://judge.yosupo.jp/problem/sparse_matrix_det",
      " */",
      "",
      "#include \"LinRec.h\"",
      "",
      "mi sparseDet(int N, vector<pair<pi,mi>> A) { // nonzero entries of matrix, no repeats",
      "\tauto gen = []() { return rng()%(MOD-1)+1; };",
      "\tvmi l(N), r(N), seq(2*N); F0R(i,N) l[i] = gen(), r[i] = gen();",
      "\tF0R(i,2*N) { // consider l*A^i*r, recurrence satisfies characteristic equation",
      "\t\tF0R(j,N) seq[i] += l[j]*r[j];",
      "\t\tvmi R(N); each(t,A) R[t.f.s] += r[t.f.f]*t.s;",
      "\t\tswap(r,R);",
      "\t}",
      "\tLinRec L; L.init(seq); // hopefully found characteristic equation",
      "\tif (L.C.bk == 0) return 0; // 0 is root of characteristic equation",
      "\tif (sz(L.C) != N) return sparseDet(N,ed); // keep trying ...",
      "\tmi res = L.C.bk; if (!(N&1)) res *= -1; ",
      "\treturn res;",
      "};"
    ],
    "description": "Tries to find characteristic equation of matrix -> determinant., *"
  },
  "XorBasis": {
    "prefix":["benq_XorBasis"],
    "body": [
      "/**",
      " * Description: XOR basis. If \\texttt{x} is in basis \\texttt{b} ",
      " \t* then returns 0, otherwise returns adds it to 1. Equivalent",
      " \t* to Gaussian Elimination.",
      " * Source: Own",
      " * Verification: GP of Nanjing 2020 A",
      " \t* https://atcoder.jp/contests/agc045/tasks/agc045_a (first solve :D)",
      " */",
      "",
      "ll red(vl& b, ll x) { each(t,b) ckmin(x,x^t);",
      "\treturn x; }",
      "bool add(vl& b, ll x) {",
      "\tif (!(x = red(b,x))) return 0;",
      "\tint ind=0; while (ind<sz(b)&&b[ind]>x) ind ++;",
      "\tb.insert(begin(b)+ind,x); return 1;",
      "}",
      "",
      "/**",
      "ps(add(a,1)); // true",
      "ps(add(a,2)); // true",
      "ps(add(a,3)); // false",
      "ps(add(a,7)); // true",
      "ps(add(a,4)); // false",
      "*/"
    ],
    "description": "XOR basis. If \\texttt{x} is in basis \\texttt{b} ,  * then returns 0, otherwise returns adds it to 1. Equivalent,  * to Gaussian Elimination., *"
  },
  "GoldenSectionSearch": {
    "prefix":["benq_GoldenSectionSearch"],
    "body": [
      "/**",
      " * Description: Finds the argument minimizing the function \\$f\\$ in the interval \\$[a,b]\\$ assuming ",
      " \t* \\$f\\$ is unimodal on the interval, i.e. has only one local minimum. The maximum error in the ",
      " \t* result is \\$eps\\$. Works equally well for maximization with a small change in the code. ",
      " * Source: https://github.com/kth-competitive-programming/kactl/blob/master/content/numerical/GoldenSectionSearch.h",
      " * Verification: https://codeforces.com/contest/1427/problem/H",
      " * Usage: gss(-1000,1000,[](db x) { return 4+x+.3*x*x; }); // -5/3",
      " * Time: O(\\log((b-a) / \\epsilon))",
      " */",
      "",
      "/// It is important for r to be precise, otherwise we don't necessarily maintain the inequality a < x1 < x2 < b.",
      "db gss(db a, db b, function<db(db)> f) {",
      "\tdb r = (sqrt(5)-1)/2, eps = 1e-7;",
      "\tdb x1 = b - r*(b-a), x2 = a + r*(b-a);",
      "\tdb f1 = f(x1), f2 = f(x2);",
      "\twhile (b-a > eps)",
      "\t\tif (f1 < f2) { // change to > to find maximum",
      "\t\t\tb = x2; x2 = x1; f2 = f1;",
      "\t\t\tx1 = b - r*(b-a); f1 = f(x1);",
      "\t\t} else {",
      "\t\t\ta = x1; x1 = x2; f1 = f2;",
      "\t\t\tx2 = a + r*(b-a); f2 = f(x2);",
      "\t\t}",
      "\treturn a;",
      "}"
    ],
    "description": "Finds the argument minimizing the function \\$f\\$ in the interval \\$[a,b]\\$ assuming ,  * \\$f\\$ is unimodal on the interval, i.e. has only one local minimum. The maximum error in the ,  * result is \\$eps\\$. Works equally well for maximization with a small change in the code. , *"
  },
  "Integrate": {
    "prefix":["benq_Integrate"],
    "body": [
      "/**",
      " * Description: Integration of a function over an interval using",
      "   * Simpson's rule. The error should be proportional to \\$dif^4\\$, although in",
      "   * practice you will want to verify that the result is stable to desired",
      "   * precision when epsilon changes.",
      " * Source: KACTL",
      "\t* https://en.wikipedia.org/wiki/Simpson%27s_rule",
      " * Verification: https://codeforces.com/gym/101793/problem/C",
      " */",
      "",
      "// db f(db x) { return x*x+3*x+1; }",
      "db quad(db (*f)(db), db a, db b) {",
      "\tconst int n = 1000;",
      "\tdb dif = (b-a)/2/n, tot = f(a)+f(b);",
      "\tFOR(i,1,2*n) tot += f(a+i*dif)*(i&1?4:2);",
      "\treturn tot*dif/3;",
      "}"
    ],
    "description": "Integration of a function over an interval using,   * Simpson's rule. The error should be proportional to \\$dif^4\\$, although in,   * practice you will want to verify that the result is stable to desired,   * precision when epsilon changes., *"
  },
  "IntegrateAdaptive": {
    "prefix":["benq_IntegrateAdaptive"],
    "body": [
      "/**",
      " * Description: Unused. Fast integration using adaptive Simpson's rule,",
      " \t* exact for polynomials of degree up to 5.",
      " * Source: KACTL",
      "\t* https://en.wikipedia.org/wiki/Adaptive_Simpson%27s_method",
      " * Verification: ?",
      " * Usage: ",
      "\tdb z, y;",
      "\tdb h(db x) { return x*x + y*y + z*z <= 1; }",
      "\tdb g(db y) { ::y = y; return quad(h, -1, 1); }",
      "\tdb f(db z) { ::z = z; return quad(g, -1, 1); }",
      "\tdb sphereVol = quad(f,-1,1), pi = sphereVol*3/4;",
      " */",
      "",
      "/// db f(db x) { return x*x+3*x+1; }",
      "db simpson(db (*f)(db), db a, db b) {",
      "\tdb c = (a+b)/2; return (f(a)+4*f(c)+f(b))*(b-a)/6; }",
      "template<class F> db rec(F& f, db a, db b, db eps, db S) {",
      "\tdb c = (a+b)/2;",
      "\tdb S1 = simpson(f,a,c), S2 = simpson(f,c,b), T = S1+S2;",
      "\tif (abs(T-S)<=15*eps || b-a<1e-10) return T+(T-S)/15;",
      "\treturn rec(f,a,c,eps/2,S1)+rec(f,c,b,eps/2,S2);",
      "}",
      "template<class F> quad(F f, db a, db b, db eps = 1e-8) {",
      "\treturn rec(f,a,b,eps,simpson(f,a,b)); }"
    ],
    "description": "Unused. Fast integration using adaptive Simpson's rule,,  * exact for polynomials of degree up to 5., *"
  },
  "LinRec": {
    "prefix":["benq_LinRec"],
    "body": [
      "/**",
      " * Description: Berlekamp-Massey, computes linear recurrence ",
      "\t* \\texttt{C} of order \\$N\\$ for sequence \\texttt{s} of \\$2N\\$ terms.",
      " * Time: \\texttt{init} \\$\\Rightarrow O(N|C|),\\$ ",
      "\t* \\texttt{eval} \\$\\Rightarrow O(|C|^2\\log p)\\$.",
      " * Usage: LinRec L; L.init({0,1,1,2,3,5,8}); // Fibonacci",
      " * Source: ",
      "\t* http://crypto.stanford.edu/~mironov/cs359/massey.pdf (theorem 2 on page 3)",
      "\t* https://en.wikipedia.org/wiki/Berlekamp%E2%80%93Massey_algorithm",
      "\t* http://codeforces.com/blog/entry/61306",
      "\t* MIT ICPC notebook",
      " * Verification: http://codeforces.com/contest/506/problem/E",
      " */",
      " ",
      "#include \"Poly.h\"",
      "",
      "struct LinRec {",
      "\tpoly s, C, rC; ",
      "\tvoid BM() { // find smallest C such that C[0]=1 and ",
      "\t\t// for all i >= sz(C)-1, sum_{j=0}^{sz(C)-1}C[j]*s[i-j]=0",
      "\t\t// If we treat C and s as polynomials in D, then",
      "\t\t// for all i >= sz(C)-1, [D^i]C*s=0",
      "\t\tint x = 0; T b = 1;",
      "\t\tpoly B; B = C = {1}; // B is fail vector",
      "\t\t// for all sz(B)+x-1 <= j < i, [D^j](B<<x)*s=0, but [D^i](B<<x)*s=b",
      "\t\t// invariant: sz(B)+x = M",
      "\t\tF0R(i,sz(s)) { // update C after adding a term of s",
      "\t\t\t++x; int L = sz(C), M = i+3-L;",
      "\t\t\tT d = 0; F0R(j,L) d += C[j]*s[i-j]; // [D^i]C*s",
      "\t\t\tif (d == 0) continue; // [D^i]C*s=0, continue",
      "\t\t\tpoly _C = C; T coef = d/b; // d-coef*b = 0",
      "\t\t\t// set C := C-coef*(B<<x) to satisfy condition",
      "\t\t\tC.rsz(max(L,M)); F0R(j,sz(B)) C[j+x] -= coef*B[j];",
      "\t\t\tif (L < M) B = _C, b = d, x = 0; // replace B<<x with C<<0",
      "\t\t}",
      "\t}",
      "\tvoid init(const poly& _s) { ",
      "\t\ts = _s; BM();",
      "\t\trC = C; reverse(all(rC)); // poly for getPow",
      "\t\tC.erase(begin(C)); each(t,C) t *= -1;",
      "\t} // now s[i]=sum_{j=0}^{sz(C)-1}C[j]*s[i-j-1]",
      "\tpoly getPow(ll p) { // get x^p mod rC",
      "\t\tif (p == 0) return {1};",
      "\t\tpoly r = getPow(p/2); r = (r*r)%rC;",
      "\t\treturn p&1?(r*poly{0,1})%rC:r;",
      "\t}",
      "\tT dot(poly v) { // dot product with seq",
      "\t\tT ans = 0; F0R(i,sz(v)) ans += v[i]*s[i];",
      "\t\treturn ans; } // get p-th term of rec",
      "\tT eval(ll p) { assert(p >= 0); return dot(getPow(p)); } ",
      "};"
    ],
    "description": "Berlekamp-Massey, computes linear recurrence , * \\texttt{C} of order \\$N\\$ for sequence \\texttt{s} of \\$2N\\$ terms., * Time: \\texttt{init} \\$\\Rightarrow O(N|C|),\\$ , * \\texttt{eval} \\$\\Rightarrow O(|C|^2\\log p)\\$., * Usage: LinRec L; L.init({0,1,1,2,3,5,8}); // Fibonacci, *"
  },
  "LinRec2": {
    "prefix":["benq_LinRec2"],
    "body": [
      "/**",
      " * Description: Reeds-Sloane, generalizes Berlekamp-Massey to non-prime moduli",
      " * Source:",
      "   * https://github.com/zimpha/algorithmic-library/blob/master/cpp/mathematics/linear-recurrence.cc",
      "   * http://neilsloane.com/doc/Me111.pdf",
      " * Verification:",
      "   * https://www.spoj.com/problems/FINDLR/",
      " */",
      "",
      "#include \"CRT.h\"",
      "",
      "struct LinRec2 {",
      "\tvl s, C; ll mod;",
      "\tvoid extend(vl& a, ll b) { if (sz(a) < b) a.rsz(b); }",
      "\tvl primePower(ll p, int e) { // generalization of BM",
      "\t\tvector<vl> a(e), an(e), ao(e);",
      "\t\tvl t(e), u(e), r(e), to(e,1), uo(e), pw(e+1);",
      "\t\tpw[0] = 1; FOR(i,1,e+1) pw[i] = pw[i-1]*p;",
      "\t\tll mod = pw[e];",
      "\t\tauto mul = [mod](ll x, ll y) { return x*y%mod; };",
      "\t\tauto AD = [mod](ll& x, ll y) { x += y; if (x >= mod) x -= mod; };",
      "\t\tauto SUB = [mod](ll& x, ll y) { x -= y; if (x < 0) x += mod; };",
      "\t\tF0R(o,e) {",
      "\t\t\ta[o] = an[o] = {pw[o]}; t[o] = mul(s[0],pw[o]);",
      "\t\t\tif (!t[o]) t[o] = 1, u[o] = e;",
      "\t\t\telse for (an[o].pb(0); t[o]%p == 0; t[o] /= p, ++u[o]);",
      "\t\t}",
      "\t\tFOR(k,1,sz(s)) { // add terms one by one",
      "\t\t\tF0R(g,e) if (sz(an[g]) > sz(a[g])) { ",
      "\t\t\t\tint ind = e-1-u[g]; r[g] = k-1;",
      "\t\t\t\tao[g] = a[ind]; to[g] = t[ind]; uo[g] = u[ind];",
      "\t\t\t} // recurrence was extended after term k-1 was added",
      "\t\t\ta = an;",
      "\t\t\tF0R(o,e) {",
      "\t\t\t\tll d = 0; F0R(i,sz(a[o])) AD(d,mul(a[o][i],s[k-i])); ",
      "\t\t\t\tif (d == 0) { t[o] = 1, u[o] = e; continue; } // do nothing",
      "\t\t\t\tfor (u[o] = 0, t[o] = d; t[o]%p == 0; t[o] /= p, ++u[o]);",
      "\t\t\t\tint g = e-1-u[o];",
      "\t\t\t\tif (sz(a[g]) == 1) extend(an[o],k+2); // just make it 1,0,0,...",
      "\t\t\t\telse { // subtract multiple of previous to get to 0",
      "\t\t\t\t\tll coef = mul(mul(t[o],invGen(to[g],mod)),pw[u[o]-uo[g]]);",
      "\t\t\t\t\tint m = k-r[g]; extend(an[o],sz(ao[g])+m);",
      "\t\t\t\t\tF0R(i,sz(ao[g])) SUB(an[o][i+m],mul(coef,ao[g][i]));",
      "\t\t\t\t}",
      "\t\t\t}",
      "\t\t}",
      "\t\treturn an[0];",
      "\t}",
      "\tvoid RS() {",
      "\t\tvector<pair<ll,int>> fac; vl mul;",
      "\t\tfor (ll i = 2; i*i <= mod; ++i) if (mod%i == 0) {",
      "\t\t\tint cnt = 0; ll pw = 1;  // naive factorization",
      "\t\t\twhile (mod%i == 0) mod /= i, ++cnt, pw *= i;",
      "\t\t\tfac.pb({i,cnt}); mul.pb(pw);",
      "\t\t}",
      "\t\tif (mod > 1) fac.pb({mod,1}), mul.pb(mod);",
      "\t\tvector<vl> as; int n = 0;",
      "\t\teach(x,fac) {",
      "\t\t\tauto y = primePower(x.f,x.s);",
      "\t\t\tas.pb(y); ckmax(n,sz(y));",
      "\t\t}",
      "\t\tC.rsz(n);",
      "\t\tF0R(i,n) {",
      "\t\t\tpl p = {0,1};",
      "\t\t\tF0R(j,sz(as)) {",
      "\t\t\t\tpl tmp = {i < sz(as[j]) ? as[j][i] : 0,mul[j]};",
      "\t\t\t\tp = CRT(p,tmp);",
      "\t\t\t}",
      "\t\t\tC[i] = p.f;",
      "\t\t}",
      "\t}",
      "\tvoid init(vl _s, ll _mod) {",
      "\t\ts = _s; mod = _mod; RS();",
      "\t} // can use C in same way as Berlekamp-Massey",
      "};",
      "",
      "int main() {",
      "\tLinRec2 L;",
      "\tL.init({0,0,0,1,1,2,3,5,8,13},20);",
      "\tps(L.C); // {1, 19, 19, 0, 0}",
      "}"
    ],
    "description": "Reeds-Sloane, generalizes Berlekamp-Massey to non-prime moduli, *"
  },
  "Simplex": {
    "prefix":["benq_Simplex"],
    "body": [
      "/**",
      " * Description: Solves a general linear maximization problem: ",
      " \t* maximize \\$c^T x\\$ subject to \\$Ax \\le b\\$, \\$x \\ge 0\\$.",
      "\t* Returns -inf if there is no solution, ",
      "\t* inf if there are arbitrarily good solutions, ",
      "\t* or the maximum value of \\$c^T x\\$ otherwise.",
      "\t* The input vector is set to an optimal \\$x\\$ ",
      "\t* (or in the unbounded case, an arbitrary solution fulfilling the constraints).",
      "\t* Numerical stability is not guaranteed. For better performance, ",
      "\t* define variables such that \\$x = 0\\$ is viable.",
      " * Usage:",
      "\t * vvd A = {{1,-1}, {-1,1}, {-1,-2}};",
      "\t * vd b = {1,1,-4}, c = {-1,-1}, x;",
      "\t * T val = LPSolver(A, b, c).solve(x);",
      " * Time: O(NM \\cdot \\#pivots), where a pivot may be e.g. an edge relaxation. O(2^N) in the general case.",
      " * Source: KACTL, Stanford",
      "\t* https://cs.stanford.edu/group/acm/SLPC/notebook.pdf",
      "\t* https://www.utdallas.edu/~scniu/OPRE-6201/documents/LP06-Simplex-Tableau.pdf (good example)",
      "\t* http://www.columbia.edu/~cs2035/courses/ieor3608.F05/bigm1.pdf",
      " * Verification: https://open.kattis.com/contests/ecna19open/problems/cheeseifyouplease",
      " */",
      " ",
      "typedef db T; typedef vector<T> vd;",
      "typedef vector<vd> vvd;",
      "const T eps = 1e-8, inf = 1/.0;",
      "",
      "#define ltj(X) if (s==-1 || mp(X[j],N[j])<mp(X[s],N[s])) s=j",
      "struct LPSolver {",
      "\tint m, n; vi N, B; vvd D; // # contraints, # variables",
      "\tLPSolver(const vvd& A, const vd& b, const vd& c) :",
      "\t  m(sz(b)), n(sz(c)), N(n+1), B(m), D(m+2, vd(n+2)) {",
      "\t\tF0R(i,m) F0R(j,n) D[i][j] = A[i][j]; ",
      "\t\tF0R(i,m) { // B[i]: add basic variable for each constraint, ",
      "\t\t\tB[i] = n+i, D[i][n] = -1, D[i][n+1] = b[i]; ",
      "\t\t\t// convert ineqs to eqs",
      "\t\t} // D[i][n]: artificial variable for testing feasibility",
      "\t\tF0R(j,n) { ",
      "\t\t\tN[j] = j; // non-basic variables, all zero",
      "\t\t\tD[m][j] = -c[j]; // minimize -c^T x",
      "\t\t} ",
      "\t\tN[n] = -1; D[m+1][n] = 1; ",
      "\t}",
      "\tvoid pivot(int r, int s) { // r = row, c = column",
      "\t\tT *a = D[r].data(), inv = 1/a[s]; ",
      "\t\tF0R(i,m+2) if (i != r && abs(D[i][s]) > eps) {",
      "\t\t\tT *b = D[i].data(), binv = b[s]*inv;",
      "\t\t\tF0R(j,n+2) b[j] -= a[j]*binv; ",
      "\t\t\t// make column corresponding to s all 0s",
      "\t\t\tb[s] = a[s]*binv; // swap N[s] with B[r]",
      "\t\t}",
      "\t\t// equation for r scaled so x_r coefficient equals 1",
      "\t\tF0R(j,n+2) if (j != s) D[r][j] *= inv; ",
      "\t\tF0R(i,m+2) if (i != r) D[i][s] *= -inv; ",
      "\t\tD[r][s] = inv; swap(B[r], N[s]); // swap basic w/ non-basic",
      "\t}",
      "\tbool simplex(int phase) {",
      "\t\tint x = m+phase-1;",
      "\t\twhile (1) {",
      "\t\t\tint s = -1; F0R(j,n+1) if (N[j] != -phase) ltj(D[x]); ",
      "\t\t\t// find most negative col for nonbasic (nb) variable",
      "\t\t\tif (D[x][s] >= -eps) return 1; ",
      "\t\t\t// can't get better sol by increasing nb variable",
      "\t\t\tint r = -1;",
      "\t\t\tF0R(i,m) {",
      "\t\t\t\tif (D[i][s] <= eps) continue;",
      "\t\t\t\tif (r == -1 || mp(D[i][n+1] / D[i][s], B[i])",
      "\t\t\t\t\t\t\t < mp(D[r][n+1] / D[r][s], B[r])) r = i; ",
      "\t\t\t\t// find smallest positive ratio",
      "\t\t\t} // -> max increase in nonbasic variable",
      "\t\t\tif (r == -1) return 0; // unbounded",
      "\t\t\tpivot(r,s);",
      "\t\t}",
      "\t}",
      "\tT solve(vd& x) {",
      "\t\tint r = 0; FOR(i,1,m) if (D[i][n+1] < D[r][n+1]) r = i;",
      "\t\tif (D[r][n+1] < -eps) { // run simplex, find feasible x!=0",
      "\t\t\tpivot(r, n); // N[n] = -1 is artificial variable",
      "\t\t\t// initially set to smth large",
      "\t\t\tif (!simplex(2) || D[m+1][n+1] < -eps) return -inf; ",
      "\t\t\t// D[m+1][n+1] is max possible value of the negation of ",
      "\t\t\t// artificial variable, optimal value should be zero ",
      "\t\t\t// if exists feasible solution",
      "\t\t\tF0R(i,m) if (B[i] == -1) { // ?",
      "\t\t\t\tint s = 0; FOR(j,1,n+1) ltj(D[i]);",
      "\t\t\t\tpivot(i,s);",
      "\t\t\t}",
      "\t\t}",
      "\t\tbool ok = simplex(1); x = vd(n);",
      "\t\tF0R(i,m) if (B[i] < n) x[B[i]] = D[i][n+1]; ",
      "\t\treturn ok ? D[m][n+1] : inf;",
      "\t}",
      "};"
    ],
    "description": "Solves a general linear maximization problem: ,  * maximize \\$c^T x\\$ subject to \\$Ax \\le b\\$, \\$x \\ge 0\\$., * Returns -inf if there is no solution, , * inf if there are arbitrarily good solutions, , * or the maximum value of \\$c^T x\\$ otherwise., * The input vector is set to an optimal \\$x\\$ , * (or in the unbounded case, an arbitrary solution fulfilling the constraints)., * Numerical stability is not guaranteed. For better performance, , * define variables such that \\$x = 0\\$ is viable., * Usage:,  * vvd A = {{1,-1}, {-1,1}, {-1,-2}};,  * vd b = {1,1,-4}, c = {-1,-1}, x;,  * T val = LPSolver(A, b, c).solve(x);, * Time: O(NM \\cdot \\#pivots), where a pivot may be e.g. an edge relaxation. O(2^N) in the general case., *"
  },
  "ChirpZ": {
    "prefix":["benq_ChirpZ"],
    "body": [
      "/**",
      " * Description: Modified Chirp-Z. For \\$x\\neq 0\\$, computes ",
      " \t* \\$A(x^0), A(x^1), \\ldots, A(x^{n-1})\\$.",
      " * Time: FFT(2|A|+n)",
      " * Source: https://cp-algorithms.com/algebra/polynomial.html",
      " \t* https://github.com/e-maxx-eng/e-maxx-eng-aux/blob/master/src/polynomial.cpp",
      " \t* https://codeforces.com/blog/entry/82165",
      " * Verification:",
      " \t* https://codeforces.com/contest/1054/problem/H",
      " */",
      "",
      "#include \"FFT.h\"",
      "",
      "poly chirpz(poly A, T x, int n) {",
      "\tauto gen = [&](T c) -> poly {",
      "\t\tpoly p(sz(A)+n); p[0] = 1;",
      "\t\tT t = 1; FOR(i,1,sz(p)) p[i] = p[i-1]*t, t *= c; ",
      "\t\treturn p;",
      "\t}; // uses ij = -C(i,2)+C(i+j,2)-C(j,2)",
      "\tpoly ip = gen(1/x); F0R(i,sz(A)) A[i] *= ip[i];",
      "\treverse(all(A)); poly res = mul(A,gen(x)); ",
      "\tres = poly(sz(A)-1+all(res)); F0R(i,n) res[i] *= ip[i];",
      "\treturn res;",
      "}",
      "// poly chirpzNaive(poly A, T x, int n) {",
      "// \tpoly res; F0R(i,n) res.pb(eval(A,pow(x,i)));",
      "// \treturn res; }"
    ],
    "description": "Modified Chirp-Z. For \\$x\\neq 0\\$, computes ,  * \\$A(x^0), A(x^1), \\ldots, A(x^{n-1})\\$., * Time: FFT(2|A|+n), *"
  },
  "FFT": {
    "prefix":["benq_FFT"],
    "body": [
      "/**",
      " * Description: Multiply polynomials of ints for any modulus \\$<2^{31}\\$. ",
      " \t* For XOR convolution ignore \\texttt{m} within \\texttt{fft}. ",
      " * Time: O(N\\log N)",
      " * Source: ",
      " \t* KACTL (https://github.com/kth-competitive-programming/kactl/blob/master/content/numerical/NumberTheoreticTransform.h)",
      " \t* https://cp-algorithms.com/algebra/fft.html",
      " \t* https://csacademy.com/blog/fast-fourier-transform-and-variations-of-it",
      " \t* maroonrk",
      " * Verification: ",
      "\t* https://judge.yosupo.jp/problem/convolution_mod",
      "\t* SPOJ polymul, CSA manhattan, CF Perfect Encoding",
      "\t* http://codeforces.com/contest/632/problem/E",
      " */",
      "",
      "#include \"ModInt.h\"",
      "// const int MOD = 998244353;",
      "",
      "template<class T> void fft(V<T>& A, bool inv = 0) { // NTT",
      "\tint n = sz(A); assert((T::mod-1)%n == 0); V<T> B(n);",
      "\tfor(int b = n/2; b; b /= 2, swap(A,B)) {",
      "\t\tT w = pow(T::rt(),(T::mod-1)/n*b), m = 1;",
      "\t\tfor(int i = 0; i < n; i += b*2, m *= w) F0R(j,b) {",
      "\t\t\tT u = A[i+j], v = A[i+j+b]*m;",
      "\t\t\tB[i/2+j] = u+v; B[i/2+j+n/2] = u-v;",
      "\t\t}",
      "\t}",
      "\tif (inv) { reverse(1+all(A)); ",
      "\t\tT z = T(1)/T(n); each(t,A) t *= z; }",
      "}",
      "template<class T> V<T> mul(V<T> A, V<T> B) { // only special moduli for NTT",
      "\tif (!min(sz(A),sz(B))) return {};",
      "\tint s = sz(A)+sz(B)-1, n = 1; for (; n < s; n *= 2);",
      "\tbool eq = A == B; A.rsz(n), fft(A);",
      "\tif (eq) B = A; // squaring A, reuse result",
      "\telse B.rsz(n), fft(B);",
      "\tF0R(i,n) A[i] *= B[i];",
      "\tfft(A,1); A.rsz(s); return A;",
      "}",
      "template<class M, class T> V<M> mulMod(V<T> x, V<T> y) {",
      "\tauto con = [](const V<T>& v) {",
      "\t\tV<M> w(sz(v)); F0R(i,sz(v)) w[i] = (int)v[i];",
      "\t\treturn w; };",
      "\treturn mul(con(x),con(y));",
      "}",
      "template<class T> V<T> MUL(const V<T>& A, const V<T>& B) { // arbitrary moduli",
      "\tusing m0 = mint<(119<<23)+1,62>; auto c0 = mulMod<m0>(A,B);",
      "\tusing m1 = mint<(5<<25)+1,  62>; auto c1 = mulMod<m1>(A,B);",
      "\tusing m2 = mint<(7<<26)+1,  62>; auto c2 = mulMod<m2>(A,B);",
      "\tint n = sz(c0); V<T> res(n);",
      "\tm1 r01 = 1/m1(m0::mod); m2 r02 = 1/m2(m0::mod), r12 = 1/m2(m1::mod);",
      "\tF0R(i,n) { // a is remainder mod m0::mod, b fixes it mod m1::mod",
      "\t\tint a = c0[i].v, b = ((c1[i]-a)*r01).v, c = (((c2[i]-a)*r02-b)*r12).v;",
      "\t\tres[i] = (T(c)*m1::mod+b)*m0::mod+a; // c fixes it mod m2::mod",
      "\t}",
      "\treturn res;",
      "}"
    ],
    "description": "Multiply polynomials of ints for any modulus \\$<2^{31}\\$. ,  * For XOR convolution ignore \\texttt{m} within \\texttt{fft}. , * Time: O(N\\log N), *"
  },
  "Karatsuba": {
    "prefix":["benq_Karatsuba"],
    "body": [
      "/**",
      " * Description: Multiply two polynomials (but FFTmod suffices).",
      " * Time: \\$O(N^{\\log_2 3})\\$",
      " * Source: kevinsogo ",
      "\t* https://www.hackerrank.com/contests/noi-ph-2019/challenges/yet-another-packing-problem/editorial",
      "\t* also see http://codeforces.com/contest/623/submission/15807539",
      "\t* https://en.wikipedia.org/wiki/Karatsuba\\_algorithm",
      " * Verification: https://open.kattis.com/problems/polymul2",
      " */",
      "",
      "int size(int s) { return s > 1 ? 32-__builtin_clz(s-1) : 0; }",
      "template<class T> void ks(T* a, T* b, T* c, T* t, int n) {",
      "\tint ca=0, cb=0; F0R(i,n) ca += a[i]!=0, cb += b[i]!=0;",
      "\tif (min(ca, cb) <= 1500/n) { // few numbers to multiply",
      "\t\tif (ca > cb) swap(a,b);",
      "\t\tF0R(i,n) if (a[i] != 0) F0R(j,n) c[i+j] += a[i]*b[j];",
      "\t} else {",
      "\t\tint h = n>>1;",
      "\t\tks(a,b,c,t,h); ks(a+h,b+h,c+n,t,h); // a0*b0, a1*b1",
      "\t\tF0R(i,h) a[i] += a[i+h], b[i] += b[i+h]; ",
      "\t\tks(a,b,t,t+n,h); // (a0+a1)*(b0+b1)",
      "\t\tF0R(i,h) a[i] -= a[i+h], b[i] -= b[i+h];",
      "\t\tF0R(i,n) t[i] -= c[i]+c[i+n];",
      "\t\tF0R(i,n) c[i+h] += t[i], t[i] = 0;",
      "\t}",
      "}",
      "template<class T> vector<T> conv(vector<T> a, vector<T> b) {",
      "\tint sa = sz(a), sb = sz(b); if (!sa || !sb) return {};",
      "\tint n = 1<<size(max(sa,sb)); a.rsz(n), b.rsz(n);",
      "\tvector<T> c(2*n), t(2*n); ",
      "\tks(&a[0],&b[0],&c[0],&t[0],n);",
      "\tc.rsz(sa+sb-1); return c;",
      "}"
    ],
    "description": "Multiply two polynomials (but FFTmod suffices)., * Time: \\$O(N^{\\log_2 3})\\$, *"
  },
  "Poly": {
    "prefix":["benq_Poly"],
    "body": [
      "/**",
      " * Description: Basic poly ops including division. Can replace \\texttt{T} with double, complex.",
      " * Source: Own. Also see",
      "\t* https://github.com/kth-competitive-programming/kactl/blob/master/content/numerical/PolyInterpolate.h",
      "\t* https://github.com/ecnerwala/icpc-book/blob/master/content/numerical/fft.cpp",
      " * Verification: see FFT",
      " */",
      "",
      "#include \"../../number-theory (11.1)/Modular Arithmetic/ModInt.h\"",
      "",
      "using T = mi; using poly = vector<T>;",
      "void remz(poly& p) { while (sz(p)&&p.bk==T(0)) p.pop_back(); }",
      "poly REMZ(poly p) { remz(p); return p; }",
      "poly rev(poly p) { reverse(all(p)); return p; }",
      "poly shift(poly p, int x) { ",
      "\tif (x >= 0) p.insert(begin(p),x,0); ",
      "\telse assert(sz(p)+x >= 0), p.erase(begin(p),begin(p)-x);",
      "\treturn p; ",
      "}",
      "poly RSZ(const poly& p, int x) { ",
      "\tif (x <= sz(p)) return poly(begin(p),begin(p)+x);",
      "\tpoly q = p; q.rsz(x); return q;  }",
      "T eval(const poly& p, T x) { // evaluate at point x",
      "\tT res = 0; R0F(i,sz(p)) res = x*res+p[i]; ",
      "\treturn res; }",
      "poly dif(const poly& p) { // differentiate",
      "\tpoly res; FOR(i,1,sz(p)) res.pb(T(i)*p[i]); ",
      "\treturn res; }",
      "poly integ(const poly& p) { // integrate",
      "\tpoly res(sz(p)+1); F0R(i,sz(p)) res[i+1] = p[i]/T(i+1);",
      "\treturn res; }",
      "",
      "poly& operator+=(poly& l, const poly& r) {",
      "\tl.rsz(max(sz(l),sz(r))); F0R(i,sz(r)) l[i] += r[i]; ",
      "\treturn l; }",
      "poly& operator-=(poly& l, const poly& r) {",
      "\tl.rsz(max(sz(l),sz(r))); F0R(i,sz(r)) l[i] -= r[i]; ",
      "\treturn l; }",
      "poly& operator*=(poly& l, const T& r) { each(t,l) t *= r; ",
      "\treturn l;\t }",
      "poly& operator/=(poly& l, const T& r) { each(t,l) t /= r; ",
      "\treturn l; }",
      "poly operator+(poly l, const poly& r) { return l += r; }",
      "poly operator-(poly l, const poly& r) { return l -= r; }",
      "poly operator-(poly l) { each(t,l) t *= -1; return l; }",
      "poly operator*(poly l, const T& r) { return l *= r; }",
      "poly operator*(const T& r, const poly& l) { return l*r; }",
      "poly operator/(poly l, const T& r) { return l /= r;\t }",
      "poly operator*(const poly& l, const poly& r) {",
      "\tif (!min(sz(l),sz(r))) return {};",
      "\tpoly x(sz(l)+sz(r)-1); ",
      "\tF0R(i,sz(l)) F0R(j,sz(r)) x[i+j] += l[i]*r[j];",
      "\treturn x;",
      "}",
      "poly& operator*=(poly& l, const poly& r) { return l = l*r; }",
      "",
      "pair<poly,poly> quoRem(poly a, poly b) { ",
      "\tremz(a); remz(b); assert(sz(b));",
      "\tT lst = b.bk, B = T(1)/lst; each(t,a) t *= B; ",
      "\teach(t,b) t *= B;",
      "\tpoly q(max(sz(a)-sz(b)+1,0));",
      "\tfor (int dif; (dif=sz(a)-sz(b)) >= 0; remz(a)) {",
      "\t\tq[dif] = a.bk; F0R(i,sz(b)) a[i+dif] -= q[dif]*b[i]; }",
      "\teach(t,a) t *= lst;",
      "\treturn {q,a}; // quotient, remainder",
      "}",
      "poly operator/(const poly& a, const poly& b) { return quoRem(a,b).f; }",
      "poly operator%(const poly& a, const poly& b) { return quoRem(a,b).s; }",
      "/**poly a = {1,3,5,8,6,0,0,0,0}, b = {1,5,1};",
      "ps(quoRem(a,b)); a = 2*a, b = 2*b; ps(quoRem(a,b));*/",
      "poly gcd(poly a, poly b) { return b == poly{} ? a : gcd(b,a%b); }",
      "T resultant(poly a, poly b) { // R(A,B)",
      "\t// =b_m^n*prod_{j=1}^mA(mu_j)",
      "\t// =b_m^na_m^n*prod_{i=1}^nprod_{j=1}^m(mu_j-lambda_i)",
      "\t// =(-1)^{mn}a_n^m*prod_{i=1}^nB(lambda_i)",
      "\t// =(-1)^{nm}R(B,A)",
      "\t// Also, R(A,B)=b_m^{deg(A)-deg(A-CB)}R(A-CB,B)",
      "\tint ad = sz(a)-1, bd = sz(b)-1; ",
      "\tif (bd <= 0) return bd < 0 ? 0 : pow(b.bk,ad);",
      "\tint pw = ad; a = a%b; pw -= (ad = sz(a)-1);",
      "\treturn resultant(b,a)*pow(b.bk,pw)*T((bd&ad&1)?-1:1);",
      "}"
    ],
    "description": "Basic poly ops including division. Can replace \\texttt{T} with double, complex., *"
  },
  "PolyConv": {
    "prefix":["benq_PolyConv"],
    "body": [
      "/**",
      " * Description: Multiply small polys directly, otherwise use FFT.",
      " * Source: KACTL, https://cp-algorithms.com/algebra/fft.html",
      " */",
      "",
      "#include \"Poly.h\"",
      "#include \"FFT.h\"",
      "",
      "bool small(const poly& a, const poly& b) { // multiply directly",
      "\treturn (ll)sz(a)*sz(b) <= 10000; } ",
      "// vmi smart(const vmi& a, const vmi& b) { return mul(a,b); }",
      "// vl smart(const vl& a, const vl& b) {",
      "// \tauto X = mul(vcd(all(a)),vcd(all(b)));",
      "// \tvl x(sz(X)); F0R(i,sz(X)) x[i] = round(X[i].real());",
      "// \treturn x; }",
      "poly conv(const poly& a, const poly& b) {",
      "\treturn small(a,b) ? a*b : mul(a,b); } "
    ],
    "description": "Multiply small polys directly, otherwise use FFT., *"
  },
  "PolyEuclid": {
    "prefix":["benq_PolyEuclid"],
    "body": [
      "/**",
      " * Description: Euclidean Algorithm for polynomials using Half-GCD",
      " * Source:",
      "\t * https://dl.acm.org/doi/pdf/10.1145/800125.804045",
      "\t \t* only works for normal remainder seqs",
      "\t * https://pdfs.semanticscholar.org/a7e7/b01a3dd6ac0ec160b35e513c5efa38c2369e.pdf",
      "\t \t* complete solution",
      " * Time: O(N\\log^2N)",
      " * Verification: https://judge.yosupo.jp/problem/inv_of_polynomials",
      " */",
      "",
      "#include \"PolyInv.h\"",
      "",
      "typedef array<poly,2> Arr;",
      "typedef array<Arr,2> Mat;",
      "const Mat ID = {Arr{poly{1},poly{}},Arr{poly{},poly{1}}};",
      "Arr cut(Arr a, int k) { // decrease degrees by k",
      "\tF0R(i,2) a[i] = shift(a[i],-k);",
      "\treturn a; }",
      "Arr operator*(Mat a, Arr b) {",
      "\tArr c; F0R(i,2) c[i] = REMZ(conv(a[i][0],b[0])+conv(a[i][1],b[1])); ",
      "\treturn c; }",
      "Mat operator*(Mat a, Mat b) { // multiply matrices",
      "\tMat res; F0R(i,2) F0R(j,2) F0R(k,2) res[i][k] += conv(a[i][j],b[j][k]);",
      "\treturn res; }",
      "",
      "void step(Mat& m, Arr& a) { // perform one step of euclidean algo",
      "\tauto q = divi(a[0],a[1]); a = {a[1],REMZ(q.s)};",
      "\tm = {m[1],{REMZ(m[0][0]-conv(q.f,m[1][0])),REMZ(m[0][1]-conv(q.f,m[1][1]))}};",
      "}",
      "Mat hGCD(Arr a) { // half-gcd algo",
      "\tassert(sz(a[0]) > sz(a[1]) && sz(a[1])); // perform euclid steps until deg(a[1]) < m",
      "\tint m = sz(a[0])/2; if (sz(a[1]) <= m) return ID;",
      "\tMat R = hGCD(cut(a,m)); a = R*a; if (sz(a[1]) <= m) return R;",
      "\tstep(R,a); if (sz(a[1]) <= m) return R;",
      "\tint l = sz(a[0])-1, k = 2*m-l; return hGCD(cut(a,k))*R;",
      "}",
      "Mat euclid(Arr a) {",
      "\tassert(sz(a[0]) > sz(a[1]) && sz(a[1]));",
      "\tMat m0 = hGCD(a); a = m0*a; if (!sz(a[1])) return m0;",
      "\tstep(m0,a); if (!sz(a[1])) return m0;",
      "\treturn euclid(a)*m0;",
      "}",
      "poly getInv(poly x, poly y) { // x*ans-1 is divisible by y",
      "\tMat res = ID; Arr a = {x,y}; step(res,a); ",
      "\tif (sz(a[1])) res = euclid(a)*res; // same result as \"while (sz(a[1])) step(res,a);\"",
      "\tpoly gcd = REMZ(conv(res[0][0],x)+conv(res[0][1],y));",
      "\tif (sz(gcd) != 1) { ps(-1); exit(0); } // gcd has deg > 0",
      "\treturn REMZ(1/gcd[0]*res[0][0]);",
      "}"
    ],
    "description": "Euclidean Algorithm for polynomials using Half-GCD, *"
  },
  "PolyInterpolate": {
    "prefix":["benq_PolyInterpolate"],
    "body": [
      "/**",
      " * Description: \\$n\\$ points determine unique polynomial of degree \\$\\le n-1\\$.",
      " \t* For numerical precision pick \\$v[k].f = c*\\cos(k/(n-1)*\\pi), k=0 \\dots n-1\\$.",
      " * Time: O(n^2)",
      " * Source: KACTL",
      " * Verification: see FFT",
      " */",
      "",
      " #include \"Poly.h\"",
      "",
      "poly interpolate(vector<pair<T,T>> v) {",
      "\tint n = sz(v); poly res, tmp = {1};",
      "\tF0R(i,n) { T prod = 1; // modify poly for previous i points",
      "\t\tF0R(j,i) v[i].s -= prod*v[j].s, prod *= v[i].f-v[j].f;",
      "\t\tv[i].s /= prod; res += v[i].s*tmp; tmp *= poly{-v[i].f,1};",
      "\t} // add multiple of (x-v[0].f)*(x-v[1].f)*...*(x-v[i-1].f)",
      "\treturn res;",
      "}",
      "/**",
      "poly _interpolate(vector<pair<T,T>> v) {",
      "\tpoly ret, prod = {1}; each(t,v) prod *= poly({-t.f,1});",
      "\tF0R(i,sz(v)) {",
      "\t\tT fac = 1; F0R(j,sz(v)) if (i != j) fac *= v[i].f-v[j].f;",
      "\t\tret += v[i].s/fac*quoRem(prod,{-v[i].f,1}).f;",
      "\t}",
      "\treturn ret;",
      "}",
      "",
      "vector<pair<T,T>> v; poly p = {4,6,7,11}, x = {1,3,9,16};",
      "each(X,x) v.pb({X,eval(p,X)});",
      "ps(interpolate(v));",
      "*/"
    ],
    "description": "\\$n\\$ points determine unique polynomial of degree \\$\\le n-1\\$.,  * For numerical precision pick \\$v[k].f = c*\\cos(k/(n-1)*\\pi), k=0 \\dots n-1\\$., * Time: O(n^2), *"
  },
  "PolyInv": {
    "prefix":["benq_PolyInv"],
    "body": [
      "/**",
      " * Description: computes \\$A^{-1}\\$ such that \\$AA^{-1}\\equiv 1\\pmod{x^n}\\$.",
      " \t* Newton's method: If you want \\$F(x)=0\\$ and \\$F(Q_k)\\equiv 0\\pmod{x^a}\\$",
      " \t* then \\$Q_{k+1}=Q_k-\\frac{F(Q_k)}{F'(Q_k)}\\pmod{x^{2a}}\\$ satisfies",
      " \t* \\$F(Q_{k+1})\\equiv 0 \\pmod{x^{2a}}\\$. Application: if \\$f(n),g(n)\\$ are the",
      " \t* \\#s of forests and trees on \\$n\\$ nodes then ",
      " \t* \\$\\sum_{n=0}^{\\infty}f(n)x^n=\\exp\\left(\\sum_{n=1}^{\\infty}\\frac{g(n)}{n!}\\right)\\$.",
      " * Time: O(N\\log N)",
      " * Source: CF, http://people.csail.mit.edu/madhu/ST12/scribe/lect06.pdf",
      " \t* https://cp-algorithms.com/algebra/polynomial.html",
      " * Usage: vmi v={1,5,2,3,4}; ps(exp(2*log(v,9),9)); // squares v",
      " * Verification: https://codeforces.com/contest/438/problem/E",
      " \t* https://codeforces.com/gym/102028/submission/77687049",
      " \t* https://loj.ac/problem/6703 (MultipointEval)",
      " */",
      "",
      "#include \"PolyConv.h\"",
      "",
      "poly inv(poly A, int n) { // Q-(1/Q-A)/(-Q^{-2})",
      "\tpoly B{1/A[0]};",
      "\tfor (int x = 2; x/2 < n; x *= 2)",
      "\t\tB = 2*B-RSZ(conv(RSZ(A,x),conv(B,B)),x);",
      "\treturn RSZ(B,n);",
      "}",
      "poly sqrt(const poly& A, int n) {  // Q-(Q^2-A)/(2Q)",
      "\tassert(A[0] == 1); poly B{1};",
      "\tfor (int x = 2; x/2 < n; x *= 2)",
      "\t\tB = T(1)/T(2)*RSZ(B+conv(RSZ(A,x),inv(B,x)),x);",
      "\treturn RSZ(B,n);",
      "}",
      "pair<poly,poly> divi(const poly& f, const poly& g) { // return quotient and remainder",
      "\tif (sz(f) < sz(g)) return {{},f};",
      "\tpoly q = conv(inv(rev(g),sz(f)-sz(g)+1),rev(f));",
      "\tq = rev(RSZ(q,sz(f)-sz(g)+1));",
      "\tpoly r = RSZ(f-conv(q,g),sz(g)-1); return {q,r};",
      "}",
      "poly log(poly A, int n) { assert(A[0] == 1); // (ln A)' = A'/A",
      "\tA.rsz(n); return integ(RSZ(conv(dif(A),inv(A,n-1)),n-1)); }",
      "poly exp(poly A, int n) { assert(A[0] == 0);",
      "\tpoly B{1}, IB{1};",
      "\tfor (int x = 1; x < n; x *= 2) {",
      "\t\tIB = 2*IB-RSZ(conv(B,conv(IB,IB)),x); // inverse of B to x places",
      "\t\tpoly Q = dif(RSZ(A,x)); Q += RSZ(conv(IB,dif(B)-conv(B,Q)),2*x-1); ",
      "\t\t// first x-1 terms of dif(B)-conv(B,Q) are zero",
      "\t\tB = B+RSZ(conv(B,RSZ(A,2*x)-integ(Q)),2*x); ",
      "\t} // We know that Q=A' is B'/B to x-1 places, we want to find B'/B to 2x-1 places",
      "\treturn RSZ(B,n);",
      "}",
      "// poly expOld(poly A, int n) { // Q-(lnQ-A)/(1/Q)",
      "// \tassert(A[0] == 0); poly B = {1};",
      "// \twhile (sz(B) < n) { int x = 2*sz(B);",
      "// \t\tB = RSZ(B+conv(B,RSZ(A,x)-log(B,x)),x); }",
      "// \treturn RSZ(B,n);",
      "// }",
      "",
      "void segProd(vector<poly>& stor, poly& v, int ind, int l, int r) { // v -> places to evaluate at",
      "\tif (l == r) { stor[ind] = {-v[l],1}; return; }",
      "\tint m = (l+r)/2; segProd(stor,v,2*ind,l,m); segProd(stor,v,2*ind+1,m+1,r);",
      "\tstor[ind] = conv(stor[2*ind],stor[2*ind+1]);",
      "}",
      "void evalAll(vector<poly>& stor, poly& res, poly v, int ind = 1) {",
      "\tv = divi(v,stor[ind]).s;",
      "\tif (sz(stor[ind]) == 2) { res.pb(sz(v)?v[0]:0); return; }",
      "\tevalAll(stor,res,v,2*ind); evalAll(stor,res,v,2*ind+1);",
      "}",
      "poly multiEval(poly v, poly p) {",
      "\tvector<poly> stor(4*sz(p)); segProd(stor,p,1,0,sz(p)-1);",
      "\tpoly res; evalAll(stor,res,v); return res; }",
      "",
      "poly combAll(vector<poly>& stor, poly& dems, int ind, int l, int r) {",
      "\tif (l == r) return {dems[l]};",
      "\tint m = (l+r)/2;",
      "\tpoly a = combAll(stor,dems,2*ind,l,m), b = combAll(stor,dems,2*ind+1,m+1,r);",
      "\treturn conv(a,stor[2*ind+1])+conv(b,stor[2*ind]);",
      "}",
      "poly interpolate(vector<pair<T,T>> v) {",
      "\tint n = sz(v); poly x; each(t,v) x.pb(t.f);",
      "\tvector<poly> stor(4*n); segProd(stor,x,1,0,n-1);",
      "\tpoly dems; evalAll(stor,dems,dif(stor[1]));",
      "\tF0R(i,n) dems[i] = v[i].s/dems[i];",
      "\treturn combAll(stor,dems,1,0,n-1);",
      "}"
    ],
    "description": "computes \\$A^{-1}\\$ such that \\$AA^{-1}\\equiv 1\\pmod{x^n}\\$.,  * Newton's method: If you want \\$F(x)=0\\$ and \\$F(Q_k)\\equiv 0\\pmod{x^a}\\$,  * then \\$Q_{k+1}=Q_k-\\frac{F(Q_k)}{F'(Q_k)}\\pmod{x^{2a}}\\$ satisfies,  * \\$F(Q_{k+1})\\equiv 0 \\pmod{x^{2a}}\\$. Application: if \\$f(n),g(n)\\$ are the,  * \\#s of forests and trees on \\$n\\$ nodes then ,  * \\$\\sum_{n=0}^{\\infty}f(n)x^n=\\exp\\left(\\sum_{n=1}^{\\infty}\\frac{g(n)}{n!}\\right)\\$., * Time: O(N\\log N), *"
  },
  "PolyRoots": {
    "prefix":["benq_PolyRoots"],
    "body": [
      "/**",
      " * Source: KACTL",
      " * Description: Finds the real roots of a polynomial.",
      " * Usage: poly_roots({{2,-3,1}},-1e9,1e9) // solve x^2-3x+2 = 0",
      " * Time: O(N^2 \\log(1/\\epsilon))",
      " * Verification: https://open.kattis.com/problems/firingphaser",
      " */",
      "",
      "#include \"Poly.h\"",
      "",
      "typedef ld T;",
      "poly polyRoots(poly p, T xmin, T xmax) {",
      "\tif (sz(p) == 2) { return {-p[0]/p[1]}; }",
      "\tauto dr = polyRoots(dif(p),xmin,xmax);",
      "\tdr.pb(xmin-1); dr.pb(xmax+1); sort(all(dr));",
      "\tpoly ret;",
      "\tF0R(i,sz(dr)-1) {",
      "\t\tT l = dr[i], h = dr[i+1];",
      "\t\tbool sign = eval(p,l) > 0;",
      "\t\tif (sign^(eval(p,h) > 0)) {",
      "\t\t\tF0R(it,60) { // while (h-l > 1e-8)",
      "\t\t\t\tauto m = (l+h)/2, f = eval(p,m);",
      "\t\t\t\tif ((f <= 0) ^ sign) l = m;",
      "\t\t\t\telse h = m;",
      "\t\t\t}",
      "\t\t\tret.pb((l+h)/2);",
      "\t\t}",
      "\t}",
      "\treturn ret;",
      "}"
    ],
    "description": "None"
  },
  "PalTree": {
    "prefix":["benq_PalTree"],
    "body": [
      "/**",
      " * Description: Used infrequently. Palindromic tree computes ",
      "\t* number of occurrences of each palindrome within string.",
      "\t* \\texttt{ans[i][0]} stores min even \\$x\\$ such that ",
      "\t* the prefix \\$s[1..i]\\$ can be split into exactly \\$x\\$",
      "\t* palindromes, \\texttt{ans[i][1]} does the same for odd \\$x.\\$",
      " * Time: \\$O(N\\sum)\\$ for addChar, \\$O(N\\log N)\\$ for updAns",
      " * Source: ",
      "\t* http://codeforces.com/blog/entry/13959",
      "\t* https://codeforces.com/blog/entry/19193",
      " * Verification: ",
      "\t* https://oj.uz/problem/view/APIO14_palindrome",
      "\t* http://acm.timus.ru/problem.aspx?space=1&num=2058 (call vector reserve to pass ML)",
      "\t* https://codeforces.com/gym/102141/attachments F",
      " */",
      "",
      "struct PalTree {",
      "\tstatic const int ASZ = 26;",
      "\tstruct node {",
      "\t\tarray<int,ASZ> to = array<int,ASZ>();",
      "\t\tint len, link, oc = 0; // # occurrences of pal",
      "\t\tint slink = 0, diff = 0;",
      "\t\tarray<int,2> seriesAns;",
      "\t\tnode(int _len, int _link) : len(_len), link(_link) {}",
      "\t};",
      "\tstr s = \"@\"; vector<array<int,2>> ans = {{0,MOD}};",
      "\tvector<node> d = {{0,1},{-1,0}}; // dummy pals of len 0,-1",
      "\tint last = 1;",
      "\tint getLink(int v) {",
      "\t\twhile (s[sz(s)-d[v].len-2] != s.bk) v = d[v].link;",
      "\t\treturn v;",
      "\t}",
      "\tvoid updAns() { // serial path has O(log n) vertices",
      "\t\tans.pb({MOD,MOD});",
      "\t\tfor (int v = last; d[v].len > 0; v = d[v].slink) {",
      "\t\t\td[v].seriesAns=ans[sz(s)-1-d[d[v].slink].len-d[v].diff];",
      "\t\t\tif (d[v].diff == d[d[v].link].diff) ",
      "\t\t\t\tF0R(i,2) ckmin(d[v].seriesAns[i],",
      "\t\t\t\t\t\t\td[d[v].link].seriesAns[i]);",
      "\t\t\t// start of previous oc of link[v]=start of last oc of v",
      "\t\t\tF0R(i,2) ckmin(ans.bk[i],d[v].seriesAns[i^1]+1);",
      "\t\t}",
      "\t}",
      "\tvoid addChar(char C) {",
      "\t\ts += C; int c = C-'a'; last = getLink(last);",
      "\t\tif (!d[last].to[c]) {",
      "\t\t\td.eb(d[last].len+2,d[getLink(d[last].link)].to[c]);",
      "\t\t\td[last].to[c] = sz(d)-1;",
      "\t\t\tauto& z = d.bk; z.diff = z.len-d[z.link].len;",
      "\t\t\tz.slink = z.diff == d[z.link].diff ",
      "\t\t\t\t? d[z.link].slink : z.link;",
      "\t\t} // max suf with different dif",
      "\t\tlast = d[last].to[c]; d[last].oc ++;",
      "\t\tupdAns();",
      "\t}",
      "\tvoid numOc() { ROF(i,2,sz(d)) d[d[i].link].oc += d[i].oc; }",
      "};"
    ],
    "description": "Used infrequently. Palindromic tree computes , * number of occurrences of each palindrome within string., * \\texttt{ans[i][0]} stores min even \\$x\\$ such that , * the prefix \\$s[1..i]\\$ can be split into exactly \\$x\\$, * palindromes, \\texttt{ans[i][1]} does the same for odd \\$x.\\$, * Time: \\$O(N\\sum)\\$ for addChar, \\$O(N\\log N)\\$ for updAns, *"
  },
  "SuffixAutomaton": {
    "prefix":["benq_SuffixAutomaton"],
    "body": [
      "/**",
      " * Description: Used infrequently. Constructs minimal deterministic ",
      " \t* finite automaton (DFA) that recognizes all suffixes of a string.",
      " \t* \\texttt{len} corresponds to the maximum length of a string in",
      " \t* the equivalence class, \\texttt{pos} corresponds to",
      " \t* the first ending position of such a string, \\texttt{lnk}",
      " \t* corresponds to the longest suffix that is in a different class.",
      " \t* Suffix links correspond to suffix tree of the reversed string!",
      " * Time: O(N\\log \\sum)",
      " * Source: *",
      " * Verification: *",
      " */",
      " ",
      "struct SuffixAutomaton {",
      "\tint N = 1; vi lnk{-1}, len{0}, pos{-1}; // max length of state, suffix link, last pos of first occurrence of state",
      "\tvector<map<char,int>> nex{1}; vector<bool> isClone{0}; // transitions, cloned -> not terminal state",
      "\tvector<vi> iLnk; // inverse links",
      "\tint add(int p, char c) { // ~p is nonzero if p != -1",
      "\t\tauto getNex = [&]() {",
      "\t\t\tif (p == -1) return 0;",
      "\t\t\tint q = nex[p][c]; if (len[p]+1 == len[q]) return q;",
      "\t\t\tint clone = N++; lnk.pb(lnk[q]); lnk[q] = clone;",
      "\t\t\tlen.pb(len[p]+1); nex.pb(nex[q]), pos.pb(pos[q]), isClone.pb(1);",
      "\t\t\tfor (; ~p && nex[p][c] == q; p = lnk[p]) nex[p][c] = clone;",
      "\t\t\treturn clone;",
      "\t\t};",
      "\t\t// if (nex[p].count(c)) return getNex(); <- need if adding > 1 string",
      "\t\tint cur = N++; // make new state",
      "\t\tlnk.eb(), len.pb(len[p]+1), nex.eb(), pos.pb(pos[p]+1), isClone.pb(0);",
      "\t\tfor (; ~p && !nex[p].count(c); p = lnk[p]) nex[p][c] = cur;",
      "\t\tint x = getNex(); lnk[cur] = x; ",
      "\t\treturn cur;",
      "\t}",
      "\tvoid init(str s) { int p = 0; each(x,s) p = add(p,x); } // add string to automaton",
      "\tvoid genIlnk() { iLnk.rsz(N); FOR(v,1,N) iLnk[lnk[v]].pb(v); } // inverse links",
      "\t// APPLICATIONS",
      "\tvoid getAllOccur(vi& oc, int v) {",
      "\t\tif (!isClone[v]) oc.pb(pos[v]); // terminal position",
      "\t\teach(u,iLnk[v]) getAllOccur(oc,u); }",
      "\tvi allOccur(str s) { // get all occurrences of s in automaton",
      "\t\tint cur = 0;",
      "\t\teach(x,s) {",
      "\t\t\tif (!nex[cur].count(x)) return {};",
      "\t\t\tcur = nex[cur][x]; }",
      "\t\tvi oc; getAllOccur(oc,cur); each(t,oc) t += 1-sz(s); // convert end pos -> start pos",
      "\t\tsort(all(oc)); return oc;",
      "\t}",
      "\tvl distinct;",
      "\tll getDistinct(int x) { // # of distinct strings starting at state x",
      "\t\tif (distinct[x]) return distinct[x];",
      "\t\tdistinct[x] = 1; each(y,nex[x]) distinct[x] += getDistinct(y.s);",
      "\t\treturn distinct[x]; }",
      "\tll numDistinct() { // # distinct substrings including empty",
      "\t\tdistinct.rsz(N); return getDistinct(0); }",
      "\tll numDistinct2() { // assert(numDistinct() == numDistinct2());",
      "\t\tll ans = 1; FOR(i,1,N) ans += len[i]-len[lnk[i]];",
      "\t\treturn ans; } ",
      "};",
      "",
      "SuffixAutomaton S;",
      "vi sa; str s;",
      "void dfs(int x) {",
      "\tif (!S.isClone[x]) sa.pb(sz(s)-1-S.pos[x]);",
      "\tvector<pair<char,int>> chr;",
      "\teach(t,S.iLnk[x]) chr.pb({s[S.pos[t]-S.len[x]],t});",
      "\tsort(all(chr)); each(t,chr) dfs(t.s);",
      "}",
      "",
      "int main() {",
      "\tre(s); reverse(all(s));",
      "\tS.init(s); S.genIlnk();",
      "\tdfs(0); ps(sa); // generating suffix array for s",
      "}"
    ],
    "description": "Used infrequently. Constructs minimal deterministic ,  * finite automaton (DFA) that recognizes all suffixes of a string.,  * \\texttt{len} corresponds to the maximum length of a string in,  * the equivalence class, \\texttt{pos} corresponds to,  * the first ending position of such a string, \\texttt{lnk},  * corresponds to the longest suffix that is in a different class.,  * Suffix links correspond to suffix tree of the reversed string!, * Time: O(N\\log \\sum), *"
  },
  "SuffixTree": {
    "prefix":["benq_SuffixTree"],
    "body": [
      "/**",
      " * Description: Used infrequently. Ukkonen's algorithm for suffix tree. Longest",
      "   * non-unique suffix of \\texttt{s} has length \\texttt{len[p]+lef} after each",
      "   * call to \\texttt{add} terminates. Each iteration of loop within \\texttt{add}",
      "   * decreases this quantity by one.",
      " * Time: O(N\\log \\sum)",
      " * Source: *",
      " * Verification: *",
      " */",
      "",
      "struct SuffixTree {",
      "\tstr s; int N = 0;",
      "\tvi pos, len, lnk; vector<map<char,int>> to;",
      "\tint make(int POS, int LEN) { // lnk[x] is meaningful when x!=0 and len[x] != MOD",
      "\t\tpos.pb(POS); len.pb(LEN); lnk.pb(-1); to.eb(); return N++; }",
      "\tvoid add(int& p, int& lef, char c) { // our longest non-unique suffix is at node p with lef extra chars",
      "\t\ts += c; lef ++; int lst = 0;",
      "\t\tfor (;lef;p?p=lnk[p]:lef--) { // if p is not root then lnk[p] must be defined",
      "\t\t\twhile (lef>1 && lef>len[to[p][s[sz(s)-lef]]]) // traverse edges of suffix tree while you can",
      "\t\t\t\tp = to[p][s[sz(s)-lef]], lef -= len[p]; ",
      "\t\t\tchar e = s[sz(s)-lef]; int& q = to[p][e]; // next edge of suffix tree",
      "\t\t\tif (!q) q = make(sz(s)-lef,MOD), lnk[lst] = p, lst = 0; // make new edge",
      "\t\t\telse {",
      "\t\t\t\tchar t = s[pos[q]+lef-1]; ",
      "\t\t\t\tif (t == c) { lnk[lst] = p; return; } // suffix is not unique, done",
      "\t\t\t\tint u = make(pos[q],lef-1); // new node for the current suffix - 1, define its link",
      "\t\t\t\tto[u][c] = make(sz(s)-1,MOD); to[u][t] = q; // new node, old node",
      "\t\t\t\tpos[q] += lef-1; if (len[q] != MOD) len[q] -= lef-1;",
      "\t\t\t\tq = u, lnk[lst] = u, lst = u;",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\tvoid init(str _s) {",
      "\t\tmake(-1,0); int p = 0, lef = 0;",
      "\t\teach(c,_s) add(p,lef,c);",
      "\t\tadd(p,lef,'\\$'); s.pop_back(); // terminal char",
      "\t}",
      "\tint maxPre(str x) { // max prefix of x which is substring",
      "\t\tfor (int p = 0, ind = 0;;) {",
      "\t\t\tif (ind == sz(x) || !to[p].count(x[ind])) return ind;",
      "\t\t\tp = to[p][x[ind]];",
      "\t\t\tF0R(i,len[p]) {",
      "\t\t\t\tif (ind == sz(x) || x[ind] != s[pos[p]+i]) return ind;",
      "\t\t\t\tind ++;",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\tvi sa; // generate suffix array",
      "\tvoid genSa(int x = 0, int Len = 0) {",
      "\t\tif (!sz(to[x])) sa.pb(pos[x]-Len); // found terminal node",
      "\t\telse each(t,to[x]) genSa(t.s,Len+len[x]);",
      "\t}",
      "};"
    ],
    "description": "Used infrequently. Ukkonen's algorithm for suffix tree. Longest,   * non-unique suffix of \\texttt{s} has length \\texttt{len[p]+lef} after each,   * call to \\texttt{add} terminates. Each iteration of loop within \\texttt{add},   * decreases this quantity by one., * Time: O(N\\log \\sum), *"
  },
  "ACfixed": {
    "prefix":["benq_ACfixed"],
    "body": [
      "/**",
      " * Description: Aho-Corasick for fixed alphabet. For each prefix, ",
      " \t* stores link to max length suffix which is also a prefix.",
      " * Time: O(N\\sum)",
      " * Source: https://ideone.com/0cMjZJ",
      "\t* https://codeforces.com/contest/710/problem/F",
      "\t* https://codeforces.com/contest/1207/problem/G",
      " */",
      "",
      "struct ACfixed { // fixed alphabet",
      "\tstatic const int ASZ = 26;",
      "\tstruct node { array<int,ASZ> to; int link; };",
      "\tvector<node> d = {{}};",
      "\tint add(str s) { // add word",
      "\t\tint v = 0;",
      "\t\teach(C,s) {",
      "\t\t\tint c = C-'a';",
      "\t\t\tif (!d[v].to[c]) d[v].to[c] = sz(d), d.eb();",
      "\t\t\tv = d[v].to[c];",
      "\t\t}",
      "\t\treturn v;",
      "\t}",
      "\tvoid init() { // generate links",
      "\t\td[0].link = -1; ",
      "\t\tqueue<int> q; q.push(0);",
      "\t\twhile (sz(q)) {",
      "\t\t\tint v = q.ft; q.pop();",
      "\t\t\tF0R(c,ASZ) {",
      "\t\t\t\tint u = d[v].to[c]; if (!u) continue;",
      "\t\t\t\td[u].link = d[v].link == -1 ? 0 : d[d[v].link].to[c];",
      "\t\t\t\tq.push(u); ",
      "\t\t\t}",
      "\t\t\tif (v) F0R(c,ASZ) if (!d[v].to[c]) ",
      "\t\t\t\td[v].to[c] = d[d[v].link].to[c];",
      "\t\t}",
      "\t}",
      "};"
    ],
    "description": "Aho-Corasick for fixed alphabet. For each prefix, ,  * stores link to max length suffix which is also a prefix., * Time: O(N\\sum), *"
  },
  "ACunfixed": {
    "prefix":["benq_ACunfixed"],
    "body": [
      "/**",
      " * Description: for each prefix, stores link to max length suffix which is also a prefix",
      " * Source: https://ideone.com/0cMjZJ",
      " * Verification: ",
      "\t* Kattis stringmultimatching",
      " */",
      "",
      "struct ACunfixed { ",
      "\tstruct node {",
      "\t\tmap<char,int> to;",
      "\t\tint link;",
      "\t};",
      "\tvector<node> d;",
      "\tACunfixed() { d.eb(); }",
      "\tint add(str s) { // add word",
      "\t\tint v = 0;",
      "\t\teach(c,s) {",
      "\t\t\tif (!d[v].to.count(c)) {",
      "\t\t\t\td[v].to[c] = sz(d);",
      "\t\t\t\td.eb();",
      "\t\t\t}",
      "\t\t\tv = d[v].to[c];",
      "\t\t}",
      "\t\treturn v;",
      "\t}",
      "\tint nex(int j, char c) { // state after adding character",
      "\t\twhile (j != -1 && !d[j].to.count(c)) j = d[j].link;",
      "\t\treturn j == -1 ? 0 : d[j].to[c]; ",
      "\t}",
      "\tvoid init() { // generate links",
      "\t\td[0].link = -1;",
      "\t\tqueue<int> q; q.push(0);",
      "\t\twhile (sz(q)) {",
      "\t\t\tint v = q.ft; q.pop();",
      "\t\t\teach(it,d[v].to) {",
      "\t\t\t\tint u = it.s; d[u].link = nex(d[v].link,it.f); ",
      "\t\t\t\tq.push(u); ",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "};"
    ],
    "description": "for each prefix, stores link to max length suffix which is also a prefix, *"
  },
  "HashRange": {
    "prefix":["benq_HashRange"],
    "body": [
      "/**",
      " * Description: Polynomial hash for substrings with two bases.",
      " * Source:",
      "\t* KACTL",
      "\t* https://codeforces.com/contest/1207/submission/59309672",
      " * Verification: ",
      "\t* USACO Dec 17 Plat 1 (LCP :o)",
      "\t* CF Check Transcription",
      " */",
      "",
      "typedef array<int,2> H; // bases not too close to ends ",
      "uniform_int_distribution<int> BDIST(0.1*MOD,0.9*MOD);",
      "const H base = {BDIST(rng),BDIST(rng)};",
      "/// const T ibase = {(int)inv(mi(base[0])),(int)inv(mi(base[1]))};",
      "H operator+(H l, H r) { ",
      "\tF0R(i,2) if ((l[i] += r[i]) >= MOD) l[i] -= MOD;",
      "\treturn l; }",
      "H operator-(H l, H r) { ",
      "\tF0R(i,2) if ((l[i] -= r[i]) < 0) l[i] += MOD;",
      "\treturn l; }",
      "H operator*(H l, H r) { ",
      "\tF0R(i,2) l[i] = (ll)l[i]*r[i]%MOD;",
      "\treturn l; }",
      "H makeH(char c) { return {c,c}; }",
      "/// H& operator+=(H& l, H r) { return l = l+r; }",
      "/// H& operator-=(H& l, H r) { return l = l-r; }",
      "/// H& operator*=(H& l, H r) { return l = l*r; }",
      "",
      "vector<H> pows = {{1,1}};",
      "struct HashRange {",
      "\tstr S; vector<H> cum = {{0,0}};",
      "\tvoid add(char c) { S += c; cum.pb(base*cum.bk+makeH(c)); }",
      "\tvoid add(str s) { each(c,s) add(c); }",
      "\tvoid extend(int len) { while (sz(pows) <= len) pows.pb(base*pows.bk); }",
      "\tH hash(int l, int r) { int len = r+1-l; extend(len);",
      "\t\treturn cum[r+1]-pows[len]*cum[l]; }",
      "\t/**int lcp(HashRange& b) { return first_true([&](int x) { ",
      "\t\treturn cum[x] != b.cum[x]; },0,min(sz(S),sz(b.S)))-1; }*/",
      "};",
      "/// HashRange HR; HR.add(\"ababab\"); F0R(i,6) FOR(j,i,6) ps(i,j,HR.hash(i,j));"
    ],
    "description": "Polynomial hash for substrings with two bases., *"
  },
  "KMP": {
    "prefix":["benq_KMP"],
    "body": [
      "/**",
      " * Source: KACTL",
      " * Time: O(N)",
      " * Description: \\texttt{f[i]} is length of the longest proper suffix ",
      " \t* of the \\$i\\$-th prefix of \\$s\\$ that is a prefix of \\$s\\$",
      " * Verification: https://open.kattis.com/problems/stringmatching",
      " */",
      "",
      "vi kmp(str s) {",
      "\tint N = sz(s); vi f(N+1); f[0] = -1;",
      "\tFOR(i,1,N+1) {",
      "\t\tfor (f[i]=f[i-1];f[i]!=-1&&s[f[i]]!=s[i-1])f[i]=f[f[i]];",
      "\t\tf[i] ++; }",
      "\treturn f;",
      "}",
      "vi getOc(str a, str b) { // find occurrences of a in b",
      "\tvi f = kmp(a+\"@\"+b), ret;",
      "\tFOR(i,sz(a),sz(b)+1) if (f[i+sz(a)+1] == sz(a)) ",
      "\t\tret.pb(i-sz(a));",
      "\treturn ret;",
      "}"
    ],
    "description": "None"
  },
  "LyndonFactor": {
    "prefix":["benq_LyndonFactor"],
    "body": [
      "/**",
      " * Description: ",
      "\t* A string is \"simple\" if it is strictly smaller than any of its own nontrivial suffixes.",
      "\t* The Lyndon factorization of the string \\$s\\$ is a factorization \\$s=w_1w_2\\ldots w_k\\$",
      "\t* where all strings \\$w_i\\$ are simple and \\$w_1\\ge w_2\\ge \\cdots \\ge w_k.\\$ Min rotation",
      "\t* gets min index i such that cyclic shift of s starting at i is minimum.",
      " * Source: https://cp-algorithms.com/string/lyndon_factorization.html",
      " * Time: O(N)",
      " * Verification: https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=660",
      " */",
      "",
      "vs duval(str s) {",
      "\tint n = sz(s); vs factors;",
      "\tfor (int i = 0; i < n; ) {",
      "\t\tint j = i+1, k = i;",
      "\t\tfor (; j < n && s[k] <= s[j]; j++) {",
      "\t\t\tif (s[k] < s[j]) k = i;",
      "\t\t\telse k ++;",
      "\t\t}",
      "\t\tfor (; i <= k; i += j-k) factors.pb(s.substr(i,j-k));",
      "\t}",
      "\treturn factors;",
      "}",
      "int minRotation(str s) { ",
      "\tint n = sz(s); s += s;",
      "\tauto d = duval(s); int ind = 0, ans = 0;",
      "\twhile (ans+sz(d[ind]) < n) ans += sz(d[ind++]);",
      "\twhile (ind && d[ind] == d[ind-1]) ans -= sz(d[ind--]);",
      "\treturn ans;",
      "}"
    ],
    "description": "* A string is \"simple\" if it is strictly smaller than any of its own nontrivial suffixes., * The Lyndon factorization of the string \\$s\\$ is a factorization \\$s=w_1w_2\\ldots w_k\\$, * where all strings \\$w_i\\$ are simple and \\$w_1\\ge w_2\\ge \\cdots \\ge w_k.\\$ Min rotation, * gets min index i such that cyclic shift of s starting at i is minimum., *"
  },
  "Manacher": {
    "prefix":["benq_Manacher"],
    "body": [
      "/**",
      " * Source: http://codeforces.com/blog/entry/12143",
      " * Time: O(N)",
      " * Description: length of largest palindrome centered at each character of string",
      " \t* and between every consecutive pair",
      " * Verification: http://www.spoj.com/problems/MSUBSTR/",
      " */",
      "",
      "vi manacher(str s) {",
      "\tstr s1 = \"@\"; each(c,s) s1 += c, s1 += \"#\";",
      "\ts1.bk = '&';",
      "\tvi ans(sz(s1)-1); int lo = 0, hi = 0;",
      "\tFOR(i,1,sz(s1)-1) {",
      "\t\tif (i != 1) ans[i] = min(hi-i,ans[hi-i+lo]);",
      "\t\twhile (s1[i-ans[i]-1] == s1[i+ans[i]+1]) ans[i] ++;",
      "\t\tif (i+ans[i] > hi) lo = i-ans[i], hi = i+ans[i];",
      "\t}",
      "\tans.erase(begin(ans));",
      "\tF0R(i,sz(ans)) if ((i&1) == (ans[i]&1)) ans[i] ++; ",
      "\treturn ans;",
      "} ",
      "/// Usage: ps(manacher(\"abacaba\"))"
    ],
    "description": "None"
  },
  "MinRotation": {
    "prefix":["benq_MinRotation"],
    "body": [
      "/**",
      " * Description: minimum cyclic shift",
      " * Time: O(N)",
      " * Source: KACTL",
      " * Verification: https://cses.fi/problemset/task/1110/",
      " */",
      " ",
      "int minRotation(str s) {",
      "\tint a = 0, N = sz(s); s += s;",
      "\tF0R(b,N) F0R(i,N) { ",
      "\t\t// a is current best rotation found up to b-1",
      "\t\tif (a+i==b || s[a+i]<s[b+i]) { b += max(0,i-1); break; } ",
      "\t\t// b to b+i-1 can't be better than a to a+i-1",
      "\t\tif (s[a+i] > s[b+i]) { a = b; break; } // new best found",
      "\t}",
      "\treturn a;",
      "}"
    ],
    "description": "minimum cyclic shift, * Time: O(N), *"
  },
  "ReverseBW": {
    "prefix":["benq_ReverseBW"],
    "body": [
      "/**",
      " * Description: Used only once. Burrows-Wheeler Transform appends ",
      " \t* \\# to a string, sorts the rotations of the string in increasing order, ",
      "\t* and constructs a new string that contains the last character ",
      "\t* of each rotation. This function reverses the transform.",
      " * Time: O(N\\log N)",
      " * Source: GeeksForGeeks",
      " * Verification: https://cses.fi/problemset/task/1113/",
      " */",
      "",
      "str reverseBW(str t) {",
      "\tvi nex(sz(t)); iota(all(nex),0);",
      "\tstable_sort(all(nex),[&t](int a,int b){return t[a]<t[b];});",
      "\tstr ret; for (int i = nex[0]; i; ) ",
      "\t\tret += t[i = nex[i]];",
      "\treturn ret;",
      "}"
    ],
    "description": "Used only once. Burrows-Wheeler Transform appends ,  * \\# to a string, sorts the rotations of the string in increasing order, , * and constructs a new string that contains the last character , * of each rotation. This function reverses the transform., * Time: O(N\\log N), *"
  },
  "SuffixArray": {
    "prefix":["benq_SuffixArray"],
    "body": [
      "/**",
      " * Description: Sort suffixes. First element of \\texttt{sa} is \\texttt{sz(S)},",
      " \t* \\texttt{isa} is the inverse of \\texttt{sa}, and \\texttt{lcp} stores",
      " \t* the longest common prefix between every two consecutive elements of \\texttt{sa}.",
      " * Time: O(N\\log N)",
      " * Source: SuprDewd, KACTL, majk, ekzhang (http://ekzlib.herokuapp.com)",
      " * Verification: ",
      "\t* https://open.kattis.com/problems/suffixsorting",
      "\t* https://judge.yosupo.jp/problem/suffixarray",
      " */",
      "",
      "#include \"RMQ.h\"",
      "",
      "struct SuffixArray {",
      "\tstr S; int N; vi sa, isa, lcp;",
      "\tvoid init(str _S) { N = sz(S = _S)+1; genSa(); genLcp(); }",
      "\tvoid genSa() {",
      "\t\tsa = isa = vi(N); sa[0] = N-1; iota(1+all(sa),0);",
      "\t\tsort(1+all(sa),[&](int a, int b) { return S[a] < S[b]; });",
      "\t\tFOR(i,1,N) { int a = sa[i-1], b = sa[i];",
      "\t\t\tisa[b] = i > 1 && S[a] == S[b] ? isa[a] : i; }",
      "\t\tfor (int len = 1; len < N; len *= 2) { // currently sorted by first len chars",
      "\t\t\tvi s(sa), is(isa), pos(N); iota(all(pos),0); ",
      "\t\t\teach(t,s) { int T = t-len; if (T >= 0) sa[pos[isa[T]]++] = T; }",
      "\t\t\tFOR(i,1,N) { int a = sa[i-1], b = sa[i];",
      "\t\t\t\tisa[b] = is[a] == is[b] && is[a+len] == is[b+len] ? isa[a] : i; }",
      "\t\t}",
      "\t}",
      "\tvoid genLcp() { // Kasai's Algo",
      "\t\tlcp = vi(N-1); int h = 0;",
      "\t\tF0R(b,N-1) { int a = sa[isa[b]-1];",
      "\t\t\twhile (a+h < sz(S) && S[a+h] == S[b+h]) h ++;",
      "\t\t\tlcp[isa[b]-1] = h; if (h) h--; }",
      "\t\tR.init(lcp); /// if we cut off first chars of two strings",
      "\t\t/// with lcp h then remaining portions still have lcp h-1 ",
      "\t}",
      "\tRMQ<int> R; ",
      "\tint getLCP(int a, int b) { // lcp of suffixes starting at a,b",
      "\t\tif (a == b) return sz(S)-a;",
      "\t\tint l = isa[a], r = isa[b]; if (l > r) swap(l,r);",
      "\t\treturn R.query(l,r-1);",
      "\t}",
      "};"
    ],
    "description": "Sort suffixes. First element of \\texttt{sa} is \\texttt{sz(S)},,  * \\texttt{isa} is the inverse of \\texttt{sa}, and \\texttt{lcp} stores,  * the longest common prefix between every two consecutive elements of \\texttt{sa}., * Time: O(N\\log N), *"
  },
  "SuffixArrayLinear": {
    "prefix":["benq_SuffixArrayLinear"],
    "body": [
      "/**",
      " * Description: Linear Time Suffix Array",
      " * Source: ",
      "\t* https://github.com/atcoder/ac-library/blob/master/atcoder/string.hpp",
      " \t* https://www.researchgate.net/publication/224176324_Two_Efficient_Algorithms_for_Linear_Time_Suffix_Array_Construction",
      " * Verification:",
      " \t* https://judge.yosupo.jp/problem/suffixarray",
      " */",
      "",
      "vi sa_is(const vi& s, int upper) {",
      "\tint n = sz(s); if (!n) return {};",
      "\tvi sa(n); vb ls(n); // is suffix starting at i < suffix starting at i+1",
      "\tR0F(i,n-1) ls[i] = s[i] == s[i+1] ? ls[i+1] : s[i] < s[i+1]; ",
      "\t// s-type: less than next suffix -> ls[i] = 1 ",
      "\t// l-type: greater than next suffix -> ls[i] = 0",
      "\tvi sum_l(upper), sum_s(upper);",
      "\tF0R(i,n) (ls[i] ? sum_l[s[i]+1] : sum_s[s[i]]) ++; // note that s[i] = upper-1 -> !ls[i]",
      "\tF0R(i,upper) { ",
      "\t\tif (i) sum_l[i] += sum_s[i-1]; // sum_l[i] = sum_{j=0}^{i-1}(s_j+l_j)",
      "\t\tsum_s[i] += sum_l[i]; // sum_s[i] = sum_{j=0}^{i-1}s_j+sum_{j=0}^{i}l_j",
      "\t}",
      "\tauto induce = [&](const vi& lms) {",
      "\t\tfill(all(sa),-1);",
      "\t\tvi buf = sum_s;",
      "\t\tfor (int d: lms) if (d != n) sa[buf[s[d]]++] = d; // lms is s-type, first few ...",
      "\t\tbuf = sum_l; sa[buf[s[n-1]]++] = n-1;",
      "\t\tF0R(i,n) { // do l-type in increasing order, suf[v] > suf[v+1]",
      "\t\t\tint v = sa[i]-1;",
      "\t\t\tif (v >= 0 && !ls[v]) sa[buf[s[v]]++] = v;",
      "\t\t}",
      "\t\tbuf = sum_l;",
      "\t\tR0F(i,n) { // do s-type in decreasing order, suf[v] < suf[v+1]",
      "\t\t\tint v = sa[i]-1;",
      "\t\t\tif (v >= 0 && ls[v]) sa[--buf[s[v]+1]] = v; // lms is s-type, last few ...",
      "\t\t}",
      "\t};",
      "\tvi lms_map(n+1,-1), lms; int m = 0;",
      "\tFOR(i,1,n) if (!ls[i-1] && ls[i]) lms_map[i] = m++, lms.pb(i);",
      "\tinduce(lms); // sorts LMS prefixes",
      "\tvi sorted_lms; each(v,sa) if (lms_map[v] != -1) sorted_lms.pb(v);",
      "\tvi rec_s(m); int rec_upper = 0; // smaller subproblem",
      "\tFOR(i,1,m) { // compare two lms substrings in sorted order",
      "\t\tint l = sorted_lms[i-1], r = sorted_lms[i];",
      "\t\tint end_l = lms_map[l]+1 < m ? lms[lms_map[l]+1] : n;",
      "\t\tint end_r = lms_map[r]+1 < m ? lms[lms_map[r]+1] : n;",
      "\t\tbool same = 0; // whether lms substrings are same",
      "\t\tif (end_l-l == end_r-r) {",
      "\t\t\tfor (;l < end_l && s[l] == s[r]; ++l,++r);",
      "\t\t\tif (l != n && s[l] == s[r]) same = 1;",
      "\t\t}",
      "\t\trec_s[lms_map[sorted_lms[i]]] = (rec_upper += !same);",
      "\t}",
      "\tvi rec_sa = sa_is(rec_s,rec_upper+1);",
      "\tF0R(i,m) sorted_lms[i] = lms[rec_sa[i]];",
      "\tinduce(sorted_lms); // sorts LMS suffixes",
      "\treturn sa;",
      "}"
    ],
    "description": "Linear Time Suffix Array, *"
  },
  "TandemRepeats": {
    "prefix":["benq_TandemRepeats"],
    "body": [
      "/**",
      " * Description: Find all \\$(i,p)\\$ such that ",
      " \t* \\texttt{s.substr(i,p) == s.substr(i+p,p)}. No two intervals",
      " \t* with the same period intersect or touch.",
      " * Time: O(N\\log N)",
      " * Source: https://codeforces.com/gym/102012/submission/54638473",
      " * Verification: GP of Nanjing 2020 D - String Theory",
      " \t* https://judge.yosupo.jp/problem/runenumerate",
      " */",
      "",
      "#include \"SuffixArray.h\"",
      "",
      "vector<array<int,3>> solve(str s) {",
      "\tint N = sz(s); SuffixArray A,B; ",
      "\tA.init(s); reverse(all(s)); B.init(s);",
      "\tvector<array<int,3>> runs;",
      "\tfor (int p = 1; 2*p <= N; ++p) { // do in O(N/p) for period p",
      "\t\tfor (int i = 0, lst = -1; i+p <= N; i += p) {",
      "\t\t\tint l = i-B.getLCP(N-i-p,N-i), r = i-p+A.getLCP(i,i+p);",
      "\t\t\tif (l > r || l == lst) continue;",
      "\t\t\truns.pb({lst = l,r,p}); // for each i in [l,r],",
      "\t\t} // s.substr(i,p) == s.substr(i+p,p)",
      "\t}",
      "\treturn runs;",
      "} // ps(solve(\"aaabababa\"));"
    ],
    "description": "Find all \\$(i,p)\\$ such that ,  * \\texttt{s.substr(i,p) == s.substr(i+p,p)}. No two intervals,  * with the same period intersect or touch., * Time: O(N\\log N), *"
  },
  "Trie": {
    "prefix":["benq_Trie"],
    "body": [
      "/**",
      " * Description: insert int, query max xor with some int in the trie",
      " * Time: O(MXBIT)",
      " * Source: CF Algorithms Gym",
      " * Verification: January Easy 2018 - Shubham and Subarray Xor",
      " */",
      "",
      "template<int SZ, int MXBIT> struct Trie {",
      "\tint nex[SZ][2], sz[SZ], num = 0; // num is last node in trie",
      "\t// change 2 to 26 for lowercase letters",
      "\tTrie() { memset(nex,0,sizeof nex); memset(sz,0,sizeof sz); }",
      "\tvoid ins(ll x, int a = 1) { // insert or delete",
      "\t\tint cur = 0; sz[cur] += a;",
      "\t\tR0F(i,MXBIT) {",
      "\t\t\tint t = (x>>i)&1;",
      "\t\t\tif (!nex[cur][t]) nex[cur][t] = ++num;",
      "\t\t\tsz[cur = nex[cur][t]] += a;",
      "\t\t}",
      "\t}",
      "\tll test(ll x) { // compute max xor",
      "\t\tif (!sz[0]) return -INF; // no elements in trie",
      "\t\tint cur = 0;",
      "\t\tR0F(i,MXBIT) {",
      "\t\t\tint t = ((x>>i)&1)^1;",
      "\t\t\tif (!nex[cur][t] || !sz[nex[cur][t]]) t ^= 1;",
      "\t\t\tcur = nex[cur][t]; if (t) x ^= 1LL<<i;",
      "\t\t}",
      "\t\treturn x;",
      "\t}",
      "};"
    ],
    "description": "insert int, query max xor with some int in the trie, * Time: O(MXBIT), *"
  },
  "TrieAlpha": {
    "prefix":["benq_TrieAlpha"],
    "body": [
      "/**",
      " * Description: insert string of lowercase letters",
      " */",
      "",
      "template<int SZ> struct TrieAlpha {",
      "\tint nex[SZ][26], sz[SZ], num = 0; // num is last node in trie",
      "\t// change 2 to 26 for lowercase letters",
      "\tTrieAlpha() { memset(nex,0,sizeof nex); memset(sz,0,sizeof sz); }",
      "\tvoid ins(str x, int a) { // insert or delete",
      "\t\tint cur = 0; sz[cur] += a;",
      "\t\tF0R(i,sz(x)) {",
      "\t\t\tint t = x[i]-'a';",
      "\t\t\tif (!nex[cur][t]) nex[cur][t] = ++num;",
      "\t\t\tsz[cur = nex[cur][t]] += a;",
      "\t\t}",
      "\t}",
      "};"
    ],
    "description": "None"
  },
  "Z": {
    "prefix":["benq_Z"],
    "body": [
      "/**",
      " * Description: \\texttt{f[i]} is the max \\texttt{len} such that ",
      " \t* \\texttt{s.substr(0,len) == s.substr(i,len)}",
      " * Time: O(N)",
      " * Source: http://codeforces.com/blog/entry/3107",
      " * Verification: POI 12 Template, https://codeforces.com/contest/1137/problem/B",
      " */",
      "",
      "vi z(str s) {",
      "\tint N = sz(s), L = 1, R = 0; s += '#';",
      "\tvi ans(N); ans[0] = N; ",
      "\tFOR(i,1,N) {",
      "\t\tif (i <= R) ans[i] = min(R-i+1,ans[i-L]);",
      "\t\twhile (s[i+ans[i]] == s[ans[i]]) ans[i] ++;",
      "\t\tif (i+ans[i]-1 > R) L = i, R = i+ans[i]-1;",
      "\t}",
      "\treturn ans;",
      "}",
      "vi getPrefix(str a, str b) { // find prefixes of a in b",
      "\tvi t = z(a+b); t = vi(sz(a)+all(t)); ",
      "\teach(u,t) ckmin(u,sz(a));",
      "\treturn t;",
      "}",
      "/// Usage: pr(z(\"abcababcabcaba\"),getPrefix(\"abcab\",\"uwetrabcerabcab\"));"
    ],
    "description": "\\texttt{f[i]} is the max \\texttt{len} such that ,  * \\texttt{s.substr(0,len) == s.substr(i,len)}, * Time: O(N), *"
  },
  "BumpAllocator": {
    "prefix":["benq_BumpAllocator"],
    "body": [
      "/**",
      " * Description: When you need to dynamically allocate many objects and don't care about freeing them.",
      " \t* \"new X\" otherwise has an overhead of something like 0.05us + 16 bytes per allocation.",
      " * Source: Simon Lindholm ",
      " * Status: tested",
      " */",
      "",
      "// Either globally or in a single class:",
      "static char buf[450 << 20];",
      "void* operator new(size_t s) {",
      "\tstatic size_t i = sizeof buf; assert(s < i);",
      "\treturn (void*)&buf[i -= s];",
      "}",
      "void operator delete(void*) {}"
    ],
    "description": "When you need to dynamically allocate many objects and don't care about freeing them.,  * \"new X\" otherwise has an overhead of something like 0.05us + 16 bytes per allocation., *"
  },
  "BumpAllocatorSTL": {
    "prefix":["benq_BumpAllocatorSTL"],
    "body": [
      "/**",
      " * Description: Unused. BumpAllocator for STL containers.",
      " * Source: Simon Lindholm",
      " * Usage: vector<vector<int, small<int>>> ed(N);",
      " * Status: tested",
      " */",
      "",
      "char buf[450 << 20] alignas(16);",
      "size_t buf_ind = sizeof buf;",
      "template<class T> struct small {",
      "\ttypedef T value_type;",
      "\tsmall() {}",
      "\ttemplate<class U> small(const U&) {}",
      "\tT* allocate(size_t n) {",
      "\t\tbuf_ind -= n * sizeof(T);",
      "\t\tbuf_ind &= 0 - alignof(T);",
      "\t\treturn (T*)(buf + buf_ind);",
      "\t}",
      "\tvoid deallocate(T*, size_t) {}",
      "};"
    ],
    "description": "Unused. BumpAllocator for STL containers., *"
  },
  "CircLCS": {
    "prefix":["benq_CircLCS"],
    "body": [
      "/**",
      " * Description: Used only twice. For strs \\$a,b\\$ calculates ",
      " \t* longest common subsequence of \\$a\\$ with all rotations of \\$b\\$",
      " * Time: O(|A|\\cdot |B|)",
      " * Source: gs14004, oj.uz",
      " * Verification: https://oj.uz/problem/view/IZhO13_rowords",
      " \t* also see B from https://codeforces.com/gym/101657/standings",
      " */",
      "",
      "str A,B; V<vi> dp, dir; // DP values for normal LCS, which direction values came from",
      "void init() {",
      "\tdp = dir = V<vi>(sz(A)+1,vi(sz(B)+1));",
      "\tFOR(i,1,sz(A)+1) FOR(j,1,sz(B)+1) {",
      "\t\tdp[i][j] = dp[i-1][j];",
      "\t\tif (A[i-1] == B[j-1] && ckmax(dp[i][j],dp[i-1][j-1]+1)) dir[i][j] = 1;",
      "\t\tif (ckmax(dp[i][j],dp[i][j-1])) dir[i][j] = 2;",
      "\t}",
      "}",
      "int get_ans(pi p) { // get current LCS",
      "\tint ans = 0;",
      "\twhile (p.f) {",
      "\t\tif (dir[p.f][p.s] == 2) p.s --;",
      "\t\telse if (dir[p.f][p.s] == 1) p.f --, p.s --, ans ++;",
      "\t\telse p.f --;",
      "\t}",
      "\treturn ans;",
      "}",
      "void remove_char(int ind) { // remove column of DP table, fix dirs",
      "\tfor (pi cur{0,ind}; cur.s < sz(B);) { // decrease some suffix of each column",
      "\t\tif (dir[cur.f][cur.s+1] == 2) dir[cur.f][++cur.s] = 0; // move to next column",
      "\t\telse {",
      "\t\t\tif (cur.f == sz(A)) break;",
      "\t\t\tif (dir[++cur.f][cur.s+1] == 1) dir[cur.f][++cur.s] = 0; // move to next column, increase by one",
      "\t\t}",
      "\t}",
      "}",
      "int circ_lcs(str a, str b) {",
      "\tA = a, B = b+b; init();",
      "\tint ans = 0;",
      "\tF0R(i,sz(b)) {",
      "\t\tckmax(ans,get_ans({sz(a),i+sz(b)}));",
      "\t\tremove_char(i);",
      "\t}",
      "\treturn ans;",
      "}"
    ],
    "description": "Used only twice. For strs \\$a,b\\$ calculates ,  * longest common subsequence of \\$a\\$ with all rotations of \\$b\\$, * Time: O(|A|\\cdot |B|), *"
  },
  "DynaLIS": {
    "prefix":["benq_DynaLIS"],
    "body": [
      "/**",
      " * Description: Insert and delete elements from any position. \\texttt{sz(v)-1=min(k,length of LIS)}.",
      " * Time: O(k(n+q)\\log n)",
      " * Source: https://arxiv.org/abs/1309.7724",
      "   * https://codeforces.com/blog/entry/75266?",
      " * Verification: GP of Wroclaw 2020 D",
      " */",
      "",
      "int n,k;",
      "vi c, lef;",
      "vector<pt> v;",
      "vector<bool> in;",
      "",
      "struct tnode {",
      "\tint pri, x; pt c[2]; // essential",
      "\ttnode (int _x) {",
      "\t\tpri = rng(); x = _x;",
      "\t\tc[0] = c[1] = NULL;",
      "\t}",
      "};",
      "void tour(pt x, vi& v) { // print values of nodes, ",
      "\tif (!x) return; // inorder traversal",
      "\ttour(x->c[0],v); v.pb(x->x); tour(x->c[1],v);",
      "}",
      "pair<pt,pt> split(pt t, int v) { // split by x, >= v goes to the right",
      "\tif (!t) return {t,t};",
      "\tif (t->x >= v) {",
      "\t\tauto p = split(t->c[0], v); t->c[0] = p.s;",
      "\t\treturn {p.f,t};",
      "\t} else {",
      "\t\tauto p = split(t->c[1], v); t->c[1] = p.f;",
      "\t\treturn {t,p.s};",
      "\t}",
      "}",
      "pair<pt,pt> splitY(pt t, int v) { // <= v goes to right",
      "\tif (!t) return {t,t};",
      "\tif (c[t->x] <= v) {",
      "\t\tauto p = splitY(t->c[0], v); t->c[0] = p.s;",
      "\t\treturn {p.f,t};",
      "\t} else {",
      "\t\tauto p = splitY(t->c[1], v); t->c[1] = p.f;",
      "\t\treturn {t,p.s};",
      "\t}",
      "}",
      "pt merge(pt l, pt r) { // merge treaps, keys in left < keys in right",
      "\tif (!l || !r) return l?:r;",
      "\tpt t;",
      "\tif (l->pri > r->pri) l->c[1] = merge(l->c[1],r), t = l;",
      "\telse r->c[0] = merge(l,r->c[0]), t = r;",
      "\treturn t;",
      "}",
      "int firstX(pt p) { // min x in treap",
      "\tif (!p) return MOD;",
      "\twhile (p->c[0]) p = p->c[0];",
      "\treturn p->x;",
      "} ",
      "int lastY(pt p) { // min c-value in treap",
      "\tif (!p) return MOD;",
      "\twhile (p->c[1]) p = p->c[1];",
      "\treturn c[p->x];",
      "} ",
      "int minY(pt& a, int x) { // min y across < x",
      "\tauto b = split(a,x); int res = lastY(b.f);",
      "\ta = merge(b.f,b.s); return res;",
      "} ",
      "",
      "vi vec(pt p) { vi u; tour(p,u); return u; } // for debugging",
      "pair<pt,pt> getIns(pt a, pt b) {",
      "\tif (!b) return {a,NULL};",
      "\tauto x = split(a,firstX(b));",
      "\tauto y = splitY(x.s,lastY(b)); // > on left, <= on right",
      "\treturn {merge(x.f,merge(b,y.s)),y.f}; // same, not same",
      "}",
      "pair<pair<pt,pt>,pi> getDel(pt a, int nexX, int nexY) {",
      "\tauto x = split(a,nexX), y = splitY(x.f,nexY);",
      "\tint NEXx = firstX(x.s), NEXy = lastY(y.f);",
      "\treturn {{merge(y.f,x.s),y.s},{NEXx,NEXy}};",
      "}",
      "pt insMid(pt a, pt b) {",
      "\tif (!b) return a;",
      "\tauto x = split(a,b->x);",
      "\treturn merge(merge(x.f,b),x.s);",
      "}",
      "void DEL(int ind, int nexX, int nexY) {",
      "\tif (ind >= sz(v)) return;",
      "\tpair<pt,pt> z; pi oops;",
      "\ttie(z,oops) = getDel(v[ind],nexX,nexY);",
      "\tv[ind-1] = insMid(v[ind-1],z.s); v[ind] = z.f;",
      "\tDEL(ind+1,oops.f,oops.s);",
      "}",
      "",
      "bool inside(pt& a, int b) {",
      "\tauto x = split(a,b), y = split(x.s,b+1);",
      "\tbool ok = (y.f != NULL); ",
      "\ta = merge(x.f,merge(y.f,y.s));",
      "\treturn ok;",
      "}",
      "",
      "void del(int x) {",
      "\tassert(in[x]); in[x] = 0; lef.pb(x);",
      "\tint ind = 0; while (ind < sz(v) && !inside(v[ind],x)) ind ++;",
      "\tauto a = split(v[ind],x), b = split(a.s,x+1);",
      "\tint nexX = firstX(b.s), nexY = lastY(a.f);",
      "\tv[ind] = merge(a.f,b.s);",
      "\tDEL(ind+1,nexX,nexY);",
      "\twhile (!v.bk) v.pop_back();",
      "}",
      "",
      "void INS(int ind, pt p) { // OK",
      "\tif (!p) return;",
      "\tif (ind >= sz(v)) v.pb(NULL);",
      "\tpair<pt,pt> z = getIns(v[ind],p);",
      "\tv[ind] = z.f; INS(ind+1,z.s);",
      "}",
      "",
      "void ins(int x) {",
      "\tassert(!in[x]); in[x] = 1;",
      "\tint ind = 0; ",
      "\twhile (ind+1 < sz(v) && minY(v[ind+1],x) < c[x]) ind ++;",
      "\tINS(ind+1,new tnode(x));",
      "}",
      "",
      "void solve() {",
      "\tre(n,k); c.rsz(n+1); FOR(i,1,n+1) re(c[i]);",
      "\tlef.clear(); FOR(i,1,n+1) lef.pb(i);",
      "\tin = vector<bool>(n+1);",
      "\tv = {new tnode(0)};",
      "\tint q; re(q);",
      "\tF0R(i,q) {",
      "\t\tint p,val; re(p,val);",
      "\t\tif (in[p]) del(p);",
      "\t\tc[p] = val;",
      "\t\twhile (sz(lef) && sz(v) <= k) {",
      "\t\t\tins(lef.bk);",
      "\t\t\tlef.pop_back();",
      "\t\t}",
      "\t\tps(sz(v)-1);",
      "\t}",
      "}"
    ],
    "description": "Insert and delete elements from any position. \\texttt{sz(v)-1=min(k,length of LIS)}., * Time: O(k(n+q)\\log n), *"
  },
  "FastIO": {
    "prefix":["benq_FastIO"],
    "body": [
      "/**",
      " * Description: Fast input and output.",
      " * Time: input is \\$\\sim\\$300ms faster for \\$10^6\\$ long longs on CF",
      " * Source: ",
      " \t* https://codeforces.com/gym/102394/submission/64154785",
      " \t* https://codeforces.com/contest/1254/submission/65420506 (neal)",
      " \t* https://codeforces.com/blog/entry/45835 (AI.Cash)",
      " * Verification: https://codeforces.com/gym/102394/problem/G ",
      " */",
      "",
      "namespace FastIO {",
      "\tconst int BSZ = 1<<15; ////// INPUT",
      "\tchar ibuf[BSZ]; int ipos, ilen;",
      "\tchar nc() { // next char",
      "\t\tif (ipos == ilen) {",
      "\t\t\tipos = 0; ilen = fread(ibuf,1,BSZ,stdin);",
      "\t\t\tif (!ilen) return EOF;",
      "\t\t}",
      "\t\treturn ibuf[ipos++];",
      "\t}",
      "\tvoid rs(str& x) { // read str",
      "\t\tchar ch; while (isspace(ch = nc()));",
      "\t\tdo { x += ch; } while (!isspace(ch = nc()) && ch != EOF);",
      "\t}",
      "\ttemplate<class T> void ri(T& x) { // read int or ll",
      "\t\tchar ch; int sgn = 1;",
      "\t\twhile (!isdigit(ch = nc())) if (ch == '-') sgn *= -1;",
      "\t\tx = ch-'0'; while (isdigit(ch = nc())) x = x*10+(ch-'0');",
      "\t\tx *= sgn;",
      "\t}",
      "\ttemplate<class T, class... Ts> void ri(T& t, Ts&... ts) { ",
      "\t\tri(t); ri(ts...); } // read ints",
      "\t////// OUTPUT (call initO() at start)",
      "\tchar obuf[BSZ], numBuf[100]; int opos;",
      "\tvoid flushOut() { fwrite(obuf,1,opos,stdout); opos = 0; }",
      "\tvoid wc(char c) { // write char",
      "\t\tif (opos == BSZ) flushOut();",
      "\t\tobuf[opos++] = c; }",
      "\tvoid ws(str s) { each(c,s) wc(c); } // write str",
      "\ttemplate<class T> void wi(T x, char after = '\\0') { /// write int",
      "\t\tif (x < 0) wc('-'), x *= -1;",
      "\t\tint len = 0; for (;x>=10;x/=10) numBuf[len++] = '0'+(x%10);",
      "\t\twc('0'+x); R0F(i,len) wc(numBuf[i]);",
      "\t\tif (after) wc(after);",
      "\t}",
      "\tvoid initO() { assert(atexit(flushOut) == 0); } /// auto-flush output",
      "}",
      "/// using namespace FastIO;",
      "/// initO(); int a,b; ri(a,b); wi(b,'\\n'); wi(a,'\\n'); "
    ],
    "description": "Fast input and output., * Time: input is \\$\\sim\\$300ms faster for \\$10^6\\$ long longs on CF, *"
  },
  "Knapsack": {
    "prefix":["benq_Knapsack"],
    "body": [
      "/**",
      " * Description: Linear Time Knapsack w/ Bounded Weights",
      " * Time: O(N\\cdot (\\text{max weight}))",
      " * Source: ",
      " \t* https://chaoxuprime.com/posts/2018-12-18-subset-sum-through-balancing.html",
      " \t* https://stackoverflow.com/questions/18821453/bounded-knapsack-special-case-small-individual-item-weight-is-small-compared-t",
      " * Verification: GP of Bytedance 2020 F",
      " */",
      "",
      "const int BIG = 20000;",
      "array<int,2*BIG+1> dp, tmp;",
      "",
      "int solve(vi a) {",
      "\tint n = sz(a), ind = 0, sum = 0;",
      "\twhile (ind < n && sum+a[ind] <= c) sum += a[ind++];",
      "\tif (ind == n) return sum;",
      "\tF0R(i,2*BIG+1) dp[i] = ind+1, tmp[i] = ind;",
      "\tdp[BIG+sum-c] = 0;",
      "\tFOR(i,ind,n) {",
      "\t\tR0F(j,BIG+1) ckmin(dp[j+a[i]],dp[j]);",
      "\t\tROF(j,BIG,2*BIG+1) while (tmp[j] > dp[j]) ",
      "\t\t\ttmp[j] --, ckmin(dp[j-a[tmp[j]]],tmp[j]+1);",
      "\t}",
      "\tR0F(i,BIG+1) if (dp[i] != ind+1) return c+i-BIG; // must return",
      "}"
    ],
    "description": "Linear Time Knapsack w/ Bounded Weights, * Time: O(N\\cdot (\\text{max weight})), *"
  },
  "Ops": {
    "prefix":["benq_Ops"],
    "body": [
      "/**",
      " * Description: operations with pairs / arrays (LOL is there a better way to do this)",
      " * Source: own",
      " * Verification: ?",
      " */",
      "",
      "template<class A, class B> pair<A,B> operator+(const pair<A,B>& l, const pair<A,B>& r) { return {l.f+r.f,l.s+r.s}; }",
      "template<class A, class B> pair<A,B> operator-(const pair<A,B>& l, const pair<A,B>& r) { return {l.f-r.f,l.s-r.s}; }",
      "template<class A, class B> pair<A,B> operator*(const pair<A,B>& l, const pair<A,B>& r) { return {l.f*r.f,l.s*r.s}; }",
      "template<class A, class B> pair<A,B> operator/(const pair<A,B>& l, const pair<A,B>& r) { return {l.f/r.f,l.s/r.s}; }",
      "template<class A, class B> pair<A,B>& operator+=(pair<A,B>& l, const pair<A,B>& r) { return l = l+r; }",
      "template<class A, class B> pair<A,B>& operator-=(pair<A,B>& l, const pair<A,B>& r) { return l = l-r; }",
      "template<class A, class B> pair<A,B>& operator*=(pair<A,B>& l, const pair<A,B>& r) { return l = l*r; }",
      "template<class A, class B> pair<A,B>& operator/=(pair<A,B>& l, const pair<A,B>& r) { return l = l/r; }",
      "",
      "template<class A, class B, class C> pair<A,B> operator*(const pair<A,B>& l, const C& r) { return {l.f*r,l.s*r}; }",
      "template<class A, class B, class C> pair<A,B> operator/(const pair<A,B>& l, const C& r) { return {l.f/r,l.s/r}; }",
      "template<class A, class B, class C> pair<A,B>& operator*=(pair<A,B>& l, const C& r) { return l = l*r; }",
      "template<class A, class B, class C> pair<A,B>& operator/=(pair<A,B>& l, const C& r) { return l = l/r; }",
      "",
      "template<class T, size_t SZ> array<T,SZ>& operator+=(array<T,SZ>& l, const array<T,SZ>& r) {",
      "\tF0R(i,SZ) l[i] += r[i]; ",
      "\treturn l; }",
      "template<class T, size_t SZ> array<T,SZ>& operator-=(array<T,SZ>& l, const array<T,SZ>& r) {",
      "\tF0R(i,SZ) l[i] -= r[i]; ",
      "\treturn l; }",
      "template<class T, size_t SZ> array<T,SZ>& operator*=(array<T,SZ>& l, const array<T,SZ>& r) {",
      "\tF0R(i,SZ) l[i] *= r[i]; ",
      "\treturn l; }",
      "template<class T, size_t SZ> array<T,SZ>& operator/=(array<T,SZ>& l, const array<T,SZ>& r) {",
      "\tF0R(i,SZ) l[i] /= r[i]; ",
      "\treturn l; }",
      "template<class T, size_t SZ> array<T,SZ> operator+(array<T,SZ> l, const array<T,SZ>& r) { return l += r; }",
      "template<class T, size_t SZ> array<T,SZ> operator-(array<T,SZ> l, const array<T,SZ>& r) { return l -= r; }",
      "template<class T, size_t SZ> array<T,SZ> operator*(array<T,SZ> l, const array<T,SZ>& r) { return l *= r; }",
      "template<class T, size_t SZ> array<T,SZ> operator/(array<T,SZ> l, const array<T,SZ>& r) { return l /= r; }",
      "",
      "template<class T, size_t SZ> array<T,SZ>& operator*=(array<T,SZ>& l, const T& r) { ",
      "\tF0R(i,SZ) l[i] *= r;",
      "\treturn l; }",
      "template<class T, size_t SZ> array<T,SZ>& operator/=(array<T,SZ>& l, const T& r) { ",
      "\tF0R(i,SZ) l[i] /= r; ",
      "\treturn l; }",
      "template<class T, size_t SZ> array<T,SZ> operator*(array<T,SZ> l, const T& r) { return l *= r; }",
      "template<class T, size_t SZ> array<T,SZ> operator/(array<T,SZ> l, const T& r) { return l /= r; }",
      "",
      "// // pi a = {4,5};",
      "// // a *= 3;",
      "// // ps(a);",
      "// // ps(a*4);",
      "// // array<int,3> a = {3,4,5}, b = {1,2,1};",
      "// // a *= 3; ps(a);",
      "// // ps(a*(int)4);",
      "// // ps(a);",
      "// // ps(a/b);",
      "// // ps(a);",
      "// // a /= b;",
      "// // ps(a);",
      "// array<int,3> a = {30,40,50}, b = {1,2,3};",
      "// ps(a);",
      "// ps(a/b);",
      "// a /= b;",
      "// ps(a);",
      "// ps(a*3);",
      "// a *= 3;",
      "// ps(a);"
    ],
    "description": "operations with pairs / arrays (LOL is there a better way to do this), *"
  },
  "SmallPtr": {
    "prefix":["benq_SmallPtr"],
    "body": [
      "/**",
      " * Description: Unused. A 32-bit pointer that points into BumpAllocator memory.",
      " * Source: Simon Lindholm",
      " * Status: tested",
      " */",
      "",
      "#include \"BumpAllocator.h\"",
      "",
      "template<class T> struct ptr {",
      "\tunsigned ind;",
      "\tptr(T* p = 0) : ind(p ? unsigned((char*)p - buf) : 0) {",
      "\t\tassert(ind < sizeof buf); }",
      "\tT& operator*() const { return *(T*)(buf + ind); }",
      "\tT* operator->() const { return &**this; }",
      "\tT& operator[](int a) const { return (&**this)[a]; }",
      "\texplicit operator bool() const { return ind; }",
      "};"
    ],
    "description": "Unused. A 32-bit pointer that points into BumpAllocator memory., *"
  },
  "SMAWK": {
    "prefix":["benq_SMAWK"],
    "body": [
      "/**",
      " * Description: Given negation of totally monotone matrix with entries of type \\texttt{D}, ",
      " \t* find indices of row maxima (their indices increase for every submatrix). ",
      " \t* If tie, take lesser index. \\texttt{f} returns matrix entry at \\$(r,c)\\$ in \\$O(1)\\$. ",
      " \t* Use in place of divide \\& conquer to remove a log factor.",
      " * Source: maroonrk",
      " \t* https://www.codechef.com/viewsolution/29003911",
      " \t* https://en.wikipedia.org/wiki/SMAWK_algorithm",
      " \t* http://web.cs.unlv.edu/larmore/Courses/CSC477/monge.pdf",
      " * Time: \\$O(R+C)\\$, can be reduced to \\$O(C(1+\\log R/C))\\$ evaluations of \\$f\\$",
      " * Verification: https://www.codechef.com/viewsolution/32034859",
      " */",
      "",
      "template<class F, class D=ll> vi smawk (F f, vi x, vi y) {",
      "\tvi ans(sz(x),-1); // x = rows, y = cols",
      "\t#define upd() if (ans[i] == -1 || w > mx) ans[i] = c, mx = w",
      "\tif (min(sz(x),sz(y)) <= 8) {",
      "\t\tF0R(i,sz(x)) { int r = x[i]; D mx; ",
      "\t\t\teach(c,y) { D w = f(r,c); upd(); } }",
      "\t\treturn ans; ",
      "\t}",
      "\tif (sz(x) < sz(y)) { // reduce subset of cols to consider",
      "\t\tvi Y; each(c,y) {",
      "\t\t\tfor (;sz(Y);Y.pop_back()) { int X = x[sz(Y)-1]; ",
      "\t\t\t\tif (f(X,Y.bk) >= f(X,c)) break; }",
      "\t\t\tif (sz(Y) < sz(x)) Y.pb(c);",
      "\t\t} y = Y;",
      "\t} // recurse on half the rows",
      "\tvi X; for (int i = 1; i < sz(x); i += 2) X.pb(x[i]);",
      "\tvi ANS = smawk(f,X,y); F0R(i,sz(ANS)) ans[2*i+1] = ANS[i];",
      "\tfor (int i = 0, k = 0; i < sz(x); i += 2){",
      "\t\tint to = i+1 < sz(ans) ? ans[i+1] : y.bk; D mx;",
      "\t\tfor(int r = x[i];;++k) {",
      "\t\t\tint c = y[k]; D w = f(r,c); upd();",
      "\t\t\tif (c == to) break; }",
      "\t}",
      "\treturn ans;",
      "};"
    ],
    "description": "Given negation of totally monotone matrix with entries of type \\texttt{D}, ,  * find indices of row maxima (their indices increase for every submatrix). ,  * If tie, take lesser index. \\texttt{f} returns matrix entry at \\$(r,c)\\$ in \\$O(1)\\$. ,  * Use in place of divide \\& conquer to remove a log factor., *"
  }
}
